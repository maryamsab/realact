# This file was automatically generated by SWIG (http://www.swig.org).
# Version 2.0.9
#
# Do not make changes to this file unless you know what you are doing--modify
# the SWIG interface file instead.



from sys import version_info
if version_info >= (2,6,0):
    def swig_import_helper():
        from os.path import dirname
        import imp
        fp = None
        try:
            fp, pathname, description = imp.find_module('_yarp', [dirname(__file__)])
        except ImportError:
            import _yarp
            return _yarp
        if fp is not None:
            try:
                _mod = imp.load_module('_yarp', fp, pathname, description)
            finally:
                fp.close()
            return _mod
    _yarp = swig_import_helper()
    del swig_import_helper
else:
    import _yarp
del version_info
try:
    _swig_property = property
except NameError:
    pass # Python < 2.2 doesn't have 'property'.
def _swig_setattr_nondynamic(self,class_type,name,value,static=1):
    if (name == "thisown"): return self.this.own(value)
    if (name == "this"):
        if type(value).__name__ == 'SwigPyObject':
            self.__dict__[name] = value
            return
    method = class_type.__swig_setmethods__.get(name,None)
    if method: return method(self,value)
    if (not static):
        self.__dict__[name] = value
    else:
        raise AttributeError("You cannot add attributes to %s" % self)

def _swig_setattr(self,class_type,name,value):
    return _swig_setattr_nondynamic(self,class_type,name,value,0)

def _swig_getattr(self,class_type,name):
    if (name == "thisown"): return self.this.own()
    method = class_type.__swig_getmethods__.get(name,None)
    if method: return method(self)
    raise AttributeError(name)

def _swig_repr(self):
    try: strthis = "proxy of " + self.this.__repr__()
    except: strthis = ""
    return "<%s.%s; %s >" % (self.__class__.__module__, self.__class__.__name__, strthis,)

try:
    _object = object
    _newclass = 1
except AttributeError:
    class _object : pass
    _newclass = 0


try:
    import weakref
    weakref_proxy = weakref.proxy
except:
    weakref_proxy = lambda x: x


class SwigPyIterator(_object):
    """Proxy of C++ swig::SwigPyIterator class"""
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, SwigPyIterator, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, SwigPyIterator, name)
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _yarp.delete_SwigPyIterator
    __del__ = lambda self : None;
    def value(self):
        """value(SwigPyIterator self) -> PyObject *"""
        return _yarp.SwigPyIterator_value(self)

    def incr(self, n=1):
        """
        incr(SwigPyIterator self, size_t n=1) -> SwigPyIterator
        incr(SwigPyIterator self) -> SwigPyIterator
        """
        return _yarp.SwigPyIterator_incr(self, n)

    def decr(self, n=1):
        """
        decr(SwigPyIterator self, size_t n=1) -> SwigPyIterator
        decr(SwigPyIterator self) -> SwigPyIterator
        """
        return _yarp.SwigPyIterator_decr(self, n)

    def distance(self, *args):
        """distance(SwigPyIterator self, SwigPyIterator x) -> ptrdiff_t"""
        return _yarp.SwigPyIterator_distance(self, *args)

    def equal(self, *args):
        """equal(SwigPyIterator self, SwigPyIterator x) -> bool"""
        return _yarp.SwigPyIterator_equal(self, *args)

    def copy(self):
        """copy(SwigPyIterator self) -> SwigPyIterator"""
        return _yarp.SwigPyIterator_copy(self)

    def next(self):
        """next(SwigPyIterator self) -> PyObject *"""
        return _yarp.SwigPyIterator_next(self)

    def __next__(self):
        """__next__(SwigPyIterator self) -> PyObject *"""
        return _yarp.SwigPyIterator___next__(self)

    def previous(self):
        """previous(SwigPyIterator self) -> PyObject *"""
        return _yarp.SwigPyIterator_previous(self)

    def advance(self, *args):
        """advance(SwigPyIterator self, ptrdiff_t n) -> SwigPyIterator"""
        return _yarp.SwigPyIterator_advance(self, *args)

    def __eq__(self, *args):
        """__eq__(SwigPyIterator self, SwigPyIterator x) -> bool"""
        return _yarp.SwigPyIterator___eq__(self, *args)

    def __ne__(self, *args):
        """__ne__(SwigPyIterator self, SwigPyIterator x) -> bool"""
        return _yarp.SwigPyIterator___ne__(self, *args)

    def __iadd__(self, *args):
        """__iadd__(SwigPyIterator self, ptrdiff_t n) -> SwigPyIterator"""
        return _yarp.SwigPyIterator___iadd__(self, *args)

    def __isub__(self, *args):
        """__isub__(SwigPyIterator self, ptrdiff_t n) -> SwigPyIterator"""
        return _yarp.SwigPyIterator___isub__(self, *args)

    def __add__(self, *args):
        """__add__(SwigPyIterator self, ptrdiff_t n) -> SwigPyIterator"""
        return _yarp.SwigPyIterator___add__(self, *args)

    def __sub__(self, *args):
        """
        __sub__(SwigPyIterator self, ptrdiff_t n) -> SwigPyIterator
        __sub__(SwigPyIterator self, SwigPyIterator x) -> ptrdiff_t
        """
        return _yarp.SwigPyIterator___sub__(self, *args)

    def __iter__(self): return self
SwigPyIterator_swigregister = _yarp.SwigPyIterator_swigregister
SwigPyIterator_swigregister(SwigPyIterator)

class ConstString(_object):
    """Proxy of C++ yarp::os::ConstString class"""
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, ConstString, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, ConstString, name)
    __repr__ = _swig_repr
    __swig_destroy__ = _yarp.delete_ConstString
    __del__ = lambda self : None;
    def __init__(self, *args): 
        """
        __init__(yarp::os::ConstString self) -> ConstString
        __init__(yarp::os::ConstString self, char const * str) -> ConstString
        __init__(yarp::os::ConstString self, char const * str, int len) -> ConstString
        __init__(yarp::os::ConstString self, ConstString alt) -> ConstString
        """
        this = _yarp.new_ConstString(*args)
        try: self.this.append(this)
        except: self.this = this
    def c_str(self):
        """c_str(ConstString self) -> char const *"""
        return _yarp.ConstString_c_str(self)

    def isEqual(self, *args):
        """
        isEqual(ConstString self, ConstString alt) -> bool
        isEqual(ConstString self, char const * str) -> bool
        """
        return _yarp.ConstString_isEqual(self, *args)

    def notEqual(self, *args):
        """
        notEqual(ConstString self, ConstString alt) -> bool
        notEqual(ConstString self, char const * str) -> bool
        """
        return _yarp.ConstString_notEqual(self, *args)

    def __add__(self, *args):
        """
        __add__(ConstString self, char ch) -> ConstString
        __add__(ConstString self, char const * str) -> ConstString
        __add__(ConstString self, ConstString alt) -> ConstString
        """
        return _yarp.ConstString___add__(self, *args)

    def __iadd__(self, *args):
        """
        __iadd__(ConstString self, char ch) -> ConstString
        __iadd__(ConstString self, char const * str) -> ConstString
        __iadd__(ConstString self, ConstString alt) -> ConstString
        """
        return _yarp.ConstString___iadd__(self, *args)

    def length(self):
        """length(ConstString self) -> int"""
        return _yarp.ConstString_length(self)

    def find(self, *args):
        """
        find(ConstString self, char const * needle) -> int
        find(ConstString self, char const * needle, int start) -> int
        """
        return _yarp.ConstString_find(self, *args)

    def substr(self, *args):
        """
        substr(ConstString self, int start=0, int n=-1) -> ConstString
        substr(ConstString self, int start=0) -> ConstString
        substr(ConstString self) -> ConstString
        """
        return _yarp.ConstString_substr(self, *args)

    __swig_setmethods__["npos"] = _yarp.ConstString_npos_set
    __swig_getmethods__["npos"] = _yarp.ConstString_npos_get
    if _newclass:npos = _swig_property(_yarp.ConstString_npos_get, _yarp.ConstString_npos_set)
    def toString(*args):
        """
        toString() -> char const
        toString(int x) -> ConstString
        """
        return _yarp.ConstString_toString(*args)

    if _newclass:toString = staticmethod(toString)
    __swig_getmethods__["toString"] = lambda x: toString
ConstString_swigregister = _yarp.ConstString_swigregister
ConstString_swigregister(ConstString)
cvar = _yarp.cvar

def ConstString_toString(*args):
  """
    toString() -> char const
    ConstString_toString(int x) -> ConstString
    """
  return _yarp.ConstString_toString(*args)

class PortReport(_object):
    """Proxy of C++ yarp::os::PortReport class"""
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, PortReport, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, PortReport, name)
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _yarp.delete_PortReport
    __del__ = lambda self : None;
    def report(self, *args):
        """report(PortReport self, yarp::os::PortInfo const & info)"""
        return _yarp.PortReport_report(self, *args)

PortReport_swigregister = _yarp.PortReport_swigregister
PortReport_swigregister(PortReport)

class Contact(_object):
    """Proxy of C++ yarp::os::Contact class"""
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, Contact, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, Contact, name)
    __repr__ = _swig_repr
    def empty():
        """empty() -> Contact"""
        return _yarp.Contact_empty()

    if _newclass:empty = staticmethod(empty)
    __swig_getmethods__["empty"] = lambda x: empty
    def invalid():
        """invalid() -> Contact"""
        return _yarp.Contact_invalid()

    if _newclass:invalid = staticmethod(invalid)
    __swig_getmethods__["invalid"] = lambda x: invalid
    def byName(*args):
        """byName(char const * name) -> Contact"""
        return _yarp.Contact_byName(*args)

    if _newclass:byName = staticmethod(byName)
    __swig_getmethods__["byName"] = lambda x: byName
    def byCarrier(*args):
        """byCarrier(char const * carrier) -> Contact"""
        return _yarp.Contact_byCarrier(*args)

    if _newclass:byCarrier = staticmethod(byCarrier)
    __swig_getmethods__["byCarrier"] = lambda x: byCarrier
    def byConfig(*args):
        """byConfig(Searchable & config) -> Contact"""
        return _yarp.Contact_byConfig(*args)

    if _newclass:byConfig = staticmethod(byConfig)
    __swig_getmethods__["byConfig"] = lambda x: byConfig
    def addCarrier(self, *args):
        """addCarrier(Contact self, char const * carrier) -> Contact"""
        return _yarp.Contact_addCarrier(self, *args)

    def bySocket(*args):
        """bySocket(char const * carrier, char const * host, int portNumber) -> Contact"""
        return _yarp.Contact_bySocket(*args)

    if _newclass:bySocket = staticmethod(bySocket)
    __swig_getmethods__["bySocket"] = lambda x: bySocket
    def addSocket(self, *args):
        """addSocket(Contact self, char const * carrier, char const * host, int portNumber) -> Contact"""
        return _yarp.Contact_addSocket(self, *args)

    def addName(self, *args):
        """addName(Contact self, char const * name) -> Contact"""
        return _yarp.Contact_addName(self, *args)

    def convertHostToIp(*args):
        """convertHostToIp(char const * name) -> ConstString"""
        return _yarp.Contact_convertHostToIp(*args)

    if _newclass:convertHostToIp = staticmethod(convertHostToIp)
    __swig_getmethods__["convertHostToIp"] = lambda x: convertHostToIp
    __swig_destroy__ = _yarp.delete_Contact
    __del__ = lambda self : None;
    def getName(self):
        """getName(Contact self) -> ConstString"""
        return _yarp.Contact_getName(self)

    def getHost(self):
        """getHost(Contact self) -> ConstString"""
        return _yarp.Contact_getHost(self)

    def getCarrier(self):
        """getCarrier(Contact self) -> ConstString"""
        return _yarp.Contact_getCarrier(self)

    def getPort(self):
        """getPort(Contact self) -> int"""
        return _yarp.Contact_getPort(self)

    def toString_c(self):
        """toString_c(Contact self) -> ConstString"""
        return _yarp.Contact_toString_c(self)

    def fromString(*args):
        """fromString(char const * txt) -> Contact"""
        return _yarp.Contact_fromString(*args)

    if _newclass:fromString = staticmethod(fromString)
    __swig_getmethods__["fromString"] = lambda x: fromString
    def isValid(self):
        """isValid(Contact self) -> bool"""
        return _yarp.Contact_isValid(self)

    def __init__(self, *args): 
        """
        __init__(yarp::os::Contact self, Contact alt) -> Contact
        __init__(yarp::os::Contact self) -> Contact
        """
        this = _yarp.new_Contact(*args)
        try: self.this.append(this)
        except: self.this = this
Contact_swigregister = _yarp.Contact_swigregister
Contact_swigregister(Contact)

def Contact_empty():
  """Contact_empty() -> Contact"""
  return _yarp.Contact_empty()

def Contact_invalid():
  """Contact_invalid() -> Contact"""
  return _yarp.Contact_invalid()

def Contact_byName(*args):
  """Contact_byName(char const * name) -> Contact"""
  return _yarp.Contact_byName(*args)

def Contact_byCarrier(*args):
  """Contact_byCarrier(char const * carrier) -> Contact"""
  return _yarp.Contact_byCarrier(*args)

def Contact_byConfig(*args):
  """Contact_byConfig(Searchable & config) -> Contact"""
  return _yarp.Contact_byConfig(*args)

def Contact_bySocket(*args):
  """Contact_bySocket(char const * carrier, char const * host, int portNumber) -> Contact"""
  return _yarp.Contact_bySocket(*args)

def Contact_convertHostToIp(*args):
  """Contact_convertHostToIp(char const * name) -> ConstString"""
  return _yarp.Contact_convertHostToIp(*args)

def Contact_fromString(*args):
  """Contact_fromString(char const * txt) -> Contact"""
  return _yarp.Contact_fromString(*args)

class ConnectionReader(_object):
    """Proxy of C++ yarp::os::ConnectionReader class"""
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, ConnectionReader, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, ConnectionReader, name)
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _yarp.delete_ConnectionReader
    __del__ = lambda self : None;
    def expectBlock(self, *args):
        """expectBlock(ConnectionReader self, char const * data, size_t len) -> bool"""
        return _yarp.ConnectionReader_expectBlock(self, *args)

    def expectText(self, terminatingChar='\n'):
        """
        expectText(ConnectionReader self, int terminatingChar='\n') -> ConstString
        expectText(ConnectionReader self) -> ConstString
        """
        return _yarp.ConnectionReader_expectText(self, terminatingChar)

    def expectInt(self):
        """expectInt(ConnectionReader self) -> int"""
        return _yarp.ConnectionReader_expectInt(self)

    def expectDouble(self):
        """expectDouble(ConnectionReader self) -> double"""
        return _yarp.ConnectionReader_expectDouble(self)

    def isTextMode(self):
        """isTextMode(ConnectionReader self) -> bool"""
        return _yarp.ConnectionReader_isTextMode(self)

    def convertTextMode(self):
        """convertTextMode(ConnectionReader self) -> bool"""
        return _yarp.ConnectionReader_convertTextMode(self)

    def getSize(self):
        """getSize(ConnectionReader self) -> size_t"""
        return _yarp.ConnectionReader_getSize(self)

    def getWriter(self):
        """getWriter(ConnectionReader self) -> ConnectionWriter"""
        return _yarp.ConnectionReader_getWriter(self)

    def readEnvelope(self):
        """readEnvelope(ConnectionReader self) -> Bytes"""
        return _yarp.ConnectionReader_readEnvelope(self)

    def getReference(self):
        """getReference(ConnectionReader self) -> Portable"""
        return _yarp.ConnectionReader_getReference(self)

    def getRemoteContact(self):
        """getRemoteContact(ConnectionReader self) -> Contact"""
        return _yarp.ConnectionReader_getRemoteContact(self)

    def getLocalContact(self):
        """getLocalContact(ConnectionReader self) -> Contact"""
        return _yarp.ConnectionReader_getLocalContact(self)

    def isValid(self):
        """isValid(ConnectionReader self) -> bool"""
        return _yarp.ConnectionReader_isValid(self)

    def isActive(self):
        """isActive(ConnectionReader self) -> bool"""
        return _yarp.ConnectionReader_isActive(self)

    def isError(self):
        """isError(ConnectionReader self) -> bool"""
        return _yarp.ConnectionReader_isError(self)

    def requestDrop(self):
        """requestDrop(ConnectionReader self)"""
        return _yarp.ConnectionReader_requestDrop(self)

    def getConnectionModifiers(self):
        """getConnectionModifiers(ConnectionReader self) -> Searchable &"""
        return _yarp.ConnectionReader_getConnectionModifiers(self)

    def pushInt(self, *args):
        """pushInt(ConnectionReader self, int x) -> bool"""
        return _yarp.ConnectionReader_pushInt(self, *args)

ConnectionReader_swigregister = _yarp.ConnectionReader_swigregister
ConnectionReader_swigregister(ConnectionReader)

class ConnectionWriter(_object):
    """Proxy of C++ yarp::os::ConnectionWriter class"""
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, ConnectionWriter, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, ConnectionWriter, name)
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _yarp.delete_ConnectionWriter
    __del__ = lambda self : None;
    def appendBlock(self, *args):
        """appendBlock(ConnectionWriter self, char const * data, size_t len)"""
        return _yarp.ConnectionWriter_appendBlock(self, *args)

    def appendInt(self, *args):
        """appendInt(ConnectionWriter self, int data)"""
        return _yarp.ConnectionWriter_appendInt(self, *args)

    def appendDouble(self, *args):
        """appendDouble(ConnectionWriter self, double data)"""
        return _yarp.ConnectionWriter_appendDouble(self, *args)

    def appendString(self, *args):
        """
        appendString(ConnectionWriter self, char const * str, int terminate='\n')
        appendString(ConnectionWriter self, char const * str)
        """
        return _yarp.ConnectionWriter_appendString(self, *args)

    def appendExternalBlock(self, *args):
        """appendExternalBlock(ConnectionWriter self, char const * data, size_t len)"""
        return _yarp.ConnectionWriter_appendExternalBlock(self, *args)

    def isTextMode(self):
        """isTextMode(ConnectionWriter self) -> bool"""
        return _yarp.ConnectionWriter_isTextMode(self)

    def declareSizes(self, *args):
        """declareSizes(ConnectionWriter self, int argc, int * argv)"""
        return _yarp.ConnectionWriter_declareSizes(self, *args)

    def setReplyHandler(self, *args):
        """setReplyHandler(ConnectionWriter self, PortReader reader)"""
        return _yarp.ConnectionWriter_setReplyHandler(self, *args)

    def setReference(self, *args):
        """setReference(ConnectionWriter self, Portable obj)"""
        return _yarp.ConnectionWriter_setReference(self, *args)

    def convertTextMode(self):
        """convertTextMode(ConnectionWriter self) -> bool"""
        return _yarp.ConnectionWriter_convertTextMode(self)

    def isValid(self):
        """isValid(ConnectionWriter self) -> bool"""
        return _yarp.ConnectionWriter_isValid(self)

    def isActive(self):
        """isActive(ConnectionWriter self) -> bool"""
        return _yarp.ConnectionWriter_isActive(self)

    def isError(self):
        """isError(ConnectionWriter self) -> bool"""
        return _yarp.ConnectionWriter_isError(self)

    def requestDrop(self):
        """requestDrop(ConnectionWriter self)"""
        return _yarp.ConnectionWriter_requestDrop(self)

    def isNull(self):
        """isNull(ConnectionWriter self) -> bool"""
        return _yarp.ConnectionWriter_isNull(self)

ConnectionWriter_swigregister = _yarp.ConnectionWriter_swigregister
ConnectionWriter_swigregister(ConnectionWriter)

class PortReader(_object):
    """Proxy of C++ yarp::os::PortReader class"""
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, PortReader, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, PortReader, name)
    __repr__ = _swig_repr
    __swig_destroy__ = _yarp.delete_PortReader
    __del__ = lambda self : None;
    def read(self, *args):
        """read(PortReader self, ConnectionReader connection) -> bool"""
        return _yarp.PortReader_read(self, *args)

    def __init__(self): 
        """__init__(yarp::os::PortReader self) -> PortReader"""
        if self.__class__ == PortReader:
            _self = None
        else:
            _self = self
        this = _yarp.new_PortReader(_self, )
        try: self.this.append(this)
        except: self.this = this
    def __disown__(self):
        self.this.disown()
        _yarp.disown_PortReader(self)
        return weakref_proxy(self)
PortReader_swigregister = _yarp.PortReader_swigregister
PortReader_swigregister(PortReader)

class PortWriter(_object):
    """Proxy of C++ yarp::os::PortWriter class"""
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, PortWriter, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, PortWriter, name)
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _yarp.delete_PortWriter
    __del__ = lambda self : None;
    def write(self, *args):
        """write(PortWriter self, ConnectionWriter connection) -> bool"""
        return _yarp.PortWriter_write(self, *args)

    def onCompletion(self):
        """onCompletion(PortWriter self)"""
        return _yarp.PortWriter_onCompletion(self)

    def onCommencement(self):
        """onCommencement(PortWriter self)"""
        return _yarp.PortWriter_onCommencement(self)

PortWriter_swigregister = _yarp.PortWriter_swigregister
PortWriter_swigregister(PortWriter)

class Portable(PortReader,PortWriter):
    """Proxy of C++ yarp::os::Portable class"""
    __swig_setmethods__ = {}
    for _s in [PortReader,PortWriter]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, Portable, name, value)
    __swig_getmethods__ = {}
    for _s in [PortReader,PortWriter]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, Portable, name)
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    def read(self, *args):
        """read(Portable self, ConnectionReader connection) -> bool"""
        return _yarp.Portable_read(self, *args)

    def write(self, *args):
        """write(Portable self, ConnectionWriter connection) -> bool"""
        return _yarp.Portable_write(self, *args)

    __swig_destroy__ = _yarp.delete_Portable
    __del__ = lambda self : None;
Portable_swigregister = _yarp.Portable_swigregister
Portable_swigregister(Portable)

class SearchReport(_object):
    """Proxy of C++ yarp::os::SearchReport class"""
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, SearchReport, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, SearchReport, name)
    __repr__ = _swig_repr
    __swig_setmethods__["key"] = _yarp.SearchReport_key_set
    __swig_getmethods__["key"] = _yarp.SearchReport_key_get
    if _newclass:key = _swig_property(_yarp.SearchReport_key_get, _yarp.SearchReport_key_set)
    __swig_setmethods__["value"] = _yarp.SearchReport_value_set
    __swig_getmethods__["value"] = _yarp.SearchReport_value_get
    if _newclass:value = _swig_property(_yarp.SearchReport_value_get, _yarp.SearchReport_value_set)
    __swig_setmethods__["isFound"] = _yarp.SearchReport_isFound_set
    __swig_getmethods__["isFound"] = _yarp.SearchReport_isFound_get
    if _newclass:isFound = _swig_property(_yarp.SearchReport_isFound_get, _yarp.SearchReport_isFound_set)
    __swig_setmethods__["isGroup"] = _yarp.SearchReport_isGroup_set
    __swig_getmethods__["isGroup"] = _yarp.SearchReport_isGroup_get
    if _newclass:isGroup = _swig_property(_yarp.SearchReport_isGroup_get, _yarp.SearchReport_isGroup_set)
    __swig_setmethods__["isComment"] = _yarp.SearchReport_isComment_set
    __swig_getmethods__["isComment"] = _yarp.SearchReport_isComment_get
    if _newclass:isComment = _swig_property(_yarp.SearchReport_isComment_get, _yarp.SearchReport_isComment_set)
    __swig_setmethods__["isDefault"] = _yarp.SearchReport_isDefault_set
    __swig_getmethods__["isDefault"] = _yarp.SearchReport_isDefault_get
    if _newclass:isDefault = _swig_property(_yarp.SearchReport_isDefault_get, _yarp.SearchReport_isDefault_set)
    def __init__(self): 
        """__init__(yarp::os::SearchReport self) -> SearchReport"""
        this = _yarp.new_SearchReport()
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _yarp.delete_SearchReport
    __del__ = lambda self : None;
SearchReport_swigregister = _yarp.SearchReport_swigregister
SearchReport_swigregister(SearchReport)

class SearchMonitor(_object):
    """Proxy of C++ yarp::os::SearchMonitor class"""
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, SearchMonitor, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, SearchMonitor, name)
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _yarp.delete_SearchMonitor
    __del__ = lambda self : None;
    def report(self, *args):
        """report(SearchMonitor self, SearchReport report, char const * context)"""
        return _yarp.SearchMonitor_report(self, *args)

SearchMonitor_swigregister = _yarp.SearchMonitor_swigregister
SearchMonitor_swigregister(SearchMonitor)

class Searchable(_object):
    """Proxy of C++ yarp::os::Searchable class"""
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, Searchable, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, Searchable, name)
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _yarp.delete_Searchable
    __del__ = lambda self : None;
    def find(self, *args):
        """find(Searchable self, char const * key) -> Value"""
        return _yarp.Searchable_find(self, *args)

    def findGroup(self, *args):
        """
        findGroup(Searchable self, char const * key) -> Bottle
        findGroup(Searchable self, char const * key, char const * comment) -> Bottle
        """
        return _yarp.Searchable_findGroup(self, *args)

    def check(self, *args):
        """
        check(Searchable self, char const * key) -> bool
        check(Searchable self, char const * key, char const * comment) -> bool
        check(Searchable self, char const * key, Value fallback, char const * comment=None) -> Value
        check(Searchable self, char const * key, Value fallback) -> Value
        """
        return _yarp.Searchable_check(self, *args)

    def isNull(self):
        """isNull(Searchable self) -> bool"""
        return _yarp.Searchable_isNull(self)

    def toString_c(self):
        """toString_c(Searchable self) -> ConstString"""
        return _yarp.Searchable_toString_c(self)

    def setMonitor(self, *args):
        """
        setMonitor(Searchable self, SearchMonitor monitor, char const * context="")
        setMonitor(Searchable self, SearchMonitor monitor)
        """
        return _yarp.Searchable_setMonitor(self, *args)

    def getMonitor(self):
        """getMonitor(Searchable self) -> SearchMonitor"""
        return _yarp.Searchable_getMonitor(self)

    def getContext(self):
        """getContext(Searchable self) -> ConstString"""
        return _yarp.Searchable_getContext(self)

    def reportToMonitor(self, *args):
        """reportToMonitor(Searchable self, SearchReport report)"""
        return _yarp.Searchable_reportToMonitor(self, *args)

Searchable_swigregister = _yarp.Searchable_swigregister
Searchable_swigregister(Searchable)

class Value(Portable,Searchable):
    """Proxy of C++ yarp::os::Value class"""
    __swig_setmethods__ = {}
    for _s in [Portable,Searchable]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, Value, name, value)
    __swig_getmethods__ = {}
    for _s in [Portable,Searchable]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, Value, name)
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(yarp::os::Value self) -> Value
        __init__(yarp::os::Value self, int x, bool isVocab=False) -> Value
        __init__(yarp::os::Value self, int x) -> Value
        __init__(yarp::os::Value self, double x) -> Value
        __init__(yarp::os::Value self, char const * str, bool isVocab=False) -> Value
        __init__(yarp::os::Value self, char const * str) -> Value
        __init__(yarp::os::Value self, void * data, int length) -> Value
        __init__(yarp::os::Value self, Value alt) -> Value
        """
        this = _yarp.new_Value(*args)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _yarp.delete_Value
    __del__ = lambda self : None;
    def isBool(self):
        """isBool(Value self) -> bool"""
        return _yarp.Value_isBool(self)

    def isInt(self):
        """isInt(Value self) -> bool"""
        return _yarp.Value_isInt(self)

    def isString(self):
        """isString(Value self) -> bool"""
        return _yarp.Value_isString(self)

    def isDouble(self):
        """isDouble(Value self) -> bool"""
        return _yarp.Value_isDouble(self)

    def isList(self):
        """isList(Value self) -> bool"""
        return _yarp.Value_isList(self)

    def isDict(self):
        """isDict(Value self) -> bool"""
        return _yarp.Value_isDict(self)

    def isVocab(self):
        """isVocab(Value self) -> bool"""
        return _yarp.Value_isVocab(self)

    def isBlob(self):
        """isBlob(Value self) -> bool"""
        return _yarp.Value_isBlob(self)

    def asBool(self):
        """asBool(Value self) -> bool"""
        return _yarp.Value_asBool(self)

    def asInt(self):
        """asInt(Value self) -> int"""
        return _yarp.Value_asInt(self)

    def asVocab(self):
        """asVocab(Value self) -> int"""
        return _yarp.Value_asVocab(self)

    def asDouble(self):
        """asDouble(Value self) -> double"""
        return _yarp.Value_asDouble(self)

    def asString(self):
        """asString(Value self) -> ConstString"""
        return _yarp.Value_asString(self)

    def asList(self):
        """asList(Value self) -> Bottle"""
        return _yarp.Value_asList(self)

    def asDict(self):
        """asDict(Value self) -> Property"""
        return _yarp.Value_asDict(self)

    def asSearchable(self):
        """asSearchable(Value self) -> Searchable"""
        return _yarp.Value_asSearchable(self)

    def asBlob(self):
        """asBlob(Value self) -> char const *"""
        return _yarp.Value_asBlob(self)

    def asBlobLength(self):
        """asBlobLength(Value self) -> size_t"""
        return _yarp.Value_asBlobLength(self)

    def read(self, *args):
        """read(Value self, ConnectionReader connection) -> bool"""
        return _yarp.Value_read(self, *args)

    def write(self, *args):
        """write(Value self, ConnectionWriter connection) -> bool"""
        return _yarp.Value_write(self, *args)

    def check(self, *args):
        """
        check(Value self, char const * key, char const * comment) -> bool
        check(Value self, char const * key, Value fallback, char const * comment=None) -> Value
        check(Value self, char const * key, Value fallback) -> Value
        check(Value self, char const * key) -> bool
        """
        return _yarp.Value_check(self, *args)

    def find(self, *args):
        """find(Value self, char const * key) -> Value"""
        return _yarp.Value_find(self, *args)

    def findGroup(self, *args):
        """
        findGroup(Value self, char const * key, char const * comment) -> Bottle
        findGroup(Value self, char const * key) -> Bottle
        """
        return _yarp.Value_findGroup(self, *args)

    def isEqual(self, *args):
        """isEqual(Value self, Value alt) -> bool"""
        return _yarp.Value_isEqual(self, *args)

    def notEqual(self, *args):
        """notEqual(Value self, Value alt) -> bool"""
        return _yarp.Value_notEqual(self, *args)

    def fromString(self, *args):
        """fromString(Value self, char const * str)"""
        return _yarp.Value_fromString(self, *args)

    def toString_c(self):
        """toString_c(Value self) -> ConstString"""
        return _yarp.Value_toString_c(self)

    def create(self):
        """create(Value self) -> Value"""
        return _yarp.Value_create(self)

    def clone(self):
        """clone(Value self) -> Value"""
        return _yarp.Value_clone(self)

    def getCode(self):
        """getCode(Value self) -> int"""
        return _yarp.Value_getCode(self)

    def isNull(self):
        """isNull(Value self) -> bool"""
        return _yarp.Value_isNull(self)

    def isLeaf(self):
        """isLeaf(Value self) -> bool"""
        return _yarp.Value_isLeaf(self)

    def makeInt(*args):
        """makeInt(int x) -> Value"""
        return _yarp.Value_makeInt(*args)

    if _newclass:makeInt = staticmethod(makeInt)
    __swig_getmethods__["makeInt"] = lambda x: makeInt
    def makeDouble(*args):
        """makeDouble(double x) -> Value"""
        return _yarp.Value_makeDouble(*args)

    if _newclass:makeDouble = staticmethod(makeDouble)
    __swig_getmethods__["makeDouble"] = lambda x: makeDouble
    def makeString(*args):
        """makeString(char const * str) -> Value"""
        return _yarp.Value_makeString(*args)

    if _newclass:makeString = staticmethod(makeString)
    __swig_getmethods__["makeString"] = lambda x: makeString
    def makeVocab(*args):
        """
        makeVocab(int v) -> Value
        makeVocab(char const * str) -> Value
        """
        return _yarp.Value_makeVocab(*args)

    if _newclass:makeVocab = staticmethod(makeVocab)
    __swig_getmethods__["makeVocab"] = lambda x: makeVocab
    def makeBlob(*args):
        """makeBlob(void * data, int length) -> Value"""
        return _yarp.Value_makeBlob(*args)

    if _newclass:makeBlob = staticmethod(makeBlob)
    __swig_getmethods__["makeBlob"] = lambda x: makeBlob
    def makeList(*args):
        """
        makeList() -> Value
        makeList(char const * txt) -> Value
        """
        return _yarp.Value_makeList(*args)

    if _newclass:makeList = staticmethod(makeList)
    __swig_getmethods__["makeList"] = lambda x: makeList
    def makeValue(*args):
        """makeValue(char const * txt) -> Value"""
        return _yarp.Value_makeValue(*args)

    if _newclass:makeValue = staticmethod(makeValue)
    __swig_getmethods__["makeValue"] = lambda x: makeValue
    def getNullValue():
        """getNullValue() -> Value"""
        return _yarp.Value_getNullValue()

    if _newclass:getNullValue = staticmethod(getNullValue)
    __swig_getmethods__["getNullValue"] = lambda x: getNullValue
    def toString(self):
        """toString(Value self) -> std::string"""
        return _yarp.Value_toString(self)

Value_swigregister = _yarp.Value_swigregister
Value_swigregister(Value)

def Value_makeInt(*args):
  """Value_makeInt(int x) -> Value"""
  return _yarp.Value_makeInt(*args)

def Value_makeDouble(*args):
  """Value_makeDouble(double x) -> Value"""
  return _yarp.Value_makeDouble(*args)

def Value_makeString(*args):
  """Value_makeString(char const * str) -> Value"""
  return _yarp.Value_makeString(*args)

def Value_makeVocab(*args):
  """
    makeVocab(int v) -> Value
    Value_makeVocab(char const * str) -> Value
    """
  return _yarp.Value_makeVocab(*args)

def Value_makeBlob(*args):
  """Value_makeBlob(void * data, int length) -> Value"""
  return _yarp.Value_makeBlob(*args)

def Value_makeList(*args):
  """
    makeList() -> Value
    Value_makeList(char const * txt) -> Value
    """
  return _yarp.Value_makeList(*args)

def Value_makeValue(*args):
  """Value_makeValue(char const * txt) -> Value"""
  return _yarp.Value_makeValue(*args)

def Value_getNullValue():
  """Value_getNullValue() -> Value"""
  return _yarp.Value_getNullValue()

class Vocab(_object):
    """Proxy of C++ yarp::os::Vocab class"""
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, Vocab, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, Vocab, name)
    __repr__ = _swig_repr
    def encode(*args):
        """encode(char const * str) -> yarp::os::NetInt32"""
        return _yarp.Vocab_encode(*args)

    if _newclass:encode = staticmethod(encode)
    __swig_getmethods__["encode"] = lambda x: encode
    def decode(*args):
        """decode(yarp::os::NetInt32 code) -> ConstString"""
        return _yarp.Vocab_decode(*args)

    if _newclass:decode = staticmethod(decode)
    __swig_getmethods__["decode"] = lambda x: decode
    def __init__(self): 
        """__init__(yarp::os::Vocab self) -> Vocab"""
        this = _yarp.new_Vocab()
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _yarp.delete_Vocab
    __del__ = lambda self : None;
Vocab_swigregister = _yarp.Vocab_swigregister
Vocab_swigregister(Vocab)

def Vocab_encode(*args):
  """Vocab_encode(char const * str) -> yarp::os::NetInt32"""
  return _yarp.Vocab_encode(*args)

def Vocab_decode(*args):
  """Vocab_decode(yarp::os::NetInt32 code) -> ConstString"""
  return _yarp.Vocab_decode(*args)

class Contactable(_object):
    """Proxy of C++ yarp::os::Contactable class"""
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, Contactable, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, Contactable, name)
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _yarp.delete_Contactable
    __del__ = lambda self : None;
    def open(self, *args):
        """
        open(Contactable self) -> bool
        open(Contactable self, char const * name) -> bool
        open(Contactable self, Contact contact, bool registerName=True) -> bool
        open(Contactable self, Contact contact) -> bool
        """
        return _yarp.Contactable_open(self, *args)

    def addOutput(self, *args):
        """
        addOutput(Contactable self, char const * name) -> bool
        addOutput(Contactable self, char const * name, char const * carrier) -> bool
        addOutput(Contactable self, Contact contact) -> bool
        """
        return _yarp.Contactable_addOutput(self, *args)

    def close(self):
        """close(Contactable self)"""
        return _yarp.Contactable_close(self)

    def interrupt(self):
        """interrupt(Contactable self)"""
        return _yarp.Contactable_interrupt(self)

    def resume(self):
        """resume(Contactable self)"""
        return _yarp.Contactable_resume(self)

    def where(self):
        """where(Contactable self) -> Contact"""
        return _yarp.Contactable_where(self)

    def getName(self):
        """getName(Contactable self) -> ConstString"""
        return _yarp.Contactable_getName(self)

    def setEnvelope(self, *args):
        """setEnvelope(Contactable self, PortWriter envelope) -> bool"""
        return _yarp.Contactable_setEnvelope(self, *args)

    def getEnvelope(self, *args):
        """getEnvelope(Contactable self, PortReader envelope) -> bool"""
        return _yarp.Contactable_getEnvelope(self, *args)

    def getInputCount(self):
        """getInputCount(Contactable self) -> int"""
        return _yarp.Contactable_getInputCount(self)

    def getOutputCount(self):
        """getOutputCount(Contactable self) -> int"""
        return _yarp.Contactable_getOutputCount(self)

    def getReport(self, *args):
        """getReport(Contactable self, PortReport reporter)"""
        return _yarp.Contactable_getReport(self, *args)

    def setReporter(self, *args):
        """setReporter(Contactable self, PortReport reporter)"""
        return _yarp.Contactable_setReporter(self, *args)

    def isWriting(self):
        """isWriting(Contactable self) -> bool"""
        return _yarp.Contactable_isWriting(self)

    def setReader(self, *args):
        """setReader(Contactable self, PortReader reader)"""
        return _yarp.Contactable_setReader(self, *args)

Contactable_swigregister = _yarp.Contactable_swigregister
Contactable_swigregister(Contactable)

class NetworkBase(_object):
    """Proxy of C++ yarp::os::NetworkBase class"""
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, NetworkBase, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, NetworkBase, name)
    __repr__ = _swig_repr
    def initMinimum():
        """initMinimum()"""
        return _yarp.NetworkBase_initMinimum()

    if _newclass:initMinimum = staticmethod(initMinimum)
    __swig_getmethods__["initMinimum"] = lambda x: initMinimum
    def finiMinimum():
        """finiMinimum()"""
        return _yarp.NetworkBase_finiMinimum()

    if _newclass:finiMinimum = staticmethod(finiMinimum)
    __swig_getmethods__["finiMinimum"] = lambda x: finiMinimum
    def connect(*args):
        """
        connect(char const * src, char const * dest, char const * carrier=None, bool quiet=True) -> bool
        connect(char const * src, char const * dest, char const * carrier=None) -> bool
        connect(char const * src, char const * dest) -> bool
        connect(char const * src, char const * dest, ContactStyle style) -> bool
        """
        return _yarp.NetworkBase_connect(*args)

    if _newclass:connect = staticmethod(connect)
    __swig_getmethods__["connect"] = lambda x: connect
    def disconnect(*args):
        """
        disconnect(char const * src, char const * dest, bool quiet=True) -> bool
        disconnect(char const * src, char const * dest) -> bool
        disconnect(char const * src, char const * dest, ContactStyle style) -> bool
        """
        return _yarp.NetworkBase_disconnect(*args)

    if _newclass:disconnect = staticmethod(disconnect)
    __swig_getmethods__["disconnect"] = lambda x: disconnect
    def isConnected(*args):
        """
        isConnected(char const * src, char const * dest, bool quiet=True) -> bool
        isConnected(char const * src, char const * dest) -> bool
        isConnected(char const * src, char const * dest, ContactStyle style) -> bool
        """
        return _yarp.NetworkBase_isConnected(*args)

    if _newclass:isConnected = staticmethod(isConnected)
    __swig_getmethods__["isConnected"] = lambda x: isConnected
    def exists(*args):
        """
        exists(char const * port, bool quiet=True) -> bool
        exists(char const * port) -> bool
        exists(char const * port, ContactStyle style) -> bool
        """
        return _yarp.NetworkBase_exists(*args)

    if _newclass:exists = staticmethod(exists)
    __swig_getmethods__["exists"] = lambda x: exists
    def sync(*args):
        """
        sync(char const * port, bool quiet=True) -> bool
        sync(char const * port) -> bool
        """
        return _yarp.NetworkBase_sync(*args)

    if _newclass:sync = staticmethod(sync)
    __swig_getmethods__["sync"] = lambda x: sync
    def main(*args):
        """main(int argc, char *[] argv) -> int"""
        return _yarp.NetworkBase_main(*args)

    if _newclass:main = staticmethod(main)
    __swig_getmethods__["main"] = lambda x: main
    def runNameServer(*args):
        """runNameServer(int argc, char *[] argv) -> int"""
        return _yarp.NetworkBase_runNameServer(*args)

    if _newclass:runNameServer = staticmethod(runNameServer)
    __swig_getmethods__["runNameServer"] = lambda x: runNameServer
    def assertion(*args):
        """assertion(bool shouldBeTrue)"""
        return _yarp.NetworkBase_assertion(*args)

    if _newclass:assertion = staticmethod(assertion)
    __swig_getmethods__["assertion"] = lambda x: assertion
    def queryName(*args):
        """queryName(char const * name) -> Contact"""
        return _yarp.NetworkBase_queryName(*args)

    if _newclass:queryName = staticmethod(queryName)
    __swig_getmethods__["queryName"] = lambda x: queryName
    def registerName(*args):
        """registerName(char const * name) -> Contact"""
        return _yarp.NetworkBase_registerName(*args)

    if _newclass:registerName = staticmethod(registerName)
    __swig_getmethods__["registerName"] = lambda x: registerName
    def registerContact(*args):
        """registerContact(Contact contact) -> Contact"""
        return _yarp.NetworkBase_registerContact(*args)

    if _newclass:registerContact = staticmethod(registerContact)
    __swig_getmethods__["registerContact"] = lambda x: registerContact
    def unregisterName(*args):
        """unregisterName(char const * name) -> Contact"""
        return _yarp.NetworkBase_unregisterName(*args)

    if _newclass:unregisterName = staticmethod(unregisterName)
    __swig_getmethods__["unregisterName"] = lambda x: unregisterName
    def unregisterContact(*args):
        """unregisterContact(Contact contact) -> Contact"""
        return _yarp.NetworkBase_unregisterContact(*args)

    if _newclass:unregisterContact = staticmethod(unregisterContact)
    __swig_getmethods__["unregisterContact"] = lambda x: unregisterContact
    def setProperty(*args):
        """setProperty(char const * name, char const * key, Value value) -> bool"""
        return _yarp.NetworkBase_setProperty(*args)

    if _newclass:setProperty = staticmethod(setProperty)
    __swig_getmethods__["setProperty"] = lambda x: setProperty
    def getProperty(*args):
        """getProperty(char const * name, char const * key) -> Value"""
        return _yarp.NetworkBase_getProperty(*args)

    if _newclass:getProperty = staticmethod(getProperty)
    __swig_getmethods__["getProperty"] = lambda x: getProperty
    def getNameServerName():
        """getNameServerName() -> ConstString"""
        return _yarp.NetworkBase_getNameServerName()

    if _newclass:getNameServerName = staticmethod(getNameServerName)
    __swig_getmethods__["getNameServerName"] = lambda x: getNameServerName
    def getNameServerContact():
        """getNameServerContact() -> Contact"""
        return _yarp.NetworkBase_getNameServerContact()

    if _newclass:getNameServerContact = staticmethod(getNameServerContact)
    __swig_getmethods__["getNameServerContact"] = lambda x: getNameServerContact
    def setNameServerName(*args):
        """setNameServerName(char const * name) -> bool"""
        return _yarp.NetworkBase_setNameServerName(*args)

    if _newclass:setNameServerName = staticmethod(setNameServerName)
    __swig_getmethods__["setNameServerName"] = lambda x: setNameServerName
    def setLocalMode(*args):
        """setLocalMode(bool flag) -> bool"""
        return _yarp.NetworkBase_setLocalMode(*args)

    if _newclass:setLocalMode = staticmethod(setLocalMode)
    __swig_getmethods__["setLocalMode"] = lambda x: setLocalMode
    def getLocalMode():
        """getLocalMode() -> bool"""
        return _yarp.NetworkBase_getLocalMode()

    if _newclass:getLocalMode = staticmethod(getLocalMode)
    __swig_getmethods__["getLocalMode"] = lambda x: getLocalMode
    def readString(eof=None):
        """
        readString(bool * eof=None) -> ConstString
        readString() -> ConstString
        """
        return _yarp.NetworkBase_readString(eof)

    if _newclass:readString = staticmethod(readString)
    __swig_getmethods__["readString"] = lambda x: readString
    def writeToNameServer(*args):
        """writeToNameServer(PortWriter cmd, PortReader reply, ContactStyle style) -> bool"""
        return _yarp.NetworkBase_writeToNameServer(*args)

    if _newclass:writeToNameServer = staticmethod(writeToNameServer)
    __swig_getmethods__["writeToNameServer"] = lambda x: writeToNameServer
    def write(*args):
        """
        write(Contact contact, PortWriter cmd, PortReader reply, bool admin=False, bool quiet=False, 
            double timeout=-1) -> bool
        write(Contact contact, PortWriter cmd, PortReader reply, bool admin=False, bool quiet=False) -> bool
        write(Contact contact, PortWriter cmd, PortReader reply, bool admin=False) -> bool
        write(Contact contact, PortWriter cmd, PortReader reply) -> bool
        write(Contact contact, PortWriter cmd, PortReader reply, ContactStyle style) -> bool
        write(char const * port_name, PortWriter cmd, PortReader reply) -> bool
        """
        return _yarp.NetworkBase_write(*args)

    if _newclass:write = staticmethod(write)
    __swig_getmethods__["write"] = lambda x: write
    def checkNetwork(*args):
        """
        checkNetwork() -> bool
        checkNetwork(double timeout) -> bool
        """
        return _yarp.NetworkBase_checkNetwork(*args)

    if _newclass:checkNetwork = staticmethod(checkNetwork)
    __swig_getmethods__["checkNetwork"] = lambda x: checkNetwork
    def initialized():
        """initialized() -> bool"""
        return _yarp.NetworkBase_initialized()

    if _newclass:initialized = staticmethod(initialized)
    __swig_getmethods__["initialized"] = lambda x: initialized
    def setVerbosity(*args):
        """setVerbosity(int verbosity)"""
        return _yarp.NetworkBase_setVerbosity(*args)

    if _newclass:setVerbosity = staticmethod(setVerbosity)
    __swig_getmethods__["setVerbosity"] = lambda x: setVerbosity
    def queryBypass(*args):
        """queryBypass(NameStore * store)"""
        return _yarp.NetworkBase_queryBypass(*args)

    if _newclass:queryBypass = staticmethod(queryBypass)
    __swig_getmethods__["queryBypass"] = lambda x: queryBypass
    def getEnvironment(*args):
        """
        getEnvironment(char const * key, bool * found=None) -> ConstString
        getEnvironment(char const * key) -> ConstString
        """
        return _yarp.NetworkBase_getEnvironment(*args)

    if _newclass:getEnvironment = staticmethod(getEnvironment)
    __swig_getmethods__["getEnvironment"] = lambda x: getEnvironment
    def registerCarrier(*args):
        """registerCarrier(char const * name, char const * dll) -> bool"""
        return _yarp.NetworkBase_registerCarrier(*args)

    if _newclass:registerCarrier = staticmethod(registerCarrier)
    __swig_getmethods__["registerCarrier"] = lambda x: registerCarrier
    def lock():
        """lock()"""
        return _yarp.NetworkBase_lock()

    if _newclass:lock = staticmethod(lock)
    __swig_getmethods__["lock"] = lambda x: lock
    def unlock():
        """unlock()"""
        return _yarp.NetworkBase_unlock()

    if _newclass:unlock = staticmethod(unlock)
    __swig_getmethods__["unlock"] = lambda x: unlock
    def localNetworkAllocation():
        """localNetworkAllocation() -> bool"""
        return _yarp.NetworkBase_localNetworkAllocation()

    if _newclass:localNetworkAllocation = staticmethod(localNetworkAllocation)
    __swig_getmethods__["localNetworkAllocation"] = lambda x: localNetworkAllocation
    def detectNameServer(*args):
        """detectNameServer(bool useDetectedServer, bool & scanNeeded, bool & serverUsed) -> Contact"""
        return _yarp.NetworkBase_detectNameServer(*args)

    if _newclass:detectNameServer = staticmethod(detectNameServer)
    __swig_getmethods__["detectNameServer"] = lambda x: detectNameServer
    def getConfigFile(*args):
        """getConfigFile(char const * fname) -> ConstString"""
        return _yarp.NetworkBase_getConfigFile(*args)

    if _newclass:getConfigFile = staticmethod(getConfigFile)
    __swig_getmethods__["getConfigFile"] = lambda x: getConfigFile
    def getDefaultPortRange():
        """getDefaultPortRange() -> int"""
        return _yarp.NetworkBase_getDefaultPortRange()

    if _newclass:getDefaultPortRange = staticmethod(getDefaultPortRange)
    __swig_getmethods__["getDefaultPortRange"] = lambda x: getDefaultPortRange
    def __init__(self): 
        """__init__(yarp::os::NetworkBase self) -> NetworkBase"""
        this = _yarp.new_NetworkBase()
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _yarp.delete_NetworkBase
    __del__ = lambda self : None;
NetworkBase_swigregister = _yarp.NetworkBase_swigregister
NetworkBase_swigregister(NetworkBase)

def NetworkBase_initMinimum():
  """NetworkBase_initMinimum()"""
  return _yarp.NetworkBase_initMinimum()

def NetworkBase_finiMinimum():
  """NetworkBase_finiMinimum()"""
  return _yarp.NetworkBase_finiMinimum()

def NetworkBase_connect(*args):
  """
    connect(char const * src, char const * dest, char const * carrier=None, bool quiet=True) -> bool
    connect(char const * src, char const * dest, char const * carrier=None) -> bool
    connect(char const * src, char const * dest) -> bool
    NetworkBase_connect(char const * src, char const * dest, ContactStyle style) -> bool
    """
  return _yarp.NetworkBase_connect(*args)

def NetworkBase_disconnect(*args):
  """
    disconnect(char const * src, char const * dest, bool quiet=True) -> bool
    disconnect(char const * src, char const * dest) -> bool
    NetworkBase_disconnect(char const * src, char const * dest, ContactStyle style) -> bool
    """
  return _yarp.NetworkBase_disconnect(*args)

def NetworkBase_isConnected(*args):
  """
    isConnected(char const * src, char const * dest, bool quiet=True) -> bool
    isConnected(char const * src, char const * dest) -> bool
    NetworkBase_isConnected(char const * src, char const * dest, ContactStyle style) -> bool
    """
  return _yarp.NetworkBase_isConnected(*args)

def NetworkBase_exists(*args):
  """
    exists(char const * port, bool quiet=True) -> bool
    exists(char const * port) -> bool
    NetworkBase_exists(char const * port, ContactStyle style) -> bool
    """
  return _yarp.NetworkBase_exists(*args)

def NetworkBase_sync(*args):
  """
    sync(char const * port, bool quiet=True) -> bool
    NetworkBase_sync(char const * port) -> bool
    """
  return _yarp.NetworkBase_sync(*args)

def NetworkBase_main(*args):
  """NetworkBase_main(int argc, char *[] argv) -> int"""
  return _yarp.NetworkBase_main(*args)

def NetworkBase_runNameServer(*args):
  """NetworkBase_runNameServer(int argc, char *[] argv) -> int"""
  return _yarp.NetworkBase_runNameServer(*args)

def NetworkBase_assertion(*args):
  """NetworkBase_assertion(bool shouldBeTrue)"""
  return _yarp.NetworkBase_assertion(*args)

def NetworkBase_queryName(*args):
  """NetworkBase_queryName(char const * name) -> Contact"""
  return _yarp.NetworkBase_queryName(*args)

def NetworkBase_registerName(*args):
  """NetworkBase_registerName(char const * name) -> Contact"""
  return _yarp.NetworkBase_registerName(*args)

def NetworkBase_registerContact(*args):
  """NetworkBase_registerContact(Contact contact) -> Contact"""
  return _yarp.NetworkBase_registerContact(*args)

def NetworkBase_unregisterName(*args):
  """NetworkBase_unregisterName(char const * name) -> Contact"""
  return _yarp.NetworkBase_unregisterName(*args)

def NetworkBase_unregisterContact(*args):
  """NetworkBase_unregisterContact(Contact contact) -> Contact"""
  return _yarp.NetworkBase_unregisterContact(*args)

def NetworkBase_setProperty(*args):
  """NetworkBase_setProperty(char const * name, char const * key, Value value) -> bool"""
  return _yarp.NetworkBase_setProperty(*args)

def NetworkBase_getProperty(*args):
  """NetworkBase_getProperty(char const * name, char const * key) -> Value"""
  return _yarp.NetworkBase_getProperty(*args)

def NetworkBase_getNameServerName():
  """NetworkBase_getNameServerName() -> ConstString"""
  return _yarp.NetworkBase_getNameServerName()

def NetworkBase_getNameServerContact():
  """NetworkBase_getNameServerContact() -> Contact"""
  return _yarp.NetworkBase_getNameServerContact()

def NetworkBase_setNameServerName(*args):
  """NetworkBase_setNameServerName(char const * name) -> bool"""
  return _yarp.NetworkBase_setNameServerName(*args)

def NetworkBase_setLocalMode(*args):
  """NetworkBase_setLocalMode(bool flag) -> bool"""
  return _yarp.NetworkBase_setLocalMode(*args)

def NetworkBase_getLocalMode():
  """NetworkBase_getLocalMode() -> bool"""
  return _yarp.NetworkBase_getLocalMode()

def NetworkBase_readString(eof=None):
  """
    readString(bool * eof=None) -> ConstString
    NetworkBase_readString() -> ConstString
    """
  return _yarp.NetworkBase_readString(eof)

def NetworkBase_writeToNameServer(*args):
  """NetworkBase_writeToNameServer(PortWriter cmd, PortReader reply, ContactStyle style) -> bool"""
  return _yarp.NetworkBase_writeToNameServer(*args)

def NetworkBase_write(*args):
  """
    write(Contact contact, PortWriter cmd, PortReader reply, bool admin=False, bool quiet=False, 
        double timeout=-1) -> bool
    write(Contact contact, PortWriter cmd, PortReader reply, bool admin=False, bool quiet=False) -> bool
    write(Contact contact, PortWriter cmd, PortReader reply, bool admin=False) -> bool
    write(Contact contact, PortWriter cmd, PortReader reply) -> bool
    write(Contact contact, PortWriter cmd, PortReader reply, ContactStyle style) -> bool
    NetworkBase_write(char const * port_name, PortWriter cmd, PortReader reply) -> bool
    """
  return _yarp.NetworkBase_write(*args)

def NetworkBase_checkNetwork(*args):
  """
    checkNetwork() -> bool
    NetworkBase_checkNetwork(double timeout) -> bool
    """
  return _yarp.NetworkBase_checkNetwork(*args)

def NetworkBase_initialized():
  """NetworkBase_initialized() -> bool"""
  return _yarp.NetworkBase_initialized()

def NetworkBase_setVerbosity(*args):
  """NetworkBase_setVerbosity(int verbosity)"""
  return _yarp.NetworkBase_setVerbosity(*args)

def NetworkBase_queryBypass(*args):
  """NetworkBase_queryBypass(NameStore * store)"""
  return _yarp.NetworkBase_queryBypass(*args)

def NetworkBase_getEnvironment(*args):
  """
    getEnvironment(char const * key, bool * found=None) -> ConstString
    NetworkBase_getEnvironment(char const * key) -> ConstString
    """
  return _yarp.NetworkBase_getEnvironment(*args)

def NetworkBase_registerCarrier(*args):
  """NetworkBase_registerCarrier(char const * name, char const * dll) -> bool"""
  return _yarp.NetworkBase_registerCarrier(*args)

def NetworkBase_lock():
  """NetworkBase_lock()"""
  return _yarp.NetworkBase_lock()

def NetworkBase_unlock():
  """NetworkBase_unlock()"""
  return _yarp.NetworkBase_unlock()

def NetworkBase_localNetworkAllocation():
  """NetworkBase_localNetworkAllocation() -> bool"""
  return _yarp.NetworkBase_localNetworkAllocation()

def NetworkBase_detectNameServer(*args):
  """NetworkBase_detectNameServer(bool useDetectedServer, bool & scanNeeded, bool & serverUsed) -> Contact"""
  return _yarp.NetworkBase_detectNameServer(*args)

def NetworkBase_getConfigFile(*args):
  """NetworkBase_getConfigFile(char const * fname) -> ConstString"""
  return _yarp.NetworkBase_getConfigFile(*args)

def NetworkBase_getDefaultPortRange():
  """NetworkBase_getDefaultPortRange() -> int"""
  return _yarp.NetworkBase_getDefaultPortRange()

class Network(NetworkBase):
    """Proxy of C++ yarp::os::Network class"""
    __swig_setmethods__ = {}
    for _s in [NetworkBase]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, Network, name, value)
    __swig_getmethods__ = {}
    for _s in [NetworkBase]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, Network, name)
    __repr__ = _swig_repr
    def __init__(self): 
        """__init__(yarp::os::Network self) -> Network"""
        this = _yarp.new_Network()
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _yarp.delete_Network
    __del__ = lambda self : None;
    def init():
        """init()"""
        return _yarp.Network_init()

    if _newclass:init = staticmethod(init)
    __swig_getmethods__["init"] = lambda x: init
    def fini():
        """fini()"""
        return _yarp.Network_fini()

    if _newclass:fini = staticmethod(fini)
    __swig_getmethods__["fini"] = lambda x: fini
Network_swigregister = _yarp.Network_swigregister
Network_swigregister(Network)

def Network_init():
  """Network_init()"""
  return _yarp.Network_init()

def Network_fini():
  """Network_fini()"""
  return _yarp.Network_fini()

class PortablePairBase(Portable):
    """Proxy of C++ yarp::os::PortablePairBase class"""
    __swig_setmethods__ = {}
    for _s in [Portable]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, PortablePairBase, name, value)
    __swig_getmethods__ = {}
    for _s in [Portable]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, PortablePairBase, name)
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    def readPair(*args):
        """readPair(ConnectionReader connection, Portable head, Portable body) -> bool"""
        return _yarp.PortablePairBase_readPair(*args)

    if _newclass:readPair = staticmethod(readPair)
    __swig_getmethods__["readPair"] = lambda x: readPair
    def writePair(*args):
        """writePair(ConnectionWriter connection, Portable head, Portable body) -> bool"""
        return _yarp.PortablePairBase_writePair(*args)

    if _newclass:writePair = staticmethod(writePair)
    __swig_getmethods__["writePair"] = lambda x: writePair
    __swig_destroy__ = _yarp.delete_PortablePairBase
    __del__ = lambda self : None;
PortablePairBase_swigregister = _yarp.PortablePairBase_swigregister
PortablePairBase_swigregister(PortablePairBase)

def PortablePairBase_readPair(*args):
  """PortablePairBase_readPair(ConnectionReader connection, Portable head, Portable body) -> bool"""
  return _yarp.PortablePairBase_readPair(*args)

def PortablePairBase_writePair(*args):
  """PortablePairBase_writePair(ConnectionWriter connection, Portable head, Portable body) -> bool"""
  return _yarp.PortablePairBase_writePair(*args)

class PortReaderCreator(_object):
    """Proxy of C++ yarp::os::PortReaderCreator class"""
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, PortReaderCreator, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, PortReaderCreator, name)
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _yarp.delete_PortReaderCreator
    __del__ = lambda self : None;
    def create(self):
        """create(PortReaderCreator self) -> PortReader"""
        return _yarp.PortReaderCreator_create(self)

PortReaderCreator_swigregister = _yarp.PortReaderCreator_swigregister
PortReaderCreator_swigregister(PortReaderCreator)

class Property(Searchable,Portable):
    """Proxy of C++ yarp::os::Property class"""
    __swig_setmethods__ = {}
    for _s in [Searchable,Portable]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, Property, name, value)
    __swig_getmethods__ = {}
    for _s in [Searchable,Portable]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, Property, name)
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(yarp::os::Property self, int hash_size=0) -> Property
        __init__(yarp::os::Property self) -> Property
        __init__(yarp::os::Property self, char const * str) -> Property
        __init__(yarp::os::Property self, Property prop) -> Property
        """
        this = _yarp.new_Property(*args)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _yarp.delete_Property
    __del__ = lambda self : None;
    def check(self, *args):
        """
        check(Property self, char const * key, char const * comment) -> bool
        check(Property self, char const * key, Value fallback, char const * comment=None) -> Value
        check(Property self, char const * key, Value fallback) -> Value
        check(Property self, char const * key) -> bool
        """
        return _yarp.Property_check(self, *args)

    def put(self, *args):
        """
        put(Property self, char const * key, char const * value)
        put(Property self, char const * key, ConstString value)
        put(Property self, char const * key, Value value)
        put(Property self, char const * key, int v)
        put(Property self, char const * key, double v)
        """
        return _yarp.Property_put(self, *args)

    def unput(self, *args):
        """unput(Property self, char const * key)"""
        return _yarp.Property_unput(self, *args)

    def find(self, *args):
        """find(Property self, char const * key) -> Value"""
        return _yarp.Property_find(self, *args)

    def findGroup(self, *args):
        """
        findGroup(Property self, char const * key, char const * comment) -> Bottle
        findGroup(Property self, char const * key) -> Bottle
        """
        return _yarp.Property_findGroup(self, *args)

    def clear(self):
        """clear(Property self)"""
        return _yarp.Property_clear(self)

    def fromString(self, *args):
        """
        fromString(Property self, char const * txt, bool wipe=True)
        fromString(Property self, char const * txt)
        """
        return _yarp.Property_fromString(self, *args)

    def fromCommand(self, *args):
        """
        fromCommand(Property self, int argc, char *[] argv, bool skipFirst=True, bool wipe=True)
        fromCommand(Property self, int argc, char *[] argv, bool skipFirst=True)
        fromCommand(Property self, int argc, char *[] argv)
        """
        return _yarp.Property_fromCommand(self, *args)

    def fromConfigFile(self, *args):
        """
        fromConfigFile(Property self, char const * fname, bool wipe=True) -> bool
        fromConfigFile(Property self, char const * fname) -> bool
        fromConfigFile(Property self, char const * fname, Searchable env, bool wipe=True) -> bool
        fromConfigFile(Property self, char const * fname, Searchable env) -> bool
        """
        return _yarp.Property_fromConfigFile(self, *args)

    def fromConfig(self, *args):
        """
        fromConfig(Property self, char const * txt, bool wipe=True)
        fromConfig(Property self, char const * txt)
        fromConfig(Property self, char const * txt, Searchable env, bool wipe=True)
        fromConfig(Property self, char const * txt, Searchable env)
        """
        return _yarp.Property_fromConfig(self, *args)

    def fromQuery(self, *args):
        """
        fromQuery(Property self, char const * url, bool wipe=True)
        fromQuery(Property self, char const * url)
        """
        return _yarp.Property_fromQuery(self, *args)

    def toString_c(self):
        """toString_c(Property self) -> ConstString"""
        return _yarp.Property_toString_c(self)

    def read(self, *args):
        """read(Property self, ConnectionReader connection) -> bool"""
        return _yarp.Property_read(self, *args)

    def write(self, *args):
        """write(Property self, ConnectionWriter connection) -> bool"""
        return _yarp.Property_write(self, *args)

    def toString(self):
        """toString(Property self) -> std::string"""
        return _yarp.Property_toString(self)

Property_swigregister = _yarp.Property_swigregister
Property_swigregister(Property)

class Port(Contactable):
    """Proxy of C++ yarp::os::Port class"""
    __swig_setmethods__ = {}
    for _s in [Contactable]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, Port, name, value)
    __swig_getmethods__ = {}
    for _s in [Contactable]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, Port, name)
    __repr__ = _swig_repr
    def __init__(self): 
        """__init__(yarp::os::Port self) -> Port"""
        this = _yarp.new_Port()
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _yarp.delete_Port
    __del__ = lambda self : None;
    def openFake(self, *args):
        """openFake(Port self, char const * name) -> bool"""
        return _yarp.Port_openFake(self, *args)

    def addOutput(self, *args):
        """
        addOutput(Port self, char const * name) -> bool
        addOutput(Port self, char const * name, char const * carrier) -> bool
        addOutput(Port self, Contact contact) -> bool
        """
        return _yarp.Port_addOutput(self, *args)

    def close(self):
        """close(Port self)"""
        return _yarp.Port_close(self)

    def interrupt(self):
        """interrupt(Port self)"""
        return _yarp.Port_interrupt(self)

    def resume(self):
        """resume(Port self)"""
        return _yarp.Port_resume(self)

    def where(self):
        """where(Port self) -> Contact"""
        return _yarp.Port_where(self)

    def read(self, *args):
        """
        read(Port self, PortReader reader, bool willReply=False) -> bool
        read(Port self, PortReader reader) -> bool
        """
        return _yarp.Port_read(self, *args)

    def replyAndDrop(self, *args):
        """replyAndDrop(Port self, PortWriter writer) -> bool"""
        return _yarp.Port_replyAndDrop(self, *args)

    def setReader(self, *args):
        """setReader(Port self, PortReader reader)"""
        return _yarp.Port_setReader(self, *args)

    def setReaderCreator(self, *args):
        """setReaderCreator(Port self, PortReaderCreator creator)"""
        return _yarp.Port_setReaderCreator(self, *args)

    def enableBackgroundWrite(self, *args):
        """enableBackgroundWrite(Port self, bool backgroundFlag)"""
        return _yarp.Port_enableBackgroundWrite(self, *args)

    def isWriting(self):
        """isWriting(Port self) -> bool"""
        return _yarp.Port_isWriting(self)

    def setEnvelope(self, *args):
        """setEnvelope(Port self, PortWriter envelope) -> bool"""
        return _yarp.Port_setEnvelope(self, *args)

    def getEnvelope(self, *args):
        """getEnvelope(Port self, PortReader envelope) -> bool"""
        return _yarp.Port_getEnvelope(self, *args)

    def getInputCount(self):
        """getInputCount(Port self) -> int"""
        return _yarp.Port_getInputCount(self)

    def getOutputCount(self):
        """getOutputCount(Port self) -> int"""
        return _yarp.Port_getOutputCount(self)

    def getReport(self, *args):
        """getReport(Port self, PortReport reporter)"""
        return _yarp.Port_getReport(self, *args)

    def setReporter(self, *args):
        """setReporter(Port self, PortReport reporter)"""
        return _yarp.Port_setReporter(self, *args)

    def setAdminMode(self, adminMode=True):
        """
        setAdminMode(Port self, bool adminMode=True)
        setAdminMode(Port self)
        """
        return _yarp.Port_setAdminMode(self, adminMode)

    def setInputMode(self, *args):
        """setInputMode(Port self, bool expectInput)"""
        return _yarp.Port_setInputMode(self, *args)

    def setOutputMode(self, *args):
        """setOutputMode(Port self, bool expectOutput)"""
        return _yarp.Port_setOutputMode(self, *args)

    def setRpcMode(self, *args):
        """setRpcMode(Port self, bool expectRpc)"""
        return _yarp.Port_setRpcMode(self, *args)

    def setTimeout(self, *args):
        """setTimeout(Port self, float timeout) -> bool"""
        return _yarp.Port_setTimeout(self, *args)

    def setVerbosity(self, *args):
        """setVerbosity(Port self, int level)"""
        return _yarp.Port_setVerbosity(self, *args)

    def getVerbosity(self):
        """getVerbosity(Port self) -> int"""
        return _yarp.Port_getVerbosity(self)

    def write(self, *args):
        """
        write(Port self, PortWriter writer, PortWriter callback=None) -> bool
        write(Port self, PortWriter writer) -> bool
        write(Port self, PortWriter writer, PortReader reader, PortWriter callback=None) -> bool
        write(Port self, PortWriter writer, PortReader reader) -> bool
        write(Port self, Bottle data) -> bool
        write(Port self, Property data) -> bool
        write(Port self, ImageRgb data) -> bool
        write(Port self, ImageFloat data) -> bool
        write(Port self, Bottle data1, Bottle data2) -> bool
        write(Port self, Bottle data1, ImageFloat data2) -> bool
        """
        return _yarp.Port_write(self, *args)

    def reply(self, *args):
        """
        reply(Port self, PortWriter writer) -> bool
        reply(Port self, Bottle data) -> bool
        """
        return _yarp.Port_reply(self, *args)

Port_swigregister = _yarp.Port_swigregister
Port_swigregister(Port)

BOTTLE_TAG_INT = _yarp.BOTTLE_TAG_INT
BOTTLE_TAG_VOCAB = _yarp.BOTTLE_TAG_VOCAB
BOTTLE_TAG_DOUBLE = _yarp.BOTTLE_TAG_DOUBLE
BOTTLE_TAG_STRING = _yarp.BOTTLE_TAG_STRING
BOTTLE_TAG_BLOB = _yarp.BOTTLE_TAG_BLOB
BOTTLE_TAG_LIST = _yarp.BOTTLE_TAG_LIST
BOTTLE_TAG_DICT = _yarp.BOTTLE_TAG_DICT
class Bottle(Portable,Searchable):
    """Proxy of C++ yarp::os::Bottle class"""
    __swig_setmethods__ = {}
    for _s in [Portable,Searchable]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, Bottle, name, value)
    __swig_getmethods__ = {}
    for _s in [Portable,Searchable]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, Bottle, name)
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(yarp::os::Bottle self) -> Bottle
        __init__(yarp::os::Bottle self, char const * text) -> Bottle
        __init__(yarp::os::Bottle self, Bottle bottle) -> Bottle
        """
        this = _yarp.new_Bottle(*args)
        try: self.this.append(this)
        except: self.this = this
    def clear(self):
        """clear(Bottle self)"""
        return _yarp.Bottle_clear(self)

    def addInt(self, *args):
        """addInt(Bottle self, int x)"""
        return _yarp.Bottle_addInt(self, *args)

    def addVocab(self, *args):
        """addVocab(Bottle self, int x)"""
        return _yarp.Bottle_addVocab(self, *args)

    def addDouble(self, *args):
        """addDouble(Bottle self, double x)"""
        return _yarp.Bottle_addDouble(self, *args)

    def addString(self, *args):
        """
        addString(Bottle self, char const * str)
        addString(Bottle self, ConstString str)
        """
        return _yarp.Bottle_addString(self, *args)

    def add(self, *args):
        """add(Bottle self, Value value)"""
        return _yarp.Bottle_add(self, *args)

    def addList(self):
        """addList(Bottle self) -> Bottle"""
        return _yarp.Bottle_addList(self)

    def addDict(self):
        """addDict(Bottle self) -> Property"""
        return _yarp.Bottle_addDict(self)

    def pop(self):
        """pop(Bottle self) -> Value"""
        return _yarp.Bottle_pop(self)

    def get(self, *args):
        """get(Bottle self, int index) -> Value"""
        return _yarp.Bottle_get(self, *args)

    def size(self):
        """size(Bottle self) -> int"""
        return _yarp.Bottle_size(self)

    def fromString(self, *args):
        """fromString(Bottle self, char const * text)"""
        return _yarp.Bottle_fromString(self, *args)

    def fromBinary(self, *args):
        """fromBinary(Bottle self, char const * buf, int len)"""
        return _yarp.Bottle_fromBinary(self, *args)

    def toBinary(self, size=None):
        """
        toBinary(Bottle self, size_t * size=None) -> char const
        toBinary(Bottle self) -> char const *
        """
        return _yarp.Bottle_toBinary(self, size)

    def toString_c(self):
        """toString_c(Bottle self) -> ConstString"""
        return _yarp.Bottle_toString_c(self)

    def write(self, *args):
        """
        write(Bottle self, ConnectionWriter writer) -> bool
        write(Bottle self, PortReader reader, bool textMode=False) -> bool
        write(Bottle self, PortReader reader) -> bool
        """
        return _yarp.Bottle_write(self, *args)

    def read(self, *args):
        """
        read(Bottle self, ConnectionReader reader) -> bool
        read(Bottle self, PortWriter writer, bool textMode=False) -> bool
        read(Bottle self, PortWriter writer) -> bool
        """
        return _yarp.Bottle_read(self, *args)

    def onCommencement(self):
        """onCommencement(Bottle self)"""
        return _yarp.Bottle_onCommencement(self)

    def check(self, *args):
        """
        check(Bottle self, char const * key, char const * comment) -> bool
        check(Bottle self, char const * key, Value fallback, char const * comment=None) -> Value
        check(Bottle self, char const * key, Value fallback) -> Value
        check(Bottle self, char const * key) -> bool
        """
        return _yarp.Bottle_check(self, *args)

    def find(self, *args):
        """find(Bottle self, char const * key) -> Value"""
        return _yarp.Bottle_find(self, *args)

    def findGroup(self, *args):
        """
        findGroup(Bottle self, char const * key, char const * comment) -> Bottle
        findGroup(Bottle self, char const * key) -> Bottle
        """
        return _yarp.Bottle_findGroup(self, *args)

    def isNull(self):
        """isNull(Bottle self) -> bool"""
        return _yarp.Bottle_isNull(self)

    __swig_destroy__ = _yarp.delete_Bottle
    __del__ = lambda self : None;
    def copy(self, *args):
        """
        copy(Bottle self, Bottle alt, int first=0, int len=-1)
        copy(Bottle self, Bottle alt, int first=0)
        copy(Bottle self, Bottle alt)
        """
        return _yarp.Bottle_copy(self, *args)

    def getNullBottle():
        """getNullBottle() -> Bottle"""
        return _yarp.Bottle_getNullBottle()

    if _newclass:getNullBottle = staticmethod(getNullBottle)
    __swig_getmethods__["getNullBottle"] = lambda x: getNullBottle
    def isEqual(self, *args):
        """isEqual(Bottle self, Bottle alt) -> bool"""
        return _yarp.Bottle_isEqual(self, *args)

    def notEqual(self, *args):
        """notEqual(Bottle self, Bottle alt) -> bool"""
        return _yarp.Bottle_notEqual(self, *args)

    def append(self, *args):
        """append(Bottle self, Bottle alt)"""
        return _yarp.Bottle_append(self, *args)

    def tail(self):
        """tail(Bottle self) -> Bottle"""
        return _yarp.Bottle_tail(self)

    def specialize(self, *args):
        """specialize(Bottle self, int subCode)"""
        return _yarp.Bottle_specialize(self, *args)

    def getSpecialization(self):
        """getSpecialization(Bottle self) -> int"""
        return _yarp.Bottle_getSpecialization(self)

    def setNested(self, *args):
        """setNested(Bottle self, bool nested)"""
        return _yarp.Bottle_setNested(self, *args)

    def hasChanged(self):
        """hasChanged(Bottle self)"""
        return _yarp.Bottle_hasChanged(self)

    def toString(self):
        """toString(Bottle self) -> std::string"""
        return _yarp.Bottle_toString(self)

Bottle_swigregister = _yarp.Bottle_swigregister
Bottle_swigregister(Bottle)

def Bottle_getNullBottle():
  """Bottle_getNullBottle() -> Bottle"""
  return _yarp.Bottle_getNullBottle()


def typedReaderMissingCallback():
  """typedReaderMissingCallback()"""
  return _yarp.typedReaderMissingCallback()
class PortReaderBufferBaseCreator(_object):
    """Proxy of C++ yarp::os::impl::PortReaderBufferBaseCreator class"""
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, PortReaderBufferBaseCreator, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, PortReaderBufferBaseCreator, name)
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _yarp.delete_PortReaderBufferBaseCreator
    __del__ = lambda self : None;
    def create(self):
        """create(PortReaderBufferBaseCreator self) -> PortReader"""
        return _yarp.PortReaderBufferBaseCreator_create(self)

PortReaderBufferBaseCreator_swigregister = _yarp.PortReaderBufferBaseCreator_swigregister
PortReaderBufferBaseCreator_swigregister(PortReaderBufferBaseCreator)

class PortReaderBufferBase(PortReader):
    """Proxy of C++ yarp::os::impl::PortReaderBufferBase class"""
    __swig_setmethods__ = {}
    for _s in [PortReader]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, PortReaderBufferBase, name, value)
    __swig_getmethods__ = {}
    for _s in [PortReader]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, PortReaderBufferBase, name)
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """__init__(yarp::os::impl::PortReaderBufferBase self, unsigned int maxBuffer) -> PortReaderBufferBase"""
        this = _yarp.new_PortReaderBufferBase(*args)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _yarp.delete_PortReaderBufferBase
    __del__ = lambda self : None;
    def setCreator(self, *args):
        """setCreator(PortReaderBufferBase self, PortReaderBufferBaseCreator creator)"""
        return _yarp.PortReaderBufferBase_setCreator(self, *args)

    def setReplier(self, *args):
        """setReplier(PortReaderBufferBase self, PortReader reader)"""
        return _yarp.PortReaderBufferBase_setReplier(self, *args)

    def setPrune(self, flag=True):
        """
        setPrune(PortReaderBufferBase self, bool flag=True)
        setPrune(PortReaderBufferBase self)
        """
        return _yarp.PortReaderBufferBase_setPrune(self, flag)

    def setAllowReuse(self, flag=True):
        """
        setAllowReuse(PortReaderBufferBase self, bool flag=True)
        setAllowReuse(PortReaderBufferBase self)
        """
        return _yarp.PortReaderBufferBase_setAllowReuse(self, flag)

    def setTargetPeriod(self, *args):
        """setTargetPeriod(PortReaderBufferBase self, double period)"""
        return _yarp.PortReaderBufferBase_setTargetPeriod(self, *args)

    def getName(self):
        """getName(PortReaderBufferBase self) -> ConstString"""
        return _yarp.PortReaderBufferBase_getName(self)

    def getMaxBuffer(self):
        """getMaxBuffer(PortReaderBufferBase self) -> unsigned int"""
        return _yarp.PortReaderBufferBase_getMaxBuffer(self)

    def isClosed(self):
        """isClosed(PortReaderBufferBase self) -> bool"""
        return _yarp.PortReaderBufferBase_isClosed(self)

    def create(self):
        """create(PortReaderBufferBase self) -> PortReader"""
        return _yarp.PortReaderBufferBase_create(self)

    def check(self):
        """check(PortReaderBufferBase self) -> int"""
        return _yarp.PortReaderBufferBase_check(self)

    def read(self, *args):
        """read(PortReaderBufferBase self, ConnectionReader connection) -> bool"""
        return _yarp.PortReaderBufferBase_read(self, *args)

    def readBase(self, *args):
        """readBase(PortReaderBufferBase self, bool & missed, bool cleanup) -> PortReader"""
        return _yarp.PortReaderBufferBase_readBase(self, *args)

    def interrupt(self):
        """interrupt(PortReaderBufferBase self)"""
        return _yarp.PortReaderBufferBase_interrupt(self)

    def attachBase(self, *args):
        """attachBase(PortReaderBufferBase self, Port port)"""
        return _yarp.PortReaderBufferBase_attachBase(self, *args)

    def acceptObjectBase(self, *args):
        """acceptObjectBase(PortReaderBufferBase self, PortReader obj, PortWriter wrapper) -> bool"""
        return _yarp.PortReaderBufferBase_acceptObjectBase(self, *args)

    def forgetObjectBase(self, *args):
        """forgetObjectBase(PortReaderBufferBase self, PortReader obj, PortWriter wrapper) -> bool"""
        return _yarp.PortReaderBufferBase_forgetObjectBase(self, *args)

    def getEnvelope(self, *args):
        """getEnvelope(PortReaderBufferBase self, PortReader envelope) -> bool"""
        return _yarp.PortReaderBufferBase_getEnvelope(self, *args)

    def acquire(self):
        """acquire(PortReaderBufferBase self) -> void *"""
        return _yarp.PortReaderBufferBase_acquire(self)

    def release(self, *args):
        """
        release(PortReaderBufferBase self, PortReader completed)
        release(PortReaderBufferBase self, void * key)
        """
        return _yarp.PortReaderBufferBase_release(self, *args)

    def setAutoRelease(self, flag=True):
        """
        setAutoRelease(PortReaderBufferBase self, bool flag=True)
        setAutoRelease(PortReaderBufferBase self)
        """
        return _yarp.PortReaderBufferBase_setAutoRelease(self, flag)

PortReaderBufferBase_swigregister = _yarp.PortReaderBufferBase_swigregister
PortReaderBufferBase_swigregister(PortReaderBufferBase)

class PortWriterBufferManager(_object):
    """Proxy of C++ yarp::os::PortWriterBufferManager class"""
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, PortWriterBufferManager, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, PortWriterBufferManager, name)
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _yarp.delete_PortWriterBufferManager
    __del__ = lambda self : None;
    def onCompletion(self, *args):
        """onCompletion(PortWriterBufferManager self, void * tracker)"""
        return _yarp.PortWriterBufferManager_onCompletion(self, *args)

PortWriterBufferManager_swigregister = _yarp.PortWriterBufferManager_swigregister
PortWriterBufferManager_swigregister(PortWriterBufferManager)

class PortWriterWrapper(PortWriter):
    """Proxy of C++ yarp::os::PortWriterWrapper class"""
    __swig_setmethods__ = {}
    for _s in [PortWriter]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, PortWriterWrapper, name, value)
    __swig_getmethods__ = {}
    for _s in [PortWriter]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, PortWriterWrapper, name)
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    def getInternal(self):
        """getInternal(PortWriterWrapper self) -> PortWriter"""
        return _yarp.PortWriterWrapper_getInternal(self)

    __swig_destroy__ = _yarp.delete_PortWriterWrapper
    __del__ = lambda self : None;
PortWriterWrapper_swigregister = _yarp.PortWriterWrapper_swigregister
PortWriterWrapper_swigregister(PortWriterWrapper)

class PortWriterBufferBase(_object):
    """Proxy of C++ yarp::os::PortWriterBufferBase class"""
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, PortWriterBufferBase, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, PortWriterBufferBase, name)
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _yarp.delete_PortWriterBufferBase
    __del__ = lambda self : None;
    def create(self, *args):
        """create(PortWriterBufferBase self, PortWriterBufferManager man, void * tracker) -> PortWriterWrapper"""
        return _yarp.PortWriterBufferBase_create(self, *args)

    def getContent(self):
        """getContent(PortWriterBufferBase self) -> void *"""
        return _yarp.PortWriterBufferBase_getContent(self)

    def releaseContent(self):
        """releaseContent(PortWriterBufferBase self) -> bool"""
        return _yarp.PortWriterBufferBase_releaseContent(self)

    def getCount(self):
        """getCount(PortWriterBufferBase self) -> int"""
        return _yarp.PortWriterBufferBase_getCount(self)

    def attach(self, *args):
        """attach(PortWriterBufferBase self, Port port)"""
        return _yarp.PortWriterBufferBase_attach(self, *args)

    def write(self, *args):
        """write(PortWriterBufferBase self, bool strict)"""
        return _yarp.PortWriterBufferBase_write(self, *args)

PortWriterBufferBase_swigregister = _yarp.PortWriterBufferBase_swigregister
PortWriterBufferBase_swigregister(PortWriterBufferBase)

class Random(_object):
    """Proxy of C++ yarp::os::Random class"""
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, Random, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, Random, name)
    __repr__ = _swig_repr
    def seed_c(*args):
        """seed_c(int seed)"""
        return _yarp.Random_seed_c(*args)

    if _newclass:seed_c = staticmethod(seed_c)
    __swig_getmethods__["seed_c"] = lambda x: seed_c
    def normal(*args):
        """
        normal(double m, double s) -> double
        normal() -> double
        """
        return _yarp.Random_normal(*args)

    if _newclass:normal = staticmethod(normal)
    __swig_getmethods__["normal"] = lambda x: normal
    def uniform(*args):
        """
        uniform() -> double
        uniform(int min, int max) -> int
        """
        return _yarp.Random_uniform(*args)

    if _newclass:uniform = staticmethod(uniform)
    __swig_getmethods__["uniform"] = lambda x: uniform
    def __init__(self): 
        """__init__(yarp::os::Random self) -> Random"""
        this = _yarp.new_Random()
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _yarp.delete_Random
    __del__ = lambda self : None;
Random_swigregister = _yarp.Random_swigregister
Random_swigregister(Random)

def Random_seed_c(*args):
  """Random_seed_c(int seed)"""
  return _yarp.Random_seed_c(*args)

def Random_normal(*args):
  """
    normal(double m, double s) -> double
    Random_normal() -> double
    """
  return _yarp.Random_normal(*args)

def Random_uniform(*args):
  """
    uniform() -> double
    Random_uniform(int min, int max) -> int
    """
  return _yarp.Random_uniform(*args)

class Semaphore(_object):
    """Proxy of C++ yarp::os::Semaphore class"""
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, Semaphore, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, Semaphore, name)
    __repr__ = _swig_repr
    def __init__(self, initialCount=1): 
        """
        __init__(yarp::os::Semaphore self, unsigned int initialCount=1) -> Semaphore
        __init__(yarp::os::Semaphore self) -> Semaphore
        """
        this = _yarp.new_Semaphore(initialCount)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _yarp.delete_Semaphore
    __del__ = lambda self : None;
    def wait(self):
        """wait(Semaphore self)"""
        return _yarp.Semaphore_wait(self)

    def waitWithTimeout(self, *args):
        """waitWithTimeout(Semaphore self, double timeoutInSeconds) -> bool"""
        return _yarp.Semaphore_waitWithTimeout(self, *args)

    def check(self):
        """check(Semaphore self) -> bool"""
        return _yarp.Semaphore_check(self)

    def post(self):
        """post(Semaphore self)"""
        return _yarp.Semaphore_post(self)

Semaphore_swigregister = _yarp.Semaphore_swigregister
Semaphore_swigregister(Semaphore)

class Thread(_object):
    """Proxy of C++ yarp::os::Thread class"""
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, Thread, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, Thread, name)
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _yarp.delete_Thread
    __del__ = lambda self : None;
    def run(self):
        """run(Thread self)"""
        return _yarp.Thread_run(self)

    def onStop(self):
        """onStop(Thread self)"""
        return _yarp.Thread_onStop(self)

    def start(self):
        """start(Thread self) -> bool"""
        return _yarp.Thread_start(self)

    def stop(self):
        """stop(Thread self) -> bool"""
        return _yarp.Thread_stop(self)

    def beforeStart(self):
        """beforeStart(Thread self)"""
        return _yarp.Thread_beforeStart(self)

    def afterStart(self, *args):
        """afterStart(Thread self, bool success)"""
        return _yarp.Thread_afterStart(self, *args)

    def threadInit(self):
        """threadInit(Thread self) -> bool"""
        return _yarp.Thread_threadInit(self)

    def threadRelease(self):
        """threadRelease(Thread self)"""
        return _yarp.Thread_threadRelease(self)

    def isStopping(self):
        """isStopping(Thread self) -> bool"""
        return _yarp.Thread_isStopping(self)

    def isRunning(self):
        """isRunning(Thread self) -> bool"""
        return _yarp.Thread_isRunning(self)

    def setOptions(self, stackSize=0):
        """
        setOptions(Thread self, int stackSize=0)
        setOptions(Thread self)
        """
        return _yarp.Thread_setOptions(self, stackSize)

    def getCount():
        """getCount() -> int"""
        return _yarp.Thread_getCount()

    if _newclass:getCount = staticmethod(getCount)
    __swig_getmethods__["getCount"] = lambda x: getCount
    def getKey(self):
        """getKey(Thread self) -> long"""
        return _yarp.Thread_getKey(self)

    def setPriority(self, *args):
        """setPriority(Thread self, int priority) -> int"""
        return _yarp.Thread_setPriority(self, *args)

    def getPriority(self):
        """getPriority(Thread self) -> int"""
        return _yarp.Thread_getPriority(self)

    def setDefaultStackSize(*args):
        """setDefaultStackSize(int stackSize)"""
        return _yarp.Thread_setDefaultStackSize(*args)

    if _newclass:setDefaultStackSize = staticmethod(setDefaultStackSize)
    __swig_getmethods__["setDefaultStackSize"] = lambda x: setDefaultStackSize
    def join(self, *args):
        """
        join(Thread self, double seconds=-1) -> bool
        join(Thread self) -> bool
        """
        return _yarp.Thread_join(self, *args)

Thread_swigregister = _yarp.Thread_swigregister
Thread_swigregister(Thread)

def Thread_getCount():
  """Thread_getCount() -> int"""
  return _yarp.Thread_getCount()

def Thread_setDefaultStackSize(*args):
  """Thread_setDefaultStackSize(int stackSize)"""
  return _yarp.Thread_setDefaultStackSize(*args)

class Time(_object):
    """Proxy of C++ yarp::os::Time class"""
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, Time, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, Time, name)
    __repr__ = _swig_repr
    def delay(*args):
        """delay(double seconds)"""
        return _yarp.Time_delay(*args)

    if _newclass:delay = staticmethod(delay)
    __swig_getmethods__["delay"] = lambda x: delay
    def now():
        """now() -> double"""
        return _yarp.Time_now()

    if _newclass:now = staticmethod(now)
    __swig_getmethods__["now"] = lambda x: now
    def yield_c():
        """yield_c()"""
        return _yarp.Time_yield_c()

    if _newclass:yield_c = staticmethod(yield_c)
    __swig_getmethods__["yield_c"] = lambda x: yield_c
    def turboBoost():
        """turboBoost()"""
        return _yarp.Time_turboBoost()

    if _newclass:turboBoost = staticmethod(turboBoost)
    __swig_getmethods__["turboBoost"] = lambda x: turboBoost
    def __init__(self): 
        """__init__(yarp::os::Time self) -> Time"""
        this = _yarp.new_Time()
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _yarp.delete_Time
    __del__ = lambda self : None;
Time_swigregister = _yarp.Time_swigregister
Time_swigregister(Time)

def Time_delay(*args):
  """Time_delay(double seconds)"""
  return _yarp.Time_delay(*args)

def Time_now():
  """Time_now() -> double"""
  return _yarp.Time_now()

def Time_yield_c():
  """Time_yield_c()"""
  return _yarp.Time_yield_c()

def Time_turboBoost():
  """Time_turboBoost()"""
  return _yarp.Time_turboBoost()

class RFModule(_object):
    """Proxy of C++ yarp::os::RFModule class"""
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, RFModule, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, RFModule, name)
    __repr__ = _swig_repr
    def __init__(self): 
        """__init__(yarp::os::RFModule self) -> RFModule"""
        if self.__class__ == RFModule:
            _self = None
        else:
            _self = self
        this = _yarp.new_RFModule(_self, )
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _yarp.delete_RFModule
    __del__ = lambda self : None;
    def getPeriod(self):
        """getPeriod(RFModule self) -> double"""
        return _yarp.RFModule_getPeriod(self)

    def updateModule(self):
        """updateModule(RFModule self) -> bool"""
        return _yarp.RFModule_updateModule(self)

    def runModule(self, *args):
        """
        runModule(RFModule self) -> int
        runModule(RFModule self, ResourceFinder rf) -> int
        """
        return _yarp.RFModule_runModule(self, *args)

    def configure(self, *args):
        """configure(RFModule self, ResourceFinder rf) -> bool"""
        return _yarp.RFModule_configure(self, *args)

    def respond(self, *args):
        """respond(RFModule self, Bottle command, Bottle reply) -> bool"""
        return _yarp.RFModule_respond(self, *args)

    def attach(self, *args):
        """attach(RFModule self, Port source) -> bool"""
        return _yarp.RFModule_attach(self, *args)

    def attach_rpc_server(self, *args):
        """attach_rpc_server(RFModule self, RpcServer source) -> bool"""
        return _yarp.RFModule_attach_rpc_server(self, *args)

    def attachTerminal(self):
        """attachTerminal(RFModule self) -> bool"""
        return _yarp.RFModule_attachTerminal(self)

    def detachTerminal(self):
        """detachTerminal(RFModule self) -> bool"""
        return _yarp.RFModule_detachTerminal(self)

    def interruptModule(self):
        """interruptModule(RFModule self) -> bool"""
        return _yarp.RFModule_interruptModule(self)

    def close(self):
        """close(RFModule self) -> bool"""
        return _yarp.RFModule_close(self)

    def stopModule(self, wait=False):
        """
        stopModule(RFModule self, bool wait=False)
        stopModule(RFModule self)
        """
        return _yarp.RFModule_stopModule(self, wait)

    def isStopping(self):
        """isStopping(RFModule self) -> bool"""
        return _yarp.RFModule_isStopping(self)

    def getName(self, subName=None):
        """
        getName(RFModule self, char const * subName=None) -> ConstString
        getName(RFModule self) -> ConstString
        """
        return _yarp.RFModule_getName(self, subName)

    def setName(self, *args):
        """setName(RFModule self, char const * name)"""
        return _yarp.RFModule_setName(self, *args)

    def safeRespond(self, *args):
        """safeRespond(RFModule self, Bottle command, Bottle reply) -> bool"""
        return _yarp.RFModule_safeRespond(self, *args)

    def __disown__(self):
        self.this.disown()
        _yarp.disown_RFModule(self)
        return weakref_proxy(self)
RFModule_swigregister = _yarp.RFModule_swigregister
RFModule_swigregister(RFModule)

class Stamp(Portable):
    """Proxy of C++ yarp::os::Stamp class"""
    __swig_setmethods__ = {}
    for _s in [Portable]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, Stamp, name, value)
    __swig_getmethods__ = {}
    for _s in [Portable]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, Stamp, name)
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(yarp::os::Stamp self) -> Stamp
        __init__(yarp::os::Stamp self, int count, double time) -> Stamp
        """
        this = _yarp.new_Stamp(*args)
        try: self.this.append(this)
        except: self.this = this
    def getCount(self):
        """getCount(Stamp self) -> int"""
        return _yarp.Stamp_getCount(self)

    def getTime(self):
        """getTime(Stamp self) -> double"""
        return _yarp.Stamp_getTime(self)

    def isValid(self):
        """isValid(Stamp self) -> bool"""
        return _yarp.Stamp_isValid(self)

    def getMaxCount(self):
        """getMaxCount(Stamp self) -> int"""
        return _yarp.Stamp_getMaxCount(self)

    def update(self, *args):
        """
        update(Stamp self)
        update(Stamp self, double time)
        """
        return _yarp.Stamp_update(self, *args)

    def read(self, *args):
        """read(Stamp self, ConnectionReader connection) -> bool"""
        return _yarp.Stamp_read(self, *args)

    def write(self, *args):
        """write(Stamp self, ConnectionWriter connection) -> bool"""
        return _yarp.Stamp_write(self, *args)

    __swig_destroy__ = _yarp.delete_Stamp
    __del__ = lambda self : None;
Stamp_swigregister = _yarp.Stamp_swigregister
Stamp_swigregister(Stamp)

class Stamped(_object):
    """Proxy of C++ yarp::os::Stamped class"""
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, Stamped, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, Stamped, name)
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _yarp.delete_Stamped
    __del__ = lambda self : None;
    def getStamp(self):
        """getStamp(Stamped self) -> Stamp"""
        return _yarp.Stamped_getStamp(self)

Stamped_swigregister = _yarp.Stamped_swigregister
Stamped_swigregister(Stamped)

class NameStore(_object):
    """Proxy of C++ yarp::os::NameStore class"""
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, NameStore, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, NameStore, name)
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _yarp.delete_NameStore
    __del__ = lambda self : None;
    def query(self, *args):
        """query(NameStore self, char const * name) -> Contact"""
        return _yarp.NameStore_query(self, *args)

    def announce(self, *args):
        """announce(NameStore self, char const * name, int activity) -> bool"""
        return _yarp.NameStore_announce(self, *args)

NameStore_swigregister = _yarp.NameStore_swigregister
NameStore_swigregister(NameStore)

class ContactStyle(_object):
    """Proxy of C++ yarp::os::ContactStyle class"""
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, ContactStyle, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, ContactStyle, name)
    __repr__ = _swig_repr
    __swig_setmethods__["admin"] = _yarp.ContactStyle_admin_set
    __swig_getmethods__["admin"] = _yarp.ContactStyle_admin_get
    if _newclass:admin = _swig_property(_yarp.ContactStyle_admin_get, _yarp.ContactStyle_admin_set)
    __swig_setmethods__["quiet"] = _yarp.ContactStyle_quiet_set
    __swig_getmethods__["quiet"] = _yarp.ContactStyle_quiet_get
    if _newclass:quiet = _swig_property(_yarp.ContactStyle_quiet_get, _yarp.ContactStyle_quiet_set)
    __swig_setmethods__["timeout"] = _yarp.ContactStyle_timeout_set
    __swig_getmethods__["timeout"] = _yarp.ContactStyle_timeout_get
    if _newclass:timeout = _swig_property(_yarp.ContactStyle_timeout_get, _yarp.ContactStyle_timeout_set)
    __swig_setmethods__["carrier"] = _yarp.ContactStyle_carrier_set
    __swig_getmethods__["carrier"] = _yarp.ContactStyle_carrier_get
    if _newclass:carrier = _swig_property(_yarp.ContactStyle_carrier_get, _yarp.ContactStyle_carrier_set)
    __swig_setmethods__["expectReply"] = _yarp.ContactStyle_expectReply_set
    __swig_getmethods__["expectReply"] = _yarp.ContactStyle_expectReply_get
    if _newclass:expectReply = _swig_property(_yarp.ContactStyle_expectReply_get, _yarp.ContactStyle_expectReply_set)
    __swig_setmethods__["persistent"] = _yarp.ContactStyle_persistent_set
    __swig_getmethods__["persistent"] = _yarp.ContactStyle_persistent_get
    if _newclass:persistent = _swig_property(_yarp.ContactStyle_persistent_get, _yarp.ContactStyle_persistent_set)
    OPENENDED = _yarp.ContactStyle_OPENENDED
    END_WITH_FROM_PORT = _yarp.ContactStyle_END_WITH_FROM_PORT
    END_WITH_TO_PORT = _yarp.ContactStyle_END_WITH_TO_PORT
    NO_PERSISTENCE = _yarp.ContactStyle_NO_PERSISTENCE
    __swig_setmethods__["persistenceType"] = _yarp.ContactStyle_persistenceType_set
    __swig_getmethods__["persistenceType"] = _yarp.ContactStyle_persistenceType_get
    if _newclass:persistenceType = _swig_property(_yarp.ContactStyle_persistenceType_get, _yarp.ContactStyle_persistenceType_set)
    def __init__(self): 
        """__init__(yarp::os::ContactStyle self) -> ContactStyle"""
        this = _yarp.new_ContactStyle()
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _yarp.delete_ContactStyle
    __del__ = lambda self : None;
ContactStyle_swigregister = _yarp.ContactStyle_swigregister
ContactStyle_swigregister(ContactStyle)

class ResourceFinder(Searchable):
    """Proxy of C++ yarp::os::ResourceFinder class"""
    __swig_setmethods__ = {}
    for _s in [Searchable]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, ResourceFinder, name, value)
    __swig_getmethods__ = {}
    for _s in [Searchable]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, ResourceFinder, name)
    __repr__ = _swig_repr
    def __init__(self): 
        """__init__(yarp::os::ResourceFinder self) -> ResourceFinder"""
        this = _yarp.new_ResourceFinder()
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _yarp.delete_ResourceFinder
    __del__ = lambda self : None;
    def setVerbose(self, verbose=True):
        """
        setVerbose(ResourceFinder self, bool verbose=True) -> bool
        setVerbose(ResourceFinder self) -> bool
        """
        return _yarp.ResourceFinder_setVerbose(self, verbose)

    def setQuiet(self, quiet=True):
        """
        setQuiet(ResourceFinder self, bool quiet=True) -> bool
        setQuiet(ResourceFinder self) -> bool
        """
        return _yarp.ResourceFinder_setQuiet(self, quiet)

    def setDefaultContext(self, *args):
        """setDefaultContext(ResourceFinder self, char const * contextName) -> bool"""
        return _yarp.ResourceFinder_setDefaultContext(self, *args)

    def setContext(self, *args):
        """setContext(ResourceFinder self, char const * contextName) -> bool"""
        return _yarp.ResourceFinder_setContext(self, *args)

    def setDefault(self, *args):
        """setDefault(ResourceFinder self, char const * key, char const * val) -> bool"""
        return _yarp.ResourceFinder_setDefault(self, *args)

    def setDefaultConfigFile(self, *args):
        """setDefaultConfigFile(ResourceFinder self, char const * fname) -> bool"""
        return _yarp.ResourceFinder_setDefaultConfigFile(self, *args)

    def findFile(self, *args):
        """findFile(ResourceFinder self, char const * key) -> ConstString"""
        return _yarp.ResourceFinder_findFile(self, *args)

    def findPaths(self, *args):
        """findPaths(ResourceFinder self, char const * key) -> Bottle"""
        return _yarp.ResourceFinder_findPaths(self, *args)

    def findPath(self, *args):
        """
        findPath(ResourceFinder self, char const * key) -> ConstString
        findPath(ResourceFinder self) -> ConstString
        """
        return _yarp.ResourceFinder_findPath(self, *args)

    def getContext(self):
        """getContext(ResourceFinder self) -> ConstString"""
        return _yarp.ResourceFinder_getContext(self)

    def getContextPath(self):
        """getContextPath(ResourceFinder self) -> ConstString"""
        return _yarp.ResourceFinder_getContextPath(self)

    def getContexts(self):
        """getContexts(ResourceFinder self) -> Bottle"""
        return _yarp.ResourceFinder_getContexts(self)

    def find(self, *args):
        """find(ResourceFinder self, char const * key) -> Value"""
        return _yarp.ResourceFinder_find(self, *args)

    def isNull(self):
        """isNull(ResourceFinder self) -> bool"""
        return _yarp.ResourceFinder_isNull(self)

    def toString_c(self):
        """toString_c(ResourceFinder self) -> ConstString"""
        return _yarp.ResourceFinder_toString_c(self)

    def findNestedResourceFinder(self, *args):
        """findNestedResourceFinder(ResourceFinder self, char const * key) -> ResourceFinder"""
        return _yarp.ResourceFinder_findNestedResourceFinder(self, *args)

    def isConfigured(self):
        """isConfigured(ResourceFinder self) -> bool"""
        return _yarp.ResourceFinder_isConfigured(self)

    def getResourceFinderSingleton():
        """getResourceFinderSingleton() -> ResourceFinder"""
        return _yarp.ResourceFinder_getResourceFinderSingleton()

    if _newclass:getResourceFinderSingleton = staticmethod(getResourceFinderSingleton)
    __swig_getmethods__["getResourceFinderSingleton"] = lambda x: getResourceFinderSingleton
    def check(self, *args):
        """
        check(ResourceFinder self, char const * key) -> bool
        check(ResourceFinder self, char const * key, char const * comment) -> bool
        check(ResourceFinder self, char const * key, Value fallback, char const * comment=None) -> Value
        check(ResourceFinder self, char const * key, Value fallback) -> Value
        """
        return _yarp.ResourceFinder_check(self, *args)

    def findGroup(self, *args):
        """
        findGroup(ResourceFinder self, char const * key) -> Bottle
        findGroup(ResourceFinder self, char const * key, char const * comment) -> Bottle
        """
        return _yarp.ResourceFinder_findGroup(self, *args)

    def configure(self, *args):
        """
        configure(ResourceFinder self, char const * policyName, int argc, char *[] argv, bool skipFirstArgument=True) -> bool
        configure(ResourceFinder self, char const * policyName, int argc, char *[] argv) -> bool
        configure(ResourceFinder self, int argc, char *[] argv) -> bool
        configure(ResourceFinder self, std::string const & policyName, SVector argv, bool skipFirstArgument=True) -> bool
        configure(ResourceFinder self, std::string const & policyName, SVector argv) -> bool
        """
        return _yarp.ResourceFinder_configure(self, *args)

ResourceFinder_swigregister = _yarp.ResourceFinder_swigregister
ResourceFinder_swigregister(ResourceFinder)

def ResourceFinder_getResourceFinderSingleton():
  """ResourceFinder_getResourceFinderSingleton() -> ResourceFinder"""
  return _yarp.ResourceFinder_getResourceFinderSingleton()

class RpcServer(Contactable):
    """Proxy of C++ yarp::os::RpcServer class"""
    __swig_setmethods__ = {}
    for _s in [Contactable]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, RpcServer, name, value)
    __swig_getmethods__ = {}
    for _s in [Contactable]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, RpcServer, name)
    __repr__ = _swig_repr
    def __init__(self): 
        """__init__(yarp::os::RpcServer self) -> RpcServer"""
        this = _yarp.new_RpcServer()
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _yarp.delete_RpcServer
    __del__ = lambda self : None;
    def open(self, *args):
        """
        open(RpcServer self) -> bool
        open(RpcServer self, Contact contact, bool registerName=True) -> bool
        open(RpcServer self, Contact contact) -> bool
        open(RpcServer self, char const * name) -> bool
        open(RpcServer self, Contact contact, bool registerName=True) -> bool
        open(RpcServer self, Contact contact) -> bool
        """
        return _yarp.RpcServer_open(self, *args)

    def addOutput(self, *args):
        """
        addOutput(RpcServer self, char const * name) -> bool
        addOutput(RpcServer self, char const * name, char const * carrier) -> bool
        addOutput(RpcServer self, Contact contact) -> bool
        """
        return _yarp.RpcServer_addOutput(self, *args)

    def close(self):
        """close(RpcServer self)"""
        return _yarp.RpcServer_close(self)

    def interrupt(self):
        """interrupt(RpcServer self)"""
        return _yarp.RpcServer_interrupt(self)

    def resume(self):
        """resume(RpcServer self)"""
        return _yarp.RpcServer_resume(self)

    def where(self):
        """where(RpcServer self) -> Contact"""
        return _yarp.RpcServer_where(self)

    def getName(self):
        """getName(RpcServer self) -> ConstString"""
        return _yarp.RpcServer_getName(self)

    def read(self, *args):
        """read(RpcServer self, PortReader reader, bool willReply) -> bool"""
        return _yarp.RpcServer_read(self, *args)

    def reply(self, *args):
        """reply(RpcServer self, PortWriter writer) -> bool"""
        return _yarp.RpcServer_reply(self, *args)

    def setReader(self, *args):
        """setReader(RpcServer self, PortReader reader)"""
        return _yarp.RpcServer_setReader(self, *args)

    def setReaderCreator(self, *args):
        """setReaderCreator(RpcServer self, PortReaderCreator creator)"""
        return _yarp.RpcServer_setReaderCreator(self, *args)

    def setEnvelope(self, *args):
        """setEnvelope(RpcServer self, PortWriter envelope) -> bool"""
        return _yarp.RpcServer_setEnvelope(self, *args)

    def getEnvelope(self, *args):
        """getEnvelope(RpcServer self, PortReader envelope) -> bool"""
        return _yarp.RpcServer_getEnvelope(self, *args)

    def getInputCount(self):
        """getInputCount(RpcServer self) -> int"""
        return _yarp.RpcServer_getInputCount(self)

    def getOutputCount(self):
        """getOutputCount(RpcServer self) -> int"""
        return _yarp.RpcServer_getOutputCount(self)

    def getReport(self, *args):
        """getReport(RpcServer self, PortReport reporter)"""
        return _yarp.RpcServer_getReport(self, *args)

    def setReporter(self, *args):
        """setReporter(RpcServer self, PortReport reporter)"""
        return _yarp.RpcServer_setReporter(self, *args)

    def isWriting(self):
        """isWriting(RpcServer self) -> bool"""
        return _yarp.RpcServer_isWriting(self)

RpcServer_swigregister = _yarp.RpcServer_swigregister
RpcServer_swigregister(RpcServer)

class RpcClient(Contactable):
    """Proxy of C++ yarp::os::RpcClient class"""
    __swig_setmethods__ = {}
    for _s in [Contactable]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, RpcClient, name, value)
    __swig_getmethods__ = {}
    for _s in [Contactable]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, RpcClient, name)
    __repr__ = _swig_repr
    def __init__(self): 
        """__init__(yarp::os::RpcClient self) -> RpcClient"""
        this = _yarp.new_RpcClient()
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _yarp.delete_RpcClient
    __del__ = lambda self : None;
    def addOutput(self, *args):
        """
        addOutput(RpcClient self, char const * name) -> bool
        addOutput(RpcClient self, char const * name, char const * carrier) -> bool
        addOutput(RpcClient self, Contact contact) -> bool
        """
        return _yarp.RpcClient_addOutput(self, *args)

    def close(self):
        """close(RpcClient self)"""
        return _yarp.RpcClient_close(self)

    def interrupt(self):
        """interrupt(RpcClient self)"""
        return _yarp.RpcClient_interrupt(self)

    def resume(self):
        """resume(RpcClient self)"""
        return _yarp.RpcClient_resume(self)

    def where(self):
        """where(RpcClient self) -> Contact"""
        return _yarp.RpcClient_where(self)

    def getName(self):
        """getName(RpcClient self) -> ConstString"""
        return _yarp.RpcClient_getName(self)

    def write(self, *args):
        """write(RpcClient self, PortWriter writer, PortReader reader) -> bool"""
        return _yarp.RpcClient_write(self, *args)

    def setEnvelope(self, *args):
        """setEnvelope(RpcClient self, PortWriter envelope) -> bool"""
        return _yarp.RpcClient_setEnvelope(self, *args)

    def getEnvelope(self, *args):
        """getEnvelope(RpcClient self, PortReader envelope) -> bool"""
        return _yarp.RpcClient_getEnvelope(self, *args)

    def getInputCount(self):
        """getInputCount(RpcClient self) -> int"""
        return _yarp.RpcClient_getInputCount(self)

    def getOutputCount(self):
        """getOutputCount(RpcClient self) -> int"""
        return _yarp.RpcClient_getOutputCount(self)

    def getReport(self, *args):
        """getReport(RpcClient self, PortReport reporter)"""
        return _yarp.RpcClient_getReport(self, *args)

    def setReporter(self, *args):
        """setReporter(RpcClient self, PortReport reporter)"""
        return _yarp.RpcClient_setReporter(self, *args)

    def isWriting(self):
        """isWriting(RpcClient self) -> bool"""
        return _yarp.RpcClient_isWriting(self)

    def setReader(self, *args):
        """setReader(RpcClient self, PortReader reader)"""
        return _yarp.RpcClient_setReader(self, *args)

RpcClient_swigregister = _yarp.RpcClient_swigregister
RpcClient_swigregister(RpcClient)

class TypedReaderProperty(_object):
    """Proxy of C++ yarp::os::TypedReader<(Property)> class"""
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, TypedReaderProperty, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, TypedReaderProperty, name)
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    def setStrict(self, strict=True):
        """
        setStrict(TypedReaderProperty self, bool strict=True)
        setStrict(TypedReaderProperty self)
        """
        return _yarp.TypedReaderProperty_setStrict(self, strict)

    def read(self, shouldWait=True):
        """
        read(TypedReaderProperty self, bool shouldWait=True) -> Property
        read(TypedReaderProperty self) -> Property
        """
        return _yarp.TypedReaderProperty_read(self, shouldWait)

    def interrupt(self):
        """interrupt(TypedReaderProperty self)"""
        return _yarp.TypedReaderProperty_interrupt(self)

    def lastRead(self):
        """lastRead(TypedReaderProperty self) -> Property"""
        return _yarp.TypedReaderProperty_lastRead(self)

    def isClosed(self):
        """isClosed(TypedReaderProperty self) -> bool"""
        return _yarp.TypedReaderProperty_isClosed(self)

    def useCallback(self, *args):
        """useCallback(TypedReaderProperty self, PropertyCallback callback)"""
        return _yarp.TypedReaderProperty_useCallback(self, *args)

    def disableCallback(self):
        """disableCallback(TypedReaderProperty self)"""
        return _yarp.TypedReaderProperty_disableCallback(self)

    def getPendingReads(self):
        """getPendingReads(TypedReaderProperty self) -> int"""
        return _yarp.TypedReaderProperty_getPendingReads(self)

    __swig_destroy__ = _yarp.delete_TypedReaderProperty
    __del__ = lambda self : None;
    def getName(self):
        """getName(TypedReaderProperty self) -> ConstString"""
        return _yarp.TypedReaderProperty_getName(self)

    def setReplier(self, *args):
        """setReplier(TypedReaderProperty self, PortReader reader)"""
        return _yarp.TypedReaderProperty_setReplier(self, *args)

    def acquire(self):
        """acquire(TypedReaderProperty self) -> void *"""
        return _yarp.TypedReaderProperty_acquire(self)

    def release(self, *args):
        """release(TypedReaderProperty self, void * handle)"""
        return _yarp.TypedReaderProperty_release(self, *args)

    def setTargetPeriod(self, *args):
        """setTargetPeriod(TypedReaderProperty self, double period)"""
        return _yarp.TypedReaderProperty_setTargetPeriod(self, *args)

TypedReaderProperty_swigregister = _yarp.TypedReaderProperty_swigregister
TypedReaderProperty_swigregister(TypedReaderProperty)

class PropertyCallback(_object):
    """Proxy of C++ yarp::os::TypedReaderCallback<(Property)> class"""
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, PropertyCallback, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, PropertyCallback, name)
    __repr__ = _swig_repr
    __swig_destroy__ = _yarp.delete_PropertyCallback
    __del__ = lambda self : None;
    def onRead(self, *args):
        """
        onRead(PropertyCallback self, Property datum)
        onRead(PropertyCallback self, Property datum, TypedReaderProperty reader)
        """
        return _yarp.PropertyCallback_onRead(self, *args)

    def __init__(self): 
        """__init__(yarp::os::TypedReaderCallback<(Property)> self) -> PropertyCallback"""
        if self.__class__ == PropertyCallback:
            _self = None
        else:
            _self = self
        this = _yarp.new_PropertyCallback(_self, )
        try: self.this.append(this)
        except: self.this = this
    def __disown__(self):
        self.this.disown()
        _yarp.disown_PropertyCallback(self)
        return weakref_proxy(self)
PropertyCallback_swigregister = _yarp.PropertyCallback_swigregister
PropertyCallback_swigregister(PropertyCallback)

class BufferedPortProperty(Contactable,TypedReaderProperty,PropertyCallback):
    """Proxy of C++ yarp::os::BufferedPort<(Property)> class"""
    __swig_setmethods__ = {}
    for _s in [Contactable,TypedReaderProperty,PropertyCallback]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, BufferedPortProperty, name, value)
    __swig_getmethods__ = {}
    for _s in [Contactable,TypedReaderProperty,PropertyCallback]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, BufferedPortProperty, name)
    __repr__ = _swig_repr
    def __init__(self): 
        """__init__(yarp::os::BufferedPort<(Property)> self) -> BufferedPortProperty"""
        this = _yarp.new_BufferedPortProperty()
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _yarp.delete_BufferedPortProperty
    __del__ = lambda self : None;
    def addOutput(self, *args):
        """
        addOutput(BufferedPortProperty self, char const * name) -> bool
        addOutput(BufferedPortProperty self, char const * name, char const * carrier) -> bool
        addOutput(BufferedPortProperty self, Contact contact) -> bool
        """
        return _yarp.BufferedPortProperty_addOutput(self, *args)

    def close(self):
        """close(BufferedPortProperty self)"""
        return _yarp.BufferedPortProperty_close(self)

    def interrupt(self):
        """interrupt(BufferedPortProperty self)"""
        return _yarp.BufferedPortProperty_interrupt(self)

    def resume(self):
        """resume(BufferedPortProperty self)"""
        return _yarp.BufferedPortProperty_resume(self)

    def getPendingReads(self):
        """getPendingReads(BufferedPortProperty self) -> int"""
        return _yarp.BufferedPortProperty_getPendingReads(self)

    def where(self):
        """where(BufferedPortProperty self) -> Contact"""
        return _yarp.BufferedPortProperty_where(self)

    def getName(self):
        """getName(BufferedPortProperty self) -> ConstString"""
        return _yarp.BufferedPortProperty_getName(self)

    def prepare(self):
        """prepare(BufferedPortProperty self) -> Property"""
        return _yarp.BufferedPortProperty_prepare(self)

    def unprepare(self):
        """unprepare(BufferedPortProperty self) -> bool"""
        return _yarp.BufferedPortProperty_unprepare(self)

    def write(self, forceStrict=False):
        """
        write(BufferedPortProperty self, bool forceStrict=False)
        write(BufferedPortProperty self)
        """
        return _yarp.BufferedPortProperty_write(self, forceStrict)

    def writeStrict(self):
        """writeStrict(BufferedPortProperty self)"""
        return _yarp.BufferedPortProperty_writeStrict(self)

    def setStrict(self, strict=True):
        """
        setStrict(BufferedPortProperty self, bool strict=True)
        setStrict(BufferedPortProperty self)
        """
        return _yarp.BufferedPortProperty_setStrict(self, strict)

    def read(self, shouldWait=True):
        """
        read(BufferedPortProperty self, bool shouldWait=True) -> Property
        read(BufferedPortProperty self) -> Property
        """
        return _yarp.BufferedPortProperty_read(self, shouldWait)

    def lastRead(self):
        """lastRead(BufferedPortProperty self) -> Property"""
        return _yarp.BufferedPortProperty_lastRead(self)

    def isClosed(self):
        """isClosed(BufferedPortProperty self) -> bool"""
        return _yarp.BufferedPortProperty_isClosed(self)

    def setReplier(self, *args):
        """setReplier(BufferedPortProperty self, PortReader reader)"""
        return _yarp.BufferedPortProperty_setReplier(self, *args)

    def setReader(self, *args):
        """setReader(BufferedPortProperty self, PortReader reader)"""
        return _yarp.BufferedPortProperty_setReader(self, *args)

    def onRead(self, *args):
        """onRead(BufferedPortProperty self, Property datum)"""
        return _yarp.BufferedPortProperty_onRead(self, *args)

    def useCallback(self, *args):
        """
        useCallback(BufferedPortProperty self, PropertyCallback callback)
        useCallback(BufferedPortProperty self)
        """
        return _yarp.BufferedPortProperty_useCallback(self, *args)

    def disableCallback(self):
        """disableCallback(BufferedPortProperty self)"""
        return _yarp.BufferedPortProperty_disableCallback(self)

    def setEnvelope(self, *args):
        """setEnvelope(BufferedPortProperty self, PortWriter envelope) -> bool"""
        return _yarp.BufferedPortProperty_setEnvelope(self, *args)

    def getEnvelope(self, *args):
        """getEnvelope(BufferedPortProperty self, PortReader envelope) -> bool"""
        return _yarp.BufferedPortProperty_getEnvelope(self, *args)

    def getInputCount(self):
        """getInputCount(BufferedPortProperty self) -> int"""
        return _yarp.BufferedPortProperty_getInputCount(self)

    def getOutputCount(self):
        """getOutputCount(BufferedPortProperty self) -> int"""
        return _yarp.BufferedPortProperty_getOutputCount(self)

    def isWriting(self):
        """isWriting(BufferedPortProperty self) -> bool"""
        return _yarp.BufferedPortProperty_isWriting(self)

    def getReport(self, *args):
        """getReport(BufferedPortProperty self, PortReport reporter)"""
        return _yarp.BufferedPortProperty_getReport(self, *args)

    def setReporter(self, *args):
        """setReporter(BufferedPortProperty self, PortReport reporter)"""
        return _yarp.BufferedPortProperty_setReporter(self, *args)

    def acquire(self):
        """acquire(BufferedPortProperty self) -> void *"""
        return _yarp.BufferedPortProperty_acquire(self)

    def release(self, *args):
        """release(BufferedPortProperty self, void * handle)"""
        return _yarp.BufferedPortProperty_release(self, *args)

    def setTargetPeriod(self, *args):
        """setTargetPeriod(BufferedPortProperty self, double period)"""
        return _yarp.BufferedPortProperty_setTargetPeriod(self, *args)

BufferedPortProperty_swigregister = _yarp.BufferedPortProperty_swigregister
BufferedPortProperty_swigregister(BufferedPortProperty)

class TypedReaderBottle(_object):
    """Proxy of C++ yarp::os::TypedReader<(Bottle)> class"""
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, TypedReaderBottle, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, TypedReaderBottle, name)
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    def setStrict(self, strict=True):
        """
        setStrict(TypedReaderBottle self, bool strict=True)
        setStrict(TypedReaderBottle self)
        """
        return _yarp.TypedReaderBottle_setStrict(self, strict)

    def read(self, shouldWait=True):
        """
        read(TypedReaderBottle self, bool shouldWait=True) -> Bottle
        read(TypedReaderBottle self) -> Bottle
        """
        return _yarp.TypedReaderBottle_read(self, shouldWait)

    def interrupt(self):
        """interrupt(TypedReaderBottle self)"""
        return _yarp.TypedReaderBottle_interrupt(self)

    def lastRead(self):
        """lastRead(TypedReaderBottle self) -> Bottle"""
        return _yarp.TypedReaderBottle_lastRead(self)

    def isClosed(self):
        """isClosed(TypedReaderBottle self) -> bool"""
        return _yarp.TypedReaderBottle_isClosed(self)

    def useCallback(self, *args):
        """useCallback(TypedReaderBottle self, BottleCallback callback)"""
        return _yarp.TypedReaderBottle_useCallback(self, *args)

    def disableCallback(self):
        """disableCallback(TypedReaderBottle self)"""
        return _yarp.TypedReaderBottle_disableCallback(self)

    def getPendingReads(self):
        """getPendingReads(TypedReaderBottle self) -> int"""
        return _yarp.TypedReaderBottle_getPendingReads(self)

    __swig_destroy__ = _yarp.delete_TypedReaderBottle
    __del__ = lambda self : None;
    def getName(self):
        """getName(TypedReaderBottle self) -> ConstString"""
        return _yarp.TypedReaderBottle_getName(self)

    def setReplier(self, *args):
        """setReplier(TypedReaderBottle self, PortReader reader)"""
        return _yarp.TypedReaderBottle_setReplier(self, *args)

    def acquire(self):
        """acquire(TypedReaderBottle self) -> void *"""
        return _yarp.TypedReaderBottle_acquire(self)

    def release(self, *args):
        """release(TypedReaderBottle self, void * handle)"""
        return _yarp.TypedReaderBottle_release(self, *args)

    def setTargetPeriod(self, *args):
        """setTargetPeriod(TypedReaderBottle self, double period)"""
        return _yarp.TypedReaderBottle_setTargetPeriod(self, *args)

TypedReaderBottle_swigregister = _yarp.TypedReaderBottle_swigregister
TypedReaderBottle_swigregister(TypedReaderBottle)

class BottleCallback(_object):
    """Proxy of C++ yarp::os::TypedReaderCallback<(Bottle)> class"""
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, BottleCallback, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, BottleCallback, name)
    __repr__ = _swig_repr
    __swig_destroy__ = _yarp.delete_BottleCallback
    __del__ = lambda self : None;
    def onRead(self, *args):
        """
        onRead(BottleCallback self, Bottle datum)
        onRead(BottleCallback self, Bottle datum, TypedReaderBottle reader)
        """
        return _yarp.BottleCallback_onRead(self, *args)

    def __init__(self): 
        """__init__(yarp::os::TypedReaderCallback<(Bottle)> self) -> BottleCallback"""
        if self.__class__ == BottleCallback:
            _self = None
        else:
            _self = self
        this = _yarp.new_BottleCallback(_self, )
        try: self.this.append(this)
        except: self.this = this
    def __disown__(self):
        self.this.disown()
        _yarp.disown_BottleCallback(self)
        return weakref_proxy(self)
BottleCallback_swigregister = _yarp.BottleCallback_swigregister
BottleCallback_swigregister(BottleCallback)

class BufferedPortBottle(Contactable,TypedReaderBottle,BottleCallback):
    """Proxy of C++ yarp::os::BufferedPort<(Bottle)> class"""
    __swig_setmethods__ = {}
    for _s in [Contactable,TypedReaderBottle,BottleCallback]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, BufferedPortBottle, name, value)
    __swig_getmethods__ = {}
    for _s in [Contactable,TypedReaderBottle,BottleCallback]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, BufferedPortBottle, name)
    __repr__ = _swig_repr
    def __init__(self): 
        """__init__(yarp::os::BufferedPort<(Bottle)> self) -> BufferedPortBottle"""
        this = _yarp.new_BufferedPortBottle()
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _yarp.delete_BufferedPortBottle
    __del__ = lambda self : None;
    def addOutput(self, *args):
        """
        addOutput(BufferedPortBottle self, char const * name) -> bool
        addOutput(BufferedPortBottle self, char const * name, char const * carrier) -> bool
        addOutput(BufferedPortBottle self, Contact contact) -> bool
        """
        return _yarp.BufferedPortBottle_addOutput(self, *args)

    def close(self):
        """close(BufferedPortBottle self)"""
        return _yarp.BufferedPortBottle_close(self)

    def interrupt(self):
        """interrupt(BufferedPortBottle self)"""
        return _yarp.BufferedPortBottle_interrupt(self)

    def resume(self):
        """resume(BufferedPortBottle self)"""
        return _yarp.BufferedPortBottle_resume(self)

    def getPendingReads(self):
        """getPendingReads(BufferedPortBottle self) -> int"""
        return _yarp.BufferedPortBottle_getPendingReads(self)

    def where(self):
        """where(BufferedPortBottle self) -> Contact"""
        return _yarp.BufferedPortBottle_where(self)

    def getName(self):
        """getName(BufferedPortBottle self) -> ConstString"""
        return _yarp.BufferedPortBottle_getName(self)

    def prepare(self):
        """prepare(BufferedPortBottle self) -> Bottle"""
        return _yarp.BufferedPortBottle_prepare(self)

    def unprepare(self):
        """unprepare(BufferedPortBottle self) -> bool"""
        return _yarp.BufferedPortBottle_unprepare(self)

    def write(self, forceStrict=False):
        """
        write(BufferedPortBottle self, bool forceStrict=False)
        write(BufferedPortBottle self)
        """
        return _yarp.BufferedPortBottle_write(self, forceStrict)

    def writeStrict(self):
        """writeStrict(BufferedPortBottle self)"""
        return _yarp.BufferedPortBottle_writeStrict(self)

    def setStrict(self, strict=True):
        """
        setStrict(BufferedPortBottle self, bool strict=True)
        setStrict(BufferedPortBottle self)
        """
        return _yarp.BufferedPortBottle_setStrict(self, strict)

    def read(self, shouldWait=True):
        """
        read(BufferedPortBottle self, bool shouldWait=True) -> Bottle
        read(BufferedPortBottle self) -> Bottle
        """
        return _yarp.BufferedPortBottle_read(self, shouldWait)

    def lastRead(self):
        """lastRead(BufferedPortBottle self) -> Bottle"""
        return _yarp.BufferedPortBottle_lastRead(self)

    def isClosed(self):
        """isClosed(BufferedPortBottle self) -> bool"""
        return _yarp.BufferedPortBottle_isClosed(self)

    def setReplier(self, *args):
        """setReplier(BufferedPortBottle self, PortReader reader)"""
        return _yarp.BufferedPortBottle_setReplier(self, *args)

    def setReader(self, *args):
        """setReader(BufferedPortBottle self, PortReader reader)"""
        return _yarp.BufferedPortBottle_setReader(self, *args)

    def onRead(self, *args):
        """onRead(BufferedPortBottle self, Bottle datum)"""
        return _yarp.BufferedPortBottle_onRead(self, *args)

    def useCallback(self, *args):
        """
        useCallback(BufferedPortBottle self, BottleCallback callback)
        useCallback(BufferedPortBottle self)
        """
        return _yarp.BufferedPortBottle_useCallback(self, *args)

    def disableCallback(self):
        """disableCallback(BufferedPortBottle self)"""
        return _yarp.BufferedPortBottle_disableCallback(self)

    def setEnvelope(self, *args):
        """setEnvelope(BufferedPortBottle self, PortWriter envelope) -> bool"""
        return _yarp.BufferedPortBottle_setEnvelope(self, *args)

    def getEnvelope(self, *args):
        """getEnvelope(BufferedPortBottle self, PortReader envelope) -> bool"""
        return _yarp.BufferedPortBottle_getEnvelope(self, *args)

    def getInputCount(self):
        """getInputCount(BufferedPortBottle self) -> int"""
        return _yarp.BufferedPortBottle_getInputCount(self)

    def getOutputCount(self):
        """getOutputCount(BufferedPortBottle self) -> int"""
        return _yarp.BufferedPortBottle_getOutputCount(self)

    def isWriting(self):
        """isWriting(BufferedPortBottle self) -> bool"""
        return _yarp.BufferedPortBottle_isWriting(self)

    def getReport(self, *args):
        """getReport(BufferedPortBottle self, PortReport reporter)"""
        return _yarp.BufferedPortBottle_getReport(self, *args)

    def setReporter(self, *args):
        """setReporter(BufferedPortBottle self, PortReport reporter)"""
        return _yarp.BufferedPortBottle_setReporter(self, *args)

    def acquire(self):
        """acquire(BufferedPortBottle self) -> void *"""
        return _yarp.BufferedPortBottle_acquire(self)

    def release(self, *args):
        """release(BufferedPortBottle self, void * handle)"""
        return _yarp.BufferedPortBottle_release(self, *args)

    def setTargetPeriod(self, *args):
        """setTargetPeriod(BufferedPortBottle self, double period)"""
        return _yarp.BufferedPortBottle_setTargetPeriod(self, *args)

BufferedPortBottle_swigregister = _yarp.BufferedPortBottle_swigregister
BufferedPortBottle_swigregister(BufferedPortBottle)


def PAD_BYTES(*args):
  """PAD_BYTES(int len, int pad) -> int"""
  return _yarp.PAD_BYTES(*args)
class Image(Portable):
    """Proxy of C++ yarp::sig::Image class"""
    __swig_setmethods__ = {}
    for _s in [Portable]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, Image, name, value)
    __swig_getmethods__ = {}
    for _s in [Portable]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, Image, name)
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(yarp::sig::Image self) -> Image
        __init__(yarp::sig::Image self, Image alt) -> Image
        """
        this = _yarp.new_Image(*args)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _yarp.delete_Image
    __del__ = lambda self : None;
    def copy(self, *args):
        """
        copy(Image self, Image alt) -> bool
        copy(Image self, Image alt, int w, int h) -> bool
        """
        return _yarp.Image_copy(self, *args)

    def width(self):
        """width(Image self) -> int"""
        return _yarp.Image_width(self)

    def height(self):
        """height(Image self) -> int"""
        return _yarp.Image_height(self)

    def getPixelSize(self):
        """getPixelSize(Image self) -> int"""
        return _yarp.Image_getPixelSize(self)

    def getPixelCode(self):
        """getPixelCode(Image self) -> int"""
        return _yarp.Image_getPixelCode(self)

    def getRowSize(self):
        """getRowSize(Image self) -> int"""
        return _yarp.Image_getRowSize(self)

    def getQuantum(self):
        """getQuantum(Image self) -> int"""
        return _yarp.Image_getQuantum(self)

    def getPadding(self):
        """getPadding(Image self) -> int"""
        return _yarp.Image_getPadding(self)

    def getRow(self, *args):
        """getRow(Image self, int r) -> unsigned char *"""
        return _yarp.Image_getRow(self, *args)

    def getPixelAddress(self, *args):
        """getPixelAddress(Image self, int x, int y) -> unsigned char *"""
        return _yarp.Image_getPixelAddress(self, *args)

    def isPixel(self, *args):
        """isPixel(Image self, int x, int y) -> bool"""
        return _yarp.Image_isPixel(self, *args)

    def zero(self):
        """zero(Image self)"""
        return _yarp.Image_zero(self)

    def resize(self, *args):
        """
        resize(Image self, int imgWidth, int imgHeight)
        resize(Image self, Image alt)
        """
        return _yarp.Image_resize(self, *args)

    def getRawImage(self):
        """getRawImage(Image self) -> unsigned char *"""
        return _yarp.Image_getRawImage(self)

    def getRawImageSize(self):
        """getRawImageSize(Image self) -> int"""
        return _yarp.Image_getRawImageSize(self)

    def getIplImage(self):
        """getIplImage(Image self) -> void *"""
        return _yarp.Image_getIplImage(self)

    def wrapIplImage(self, *args):
        """wrapIplImage(Image self, void * iplImage)"""
        return _yarp.Image_wrapIplImage(self, *args)

    def read(self, *args):
        """read(Image self, ConnectionReader connection) -> bool"""
        return _yarp.Image_read(self, *args)

    def write(self, *args):
        """write(Image self, ConnectionWriter connection) -> bool"""
        return _yarp.Image_write(self, *args)

    def setQuantum(self, *args):
        """setQuantum(Image self, int imgQuantum)"""
        return _yarp.Image_setQuantum(self, *args)

    def topIsLowIndex(self):
        """topIsLowIndex(Image self) -> bool"""
        return _yarp.Image_topIsLowIndex(self)

    def setTopIsLowIndex(self, *args):
        """setTopIsLowIndex(Image self, bool flag)"""
        return _yarp.Image_setTopIsLowIndex(self, *args)

    def getRowArray(self):
        """getRowArray(Image self) -> char **"""
        return _yarp.Image_getRowArray(self)

    def setExternal(self, *args):
        """
        setExternal(Image self, void * data, int imgWidth, int imgHeight)
        setExternal(Image self, PyObject * mem, int w, int h)
        """
        return _yarp.Image_setExternal(self, *args)

    def setExternal2(self, *args):
        """setExternal2(Image self, PyObject * mem, int w, int h)"""
        return _yarp.Image_setExternal2(self, *args)

    def tostring(self):
        """tostring(Image self) -> std::string"""
        return _yarp.Image_tostring(self)

    def fromstring(self, *args):
        """fromstring(Image self, std::string const & str, int w, int h)"""
        return _yarp.Image_fromstring(self, *args)

Image_swigregister = _yarp.Image_swigregister
Image_swigregister(Image)

class FlexImage(Image):
    """Proxy of C++ yarp::sig::FlexImage class"""
    __swig_setmethods__ = {}
    for _s in [Image]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, FlexImage, name, value)
    __swig_getmethods__ = {}
    for _s in [Image]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, FlexImage, name)
    __repr__ = _swig_repr
    def setPixelCode(self, *args):
        """setPixelCode(FlexImage self, int imgPixelCode)"""
        return _yarp.FlexImage_setPixelCode(self, *args)

    def setPixelSize(self, *args):
        """setPixelSize(FlexImage self, int imgPixelSize)"""
        return _yarp.FlexImage_setPixelSize(self, *args)

    def setQuantum(self, *args):
        """setQuantum(FlexImage self, int imgQuantum)"""
        return _yarp.FlexImage_setQuantum(self, *args)

    def __init__(self): 
        """__init__(yarp::sig::FlexImage self) -> FlexImage"""
        this = _yarp.new_FlexImage()
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _yarp.delete_FlexImage
    __del__ = lambda self : None;
FlexImage_swigregister = _yarp.FlexImage_swigregister
FlexImage_swigregister(FlexImage)

VOCAB_PIXEL_INVALID = _yarp.VOCAB_PIXEL_INVALID
VOCAB_PIXEL_MONO = _yarp.VOCAB_PIXEL_MONO
VOCAB_PIXEL_MONO16 = _yarp.VOCAB_PIXEL_MONO16
VOCAB_PIXEL_RGB = _yarp.VOCAB_PIXEL_RGB
VOCAB_PIXEL_RGBA = _yarp.VOCAB_PIXEL_RGBA
VOCAB_PIXEL_BGRA = _yarp.VOCAB_PIXEL_BGRA
VOCAB_PIXEL_INT = _yarp.VOCAB_PIXEL_INT
VOCAB_PIXEL_HSV = _yarp.VOCAB_PIXEL_HSV
VOCAB_PIXEL_BGR = _yarp.VOCAB_PIXEL_BGR
VOCAB_PIXEL_MONO_SIGNED = _yarp.VOCAB_PIXEL_MONO_SIGNED
VOCAB_PIXEL_RGB_SIGNED = _yarp.VOCAB_PIXEL_RGB_SIGNED
VOCAB_PIXEL_RGB_INT = _yarp.VOCAB_PIXEL_RGB_INT
VOCAB_PIXEL_MONO_FLOAT = _yarp.VOCAB_PIXEL_MONO_FLOAT
VOCAB_PIXEL_RGB_FLOAT = _yarp.VOCAB_PIXEL_RGB_FLOAT
VOCAB_PIXEL_HSV_FLOAT = _yarp.VOCAB_PIXEL_HSV_FLOAT
class PixelRgb(_object):
    """Proxy of C++ yarp::sig::PixelRgb class"""
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, PixelRgb, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, PixelRgb, name)
    __repr__ = _swig_repr
    __swig_setmethods__["r"] = _yarp.PixelRgb_r_set
    __swig_getmethods__["r"] = _yarp.PixelRgb_r_get
    if _newclass:r = _swig_property(_yarp.PixelRgb_r_get, _yarp.PixelRgb_r_set)
    __swig_setmethods__["g"] = _yarp.PixelRgb_g_set
    __swig_getmethods__["g"] = _yarp.PixelRgb_g_get
    if _newclass:g = _swig_property(_yarp.PixelRgb_g_get, _yarp.PixelRgb_g_set)
    __swig_setmethods__["b"] = _yarp.PixelRgb_b_set
    __swig_getmethods__["b"] = _yarp.PixelRgb_b_get
    if _newclass:b = _swig_property(_yarp.PixelRgb_b_get, _yarp.PixelRgb_b_set)
    def __init__(self, *args): 
        """
        __init__(yarp::sig::PixelRgb self) -> PixelRgb
        __init__(yarp::sig::PixelRgb self, unsigned char n_r, unsigned char n_g, unsigned char n_b) -> PixelRgb
        """
        this = _yarp.new_PixelRgb(*args)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _yarp.delete_PixelRgb
    __del__ = lambda self : None;
PixelRgb_swigregister = _yarp.PixelRgb_swigregister
PixelRgb_swigregister(PixelRgb)

class PixelRgba(_object):
    """Proxy of C++ yarp::sig::PixelRgba class"""
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, PixelRgba, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, PixelRgba, name)
    __repr__ = _swig_repr
    __swig_setmethods__["r"] = _yarp.PixelRgba_r_set
    __swig_getmethods__["r"] = _yarp.PixelRgba_r_get
    if _newclass:r = _swig_property(_yarp.PixelRgba_r_get, _yarp.PixelRgba_r_set)
    __swig_setmethods__["g"] = _yarp.PixelRgba_g_set
    __swig_getmethods__["g"] = _yarp.PixelRgba_g_get
    if _newclass:g = _swig_property(_yarp.PixelRgba_g_get, _yarp.PixelRgba_g_set)
    __swig_setmethods__["b"] = _yarp.PixelRgba_b_set
    __swig_getmethods__["b"] = _yarp.PixelRgba_b_get
    if _newclass:b = _swig_property(_yarp.PixelRgba_b_get, _yarp.PixelRgba_b_set)
    __swig_setmethods__["a"] = _yarp.PixelRgba_a_set
    __swig_getmethods__["a"] = _yarp.PixelRgba_a_get
    if _newclass:a = _swig_property(_yarp.PixelRgba_a_get, _yarp.PixelRgba_a_set)
    def __init__(self, *args): 
        """
        __init__(yarp::sig::PixelRgba self) -> PixelRgba
        __init__(yarp::sig::PixelRgba self, unsigned char n_r, unsigned char n_g, unsigned char n_b, unsigned char n_a) -> PixelRgba
        """
        this = _yarp.new_PixelRgba(*args)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _yarp.delete_PixelRgba
    __del__ = lambda self : None;
PixelRgba_swigregister = _yarp.PixelRgba_swigregister
PixelRgba_swigregister(PixelRgba)

class PixelBgra(_object):
    """Proxy of C++ yarp::sig::PixelBgra class"""
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, PixelBgra, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, PixelBgra, name)
    __repr__ = _swig_repr
    __swig_setmethods__["b"] = _yarp.PixelBgra_b_set
    __swig_getmethods__["b"] = _yarp.PixelBgra_b_get
    if _newclass:b = _swig_property(_yarp.PixelBgra_b_get, _yarp.PixelBgra_b_set)
    __swig_setmethods__["g"] = _yarp.PixelBgra_g_set
    __swig_getmethods__["g"] = _yarp.PixelBgra_g_get
    if _newclass:g = _swig_property(_yarp.PixelBgra_g_get, _yarp.PixelBgra_g_set)
    __swig_setmethods__["r"] = _yarp.PixelBgra_r_set
    __swig_getmethods__["r"] = _yarp.PixelBgra_r_get
    if _newclass:r = _swig_property(_yarp.PixelBgra_r_get, _yarp.PixelBgra_r_set)
    __swig_setmethods__["a"] = _yarp.PixelBgra_a_set
    __swig_getmethods__["a"] = _yarp.PixelBgra_a_get
    if _newclass:a = _swig_property(_yarp.PixelBgra_a_get, _yarp.PixelBgra_a_set)
    def __init__(self, *args): 
        """
        __init__(yarp::sig::PixelBgra self) -> PixelBgra
        __init__(yarp::sig::PixelBgra self, unsigned char n_r, unsigned char n_g, unsigned char n_b, unsigned char n_a) -> PixelBgra
        """
        this = _yarp.new_PixelBgra(*args)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _yarp.delete_PixelBgra
    __del__ = lambda self : None;
PixelBgra_swigregister = _yarp.PixelBgra_swigregister
PixelBgra_swigregister(PixelBgra)

class PixelBgr(_object):
    """Proxy of C++ yarp::sig::PixelBgr class"""
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, PixelBgr, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, PixelBgr, name)
    __repr__ = _swig_repr
    __swig_setmethods__["b"] = _yarp.PixelBgr_b_set
    __swig_getmethods__["b"] = _yarp.PixelBgr_b_get
    if _newclass:b = _swig_property(_yarp.PixelBgr_b_get, _yarp.PixelBgr_b_set)
    __swig_setmethods__["g"] = _yarp.PixelBgr_g_set
    __swig_getmethods__["g"] = _yarp.PixelBgr_g_get
    if _newclass:g = _swig_property(_yarp.PixelBgr_g_get, _yarp.PixelBgr_g_set)
    __swig_setmethods__["r"] = _yarp.PixelBgr_r_set
    __swig_getmethods__["r"] = _yarp.PixelBgr_r_get
    if _newclass:r = _swig_property(_yarp.PixelBgr_r_get, _yarp.PixelBgr_r_set)
    def __init__(self, *args): 
        """
        __init__(yarp::sig::PixelBgr self) -> PixelBgr
        __init__(yarp::sig::PixelBgr self, unsigned char n_r, unsigned char n_g, unsigned char n_b) -> PixelBgr
        """
        this = _yarp.new_PixelBgr(*args)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _yarp.delete_PixelBgr
    __del__ = lambda self : None;
PixelBgr_swigregister = _yarp.PixelBgr_swigregister
PixelBgr_swigregister(PixelBgr)

class PixelHsv(_object):
    """Proxy of C++ yarp::sig::PixelHsv class"""
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, PixelHsv, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, PixelHsv, name)
    __repr__ = _swig_repr
    __swig_setmethods__["h"] = _yarp.PixelHsv_h_set
    __swig_getmethods__["h"] = _yarp.PixelHsv_h_get
    if _newclass:h = _swig_property(_yarp.PixelHsv_h_get, _yarp.PixelHsv_h_set)
    __swig_setmethods__["s"] = _yarp.PixelHsv_s_set
    __swig_getmethods__["s"] = _yarp.PixelHsv_s_get
    if _newclass:s = _swig_property(_yarp.PixelHsv_s_get, _yarp.PixelHsv_s_set)
    __swig_setmethods__["v"] = _yarp.PixelHsv_v_set
    __swig_getmethods__["v"] = _yarp.PixelHsv_v_get
    if _newclass:v = _swig_property(_yarp.PixelHsv_v_get, _yarp.PixelHsv_v_set)
    def __init__(self): 
        """__init__(yarp::sig::PixelHsv self) -> PixelHsv"""
        this = _yarp.new_PixelHsv()
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _yarp.delete_PixelHsv
    __del__ = lambda self : None;
PixelHsv_swigregister = _yarp.PixelHsv_swigregister
PixelHsv_swigregister(PixelHsv)

class PixelRgbSigned(_object):
    """Proxy of C++ yarp::sig::PixelRgbSigned class"""
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, PixelRgbSigned, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, PixelRgbSigned, name)
    __repr__ = _swig_repr
    __swig_setmethods__["r"] = _yarp.PixelRgbSigned_r_set
    __swig_getmethods__["r"] = _yarp.PixelRgbSigned_r_get
    if _newclass:r = _swig_property(_yarp.PixelRgbSigned_r_get, _yarp.PixelRgbSigned_r_set)
    __swig_setmethods__["g"] = _yarp.PixelRgbSigned_g_set
    __swig_getmethods__["g"] = _yarp.PixelRgbSigned_g_get
    if _newclass:g = _swig_property(_yarp.PixelRgbSigned_g_get, _yarp.PixelRgbSigned_g_set)
    __swig_setmethods__["b"] = _yarp.PixelRgbSigned_b_set
    __swig_getmethods__["b"] = _yarp.PixelRgbSigned_b_get
    if _newclass:b = _swig_property(_yarp.PixelRgbSigned_b_get, _yarp.PixelRgbSigned_b_set)
    def __init__(self): 
        """__init__(yarp::sig::PixelRgbSigned self) -> PixelRgbSigned"""
        this = _yarp.new_PixelRgbSigned()
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _yarp.delete_PixelRgbSigned
    __del__ = lambda self : None;
PixelRgbSigned_swigregister = _yarp.PixelRgbSigned_swigregister
PixelRgbSigned_swigregister(PixelRgbSigned)

class PixelRgbFloat(_object):
    """Proxy of C++ yarp::sig::PixelRgbFloat class"""
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, PixelRgbFloat, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, PixelRgbFloat, name)
    __repr__ = _swig_repr
    __swig_setmethods__["r"] = _yarp.PixelRgbFloat_r_set
    __swig_getmethods__["r"] = _yarp.PixelRgbFloat_r_get
    if _newclass:r = _swig_property(_yarp.PixelRgbFloat_r_get, _yarp.PixelRgbFloat_r_set)
    __swig_setmethods__["g"] = _yarp.PixelRgbFloat_g_set
    __swig_getmethods__["g"] = _yarp.PixelRgbFloat_g_get
    if _newclass:g = _swig_property(_yarp.PixelRgbFloat_g_get, _yarp.PixelRgbFloat_g_set)
    __swig_setmethods__["b"] = _yarp.PixelRgbFloat_b_set
    __swig_getmethods__["b"] = _yarp.PixelRgbFloat_b_get
    if _newclass:b = _swig_property(_yarp.PixelRgbFloat_b_get, _yarp.PixelRgbFloat_b_set)
    def __init__(self, *args): 
        """
        __init__(yarp::sig::PixelRgbFloat self) -> PixelRgbFloat
        __init__(yarp::sig::PixelRgbFloat self, float n_r, float n_g, float n_b) -> PixelRgbFloat
        """
        this = _yarp.new_PixelRgbFloat(*args)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _yarp.delete_PixelRgbFloat
    __del__ = lambda self : None;
PixelRgbFloat_swigregister = _yarp.PixelRgbFloat_swigregister
PixelRgbFloat_swigregister(PixelRgbFloat)

class PixelRgbInt(_object):
    """Proxy of C++ yarp::sig::PixelRgbInt class"""
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, PixelRgbInt, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, PixelRgbInt, name)
    __repr__ = _swig_repr
    __swig_setmethods__["r"] = _yarp.PixelRgbInt_r_set
    __swig_getmethods__["r"] = _yarp.PixelRgbInt_r_get
    if _newclass:r = _swig_property(_yarp.PixelRgbInt_r_get, _yarp.PixelRgbInt_r_set)
    __swig_setmethods__["g"] = _yarp.PixelRgbInt_g_set
    __swig_getmethods__["g"] = _yarp.PixelRgbInt_g_get
    if _newclass:g = _swig_property(_yarp.PixelRgbInt_g_get, _yarp.PixelRgbInt_g_set)
    __swig_setmethods__["b"] = _yarp.PixelRgbInt_b_set
    __swig_getmethods__["b"] = _yarp.PixelRgbInt_b_get
    if _newclass:b = _swig_property(_yarp.PixelRgbInt_b_get, _yarp.PixelRgbInt_b_set)
    def __init__(self, *args): 
        """
        __init__(yarp::sig::PixelRgbInt self) -> PixelRgbInt
        __init__(yarp::sig::PixelRgbInt self, int n_r, int n_g, int n_b) -> PixelRgbInt
        """
        this = _yarp.new_PixelRgbInt(*args)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _yarp.delete_PixelRgbInt
    __del__ = lambda self : None;
PixelRgbInt_swigregister = _yarp.PixelRgbInt_swigregister
PixelRgbInt_swigregister(PixelRgbInt)

class PixelHsvFloat(_object):
    """Proxy of C++ yarp::sig::PixelHsvFloat class"""
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, PixelHsvFloat, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, PixelHsvFloat, name)
    __repr__ = _swig_repr
    __swig_setmethods__["h"] = _yarp.PixelHsvFloat_h_set
    __swig_getmethods__["h"] = _yarp.PixelHsvFloat_h_get
    if _newclass:h = _swig_property(_yarp.PixelHsvFloat_h_get, _yarp.PixelHsvFloat_h_set)
    __swig_setmethods__["s"] = _yarp.PixelHsvFloat_s_set
    __swig_getmethods__["s"] = _yarp.PixelHsvFloat_s_get
    if _newclass:s = _swig_property(_yarp.PixelHsvFloat_s_get, _yarp.PixelHsvFloat_s_set)
    __swig_setmethods__["v"] = _yarp.PixelHsvFloat_v_set
    __swig_getmethods__["v"] = _yarp.PixelHsvFloat_v_get
    if _newclass:v = _swig_property(_yarp.PixelHsvFloat_v_get, _yarp.PixelHsvFloat_v_set)
    def __init__(self): 
        """__init__(yarp::sig::PixelHsvFloat self) -> PixelHsvFloat"""
        this = _yarp.new_PixelHsvFloat()
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _yarp.delete_PixelHsvFloat
    __del__ = lambda self : None;
PixelHsvFloat_swigregister = _yarp.PixelHsvFloat_swigregister
PixelHsvFloat_swigregister(PixelHsvFloat)

FORMAT_NULL = _yarp.FORMAT_NULL
FORMAT_ANY = _yarp.FORMAT_ANY
FORMAT_PGM = _yarp.FORMAT_PGM
FORMAT_PPM = _yarp.FORMAT_PPM
FORMAT_NUMERIC = _yarp.FORMAT_NUMERIC

def read(*args):
  """
    read(ImageRgb dest, char const * src) -> bool
    read(yarp::sig::ImageOf< yarp::sig::PixelBgr > & dest, char const * src) -> bool
    read(ImageRgba dest, char const * src) -> bool
    read(ImageMono dest, char const * src) -> bool
    read(ImageFloat dest, char const * src) -> bool
    """
  return _yarp.read(*args)

def write(*args):
  """
    write(ImageRgb src, char const * dest) -> bool
    write(yarp::sig::ImageOf< yarp::sig::PixelBgr > const & src, char const * dest) -> bool
    write(ImageRgba src, char const * dest) -> bool
    write(ImageMono src, char const * dest) -> bool
    write(ImageFloat src, char const * dest) -> bool
    write(Image src, char const * dest) -> bool
    """
  return _yarp.write(*args)
class Sound(Portable):
    """Proxy of C++ yarp::sig::Sound class"""
    __swig_setmethods__ = {}
    for _s in [Portable]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, Sound, name, value)
    __swig_getmethods__ = {}
    for _s in [Portable]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, Sound, name)
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(yarp::sig::Sound self, int bytesPerSample=2) -> Sound
        __init__(yarp::sig::Sound self) -> Sound
        __init__(yarp::sig::Sound self, Sound alt) -> Sound
        """
        this = _yarp.new_Sound(*args)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _yarp.delete_Sound
    __del__ = lambda self : None;
    def resize(self, *args):
        """
        resize(Sound self, int samples, int channels=1)
        resize(Sound self, int samples)
        """
        return _yarp.Sound_resize(self, *args)

    def get(self, *args):
        """
        get(Sound self, int sample, int channel=0) -> int
        get(Sound self, int sample) -> int
        """
        return _yarp.Sound_get(self, *args)

    def set(self, *args):
        """
        set(Sound self, int value, int sample, int channel=0)
        set(Sound self, int value, int sample)
        """
        return _yarp.Sound_set(self, *args)

    def getSafe(self, *args):
        """
        getSafe(Sound self, int sample, int channel=0) -> int
        getSafe(Sound self, int sample) -> int
        """
        return _yarp.Sound_getSafe(self, *args)

    def setSafe(self, *args):
        """
        setSafe(Sound self, int value, int sample, int channel=0)
        setSafe(Sound self, int value, int sample)
        """
        return _yarp.Sound_setSafe(self, *args)

    def isSample(self, *args):
        """
        isSample(Sound self, int sample, int channel=0) -> bool
        isSample(Sound self, int sample) -> bool
        """
        return _yarp.Sound_isSample(self, *args)

    def getFrequency(self):
        """getFrequency(Sound self) -> int"""
        return _yarp.Sound_getFrequency(self)

    def setFrequency(self, *args):
        """setFrequency(Sound self, int freq)"""
        return _yarp.Sound_setFrequency(self, *args)

    def getBytesPerSample(self):
        """getBytesPerSample(Sound self) -> int"""
        return _yarp.Sound_getBytesPerSample(self)

    def getSamples(self):
        """getSamples(Sound self) -> int"""
        return _yarp.Sound_getSamples(self)

    def getChannels(self):
        """getChannels(Sound self) -> int"""
        return _yarp.Sound_getChannels(self)

    def read(self, *args):
        """read(Sound self, ConnectionReader connection) -> bool"""
        return _yarp.Sound_read(self, *args)

    def write(self, *args):
        """write(Sound self, ConnectionWriter connection) -> bool"""
        return _yarp.Sound_write(self, *args)

    def getRawData(self):
        """getRawData(Sound self) -> unsigned char *"""
        return _yarp.Sound_getRawData(self)

    def getRawDataSize(self):
        """getRawDataSize(Sound self) -> int"""
        return _yarp.Sound_getRawDataSize(self)

Sound_swigregister = _yarp.Sound_swigregister
Sound_swigregister(Sound)

class VectorBase(Portable):
    """Proxy of C++ yarp::sig::VectorBase class"""
    __swig_setmethods__ = {}
    for _s in [Portable]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, VectorBase, name, value)
    __swig_getmethods__ = {}
    for _s in [Portable]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, VectorBase, name)
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    def getElementSize(self):
        """getElementSize(VectorBase self) -> int"""
        return _yarp.VectorBase_getElementSize(self)

    def getListSize(self):
        """getListSize(VectorBase self) -> size_t"""
        return _yarp.VectorBase_getListSize(self)

    def getMemoryBlock(self):
        """getMemoryBlock(VectorBase self) -> char const *"""
        return _yarp.VectorBase_getMemoryBlock(self)

    def resize(self, *args):
        """resize(VectorBase self, size_t size)"""
        return _yarp.VectorBase_resize(self, *args)

    def read(self, *args):
        """read(VectorBase self, ConnectionReader connection) -> bool"""
        return _yarp.VectorBase_read(self, *args)

    def write(self, *args):
        """write(VectorBase self, ConnectionWriter connection) -> bool"""
        return _yarp.VectorBase_write(self, *args)

    __swig_destroy__ = _yarp.delete_VectorBase
    __del__ = lambda self : None;
VectorBase_swigregister = _yarp.VectorBase_swigregister
VectorBase_swigregister(VectorBase)

class Vector(Portable):
    """Proxy of C++ yarp::sig::Vector class"""
    __swig_setmethods__ = {}
    for _s in [Portable]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, Vector, name, value)
    __swig_getmethods__ = {}
    for _s in [Portable]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, Vector, name)
    __repr__ = _swig_repr
    __swig_destroy__ = _yarp.delete_Vector
    __del__ = lambda self : None;
    def __init__(self, *args): 
        """
        __init__(yarp::sig::Vector self) -> Vector
        __init__(yarp::sig::Vector self, size_t s) -> Vector
        __init__(yarp::sig::Vector self, size_t s, double const & _def) -> Vector
        __init__(yarp::sig::Vector self, size_t s, double const * p) -> Vector
        __init__(yarp::sig::Vector self, Vector r) -> Vector
        """
        this = _yarp.new_Vector(*args)
        try: self.this.append(this)
        except: self.this = this
    def resize(self, *args):
        """
        resize(Vector self, size_t s)
        resize(Vector self, size_t size, double const & _def)
        """
        return _yarp.Vector_resize(self, *args)

    def size(self, *args):
        """
        size(Vector self, size_t s)
        size(Vector self) -> size_t
        """
        return _yarp.Vector_size(self, *args)

    def length(self):
        """length(Vector self) -> size_t"""
        return _yarp.Vector_length(self)

    def zero(self):
        """zero(Vector self)"""
        return _yarp.Vector_zero(self)

    def toString(self, *args):
        """
        toString(Vector self, int precision=-1, int width=-1) -> ConstString
        toString(Vector self, int precision=-1) -> ConstString
        """
        return _yarp.Vector_toString(self, *args)

    def toString_c(self, *args):
        """toString_c(Vector self) -> ConstString"""
        return _yarp.Vector_toString_c(self, *args)

    def subVector(self, *args):
        """subVector(Vector self, unsigned int first, unsigned int last) -> Vector"""
        return _yarp.Vector_subVector(self, *args)

    def setSubvector(self, *args):
        """setSubvector(Vector self, int position, Vector v) -> bool"""
        return _yarp.Vector_setSubvector(self, *args)

    def data(self, *args):
        """
        data(Vector self) -> double
        data(Vector self) -> double const *
        """
        return _yarp.Vector_data(self, *args)

    def isEqual(self, *args):
        """isEqual(Vector self, Vector r) -> bool"""
        return _yarp.Vector_isEqual(self, *args)

    def push_back(self, *args):
        """push_back(Vector self, double const & elem)"""
        return _yarp.Vector_push_back(self, *args)

    def pop_back(self):
        """pop_back(Vector self)"""
        return _yarp.Vector_pop_back(self)

    def getGslVector(self, *args):
        """
        getGslVector(Vector self)
        getGslVector(Vector self) -> void const *
        """
        return _yarp.Vector_getGslVector(self, *args)

    def access(self, *args):
        """
        access(Vector self, size_t i) -> double
        access(Vector self, size_t i) -> double const &
        """
        return _yarp.Vector_access(self, *args)

    def clear(self):
        """clear(Vector self)"""
        return _yarp.Vector_clear(self)

    def read(self, *args):
        """read(Vector self, ConnectionReader connection) -> bool"""
        return _yarp.Vector_read(self, *args)

    def write(self, *args):
        """write(Vector self, ConnectionWriter connection) -> bool"""
        return _yarp.Vector_write(self, *args)

    def get(self, *args):
        """get(Vector self, int j) -> double"""
        return _yarp.Vector_get(self, *args)

    def set(self, *args):
        """set(Vector self, int j, double v)"""
        return _yarp.Vector_set(self, *args)

    def __setitem__(self, *args):
        """__setitem__(Vector self, int key, double value)"""
        return _yarp.Vector___setitem__(self, *args)

    def __getitem__(self, *args):
        """__getitem__(Vector self, int key) -> double"""
        return _yarp.Vector___getitem__(self, *args)

    def __len__(self):
        """__len__(Vector self) -> double"""
        return _yarp.Vector___len__(self)

Vector_swigregister = _yarp.Vector_swigregister
Vector_swigregister(Vector)

class IConfig(_object):
    """Proxy of C++ yarp::os::IConfig class"""
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, IConfig, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, IConfig, name)
    __repr__ = _swig_repr
    __swig_destroy__ = _yarp.delete_IConfig
    __del__ = lambda self : None;
    def open(self, *args):
        """open(IConfig self, Searchable config) -> bool"""
        return _yarp.IConfig_open(self, *args)

    def close(self):
        """close(IConfig self) -> bool"""
        return _yarp.IConfig_close(self)

    def configure(self, *args):
        """configure(IConfig self, Searchable config) -> bool"""
        return _yarp.IConfig_configure(self, *args)

    def __init__(self): 
        """__init__(yarp::os::IConfig self) -> IConfig"""
        this = _yarp.new_IConfig()
        try: self.this.append(this)
        except: self.this = this
IConfig_swigregister = _yarp.IConfig_swigregister
IConfig_swigregister(IConfig)

class DeviceDriver(IConfig):
    """Proxy of C++ yarp::dev::DeviceDriver class"""
    __swig_setmethods__ = {}
    for _s in [IConfig]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, DeviceDriver, name, value)
    __swig_getmethods__ = {}
    for _s in [IConfig]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, DeviceDriver, name)
    __repr__ = _swig_repr
    __swig_destroy__ = _yarp.delete_DeviceDriver
    __del__ = lambda self : None;
    def open(self, *args):
        """open(DeviceDriver self, Searchable config) -> bool"""
        return _yarp.DeviceDriver_open(self, *args)

    def close(self):
        """close(DeviceDriver self) -> bool"""
        return _yarp.DeviceDriver_close(self)

    def getImplementation(self):
        """getImplementation(DeviceDriver self) -> DeviceDriver"""
        return _yarp.DeviceDriver_getImplementation(self)

    def __init__(self): 
        """__init__(yarp::dev::DeviceDriver self) -> DeviceDriver"""
        this = _yarp.new_DeviceDriver()
        try: self.this.append(this)
        except: self.this = this
DeviceDriver_swigregister = _yarp.DeviceDriver_swigregister
DeviceDriver_swigregister(DeviceDriver)

class DeviceResponder(PortReader,BottleCallback):
    """Proxy of C++ yarp::dev::DeviceResponder class"""
    __swig_setmethods__ = {}
    for _s in [PortReader,BottleCallback]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, DeviceResponder, name, value)
    __swig_getmethods__ = {}
    for _s in [PortReader,BottleCallback]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, DeviceResponder, name)
    __repr__ = _swig_repr
    def __init__(self): 
        """__init__(yarp::dev::DeviceResponder self) -> DeviceResponder"""
        this = _yarp.new_DeviceResponder()
        try: self.this.append(this)
        except: self.this = this
    def addUsage(self, *args):
        """
        addUsage(DeviceResponder self, char const * txt, char const * explain=None)
        addUsage(DeviceResponder self, char const * txt)
        addUsage(DeviceResponder self, Bottle bot, char const * explain=None)
        addUsage(DeviceResponder self, Bottle bot)
        """
        return _yarp.DeviceResponder_addUsage(self, *args)

    def respond(self, *args):
        """respond(DeviceResponder self, Bottle command, Bottle reply) -> bool"""
        return _yarp.DeviceResponder_respond(self, *args)

    def read(self, *args):
        """read(DeviceResponder self, ConnectionReader connection) -> bool"""
        return _yarp.DeviceResponder_read(self, *args)

    def onRead(self, *args):
        """onRead(DeviceResponder self, Bottle v)"""
        return _yarp.DeviceResponder_onRead(self, *args)

    def makeUsage(self):
        """makeUsage(DeviceResponder self)"""
        return _yarp.DeviceResponder_makeUsage(self)

    def attach(self, *args):
        """attach(DeviceResponder self, TypedReaderBottle source)"""
        return _yarp.DeviceResponder_attach(self, *args)

    __swig_destroy__ = _yarp.delete_DeviceResponder
    __del__ = lambda self : None;
DeviceResponder_swigregister = _yarp.DeviceResponder_swigregister
DeviceResponder_swigregister(DeviceResponder)

class PolyDriver(DeviceDriver):
    """Proxy of C++ yarp::dev::PolyDriver class"""
    __swig_setmethods__ = {}
    for _s in [DeviceDriver]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, PolyDriver, name, value)
    __swig_getmethods__ = {}
    for _s in [DeviceDriver]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, PolyDriver, name)
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(yarp::dev::PolyDriver self) -> PolyDriver
        __init__(yarp::dev::PolyDriver self, char const * txt) -> PolyDriver
        __init__(yarp::dev::PolyDriver self, Searchable config) -> PolyDriver
        """
        this = _yarp.new_PolyDriver(*args)
        try: self.this.append(this)
        except: self.this = this
    def open_str(self, *args):
        """open_str(PolyDriver self, char const * txt) -> bool"""
        return _yarp.PolyDriver_open_str(self, *args)

    def open(self, *args):
        """open(PolyDriver self, Searchable config) -> bool"""
        return _yarp.PolyDriver_open(self, *args)

    def link(self, *args):
        """link(PolyDriver self, PolyDriver alt) -> bool"""
        return _yarp.PolyDriver_link(self, *args)

    def take(self):
        """take(PolyDriver self) -> DeviceDriver"""
        return _yarp.PolyDriver_take(self)

    def give(self, *args):
        """give(PolyDriver self, DeviceDriver dd, bool own) -> bool"""
        return _yarp.PolyDriver_give(self, *args)

    __swig_destroy__ = _yarp.delete_PolyDriver
    __del__ = lambda self : None;
    def close(self):
        """close(PolyDriver self) -> bool"""
        return _yarp.PolyDriver_close(self)

    def isValid(self):
        """isValid(PolyDriver self) -> bool"""
        return _yarp.PolyDriver_isValid(self)

    def getOptions(self):
        """getOptions(PolyDriver self) -> Bottle"""
        return _yarp.PolyDriver_getOptions(self)

    def getComment(self, *args):
        """getComment(PolyDriver self, char const * option) -> ConstString"""
        return _yarp.PolyDriver_getComment(self, *args)

    def getDefaultValue(self, *args):
        """getDefaultValue(PolyDriver self, char const * option) -> Value"""
        return _yarp.PolyDriver_getDefaultValue(self, *args)

    def getValue(self, *args):
        """getValue(PolyDriver self, char const * option) -> Value"""
        return _yarp.PolyDriver_getValue(self, *args)

    def getImplementation(self):
        """getImplementation(PolyDriver self) -> DeviceDriver"""
        return _yarp.PolyDriver_getImplementation(self)

    def viewFrameGrabberImage(self):
        """viewFrameGrabberImage(PolyDriver self) -> IFrameGrabberImage"""
        return _yarp.PolyDriver_viewFrameGrabberImage(self)

    def viewIPositionControl(self):
        """viewIPositionControl(PolyDriver self) -> IPositionControl"""
        return _yarp.PolyDriver_viewIPositionControl(self)

    def viewIVelocityControl(self):
        """viewIVelocityControl(PolyDriver self) -> IVelocityControl"""
        return _yarp.PolyDriver_viewIVelocityControl(self)

    def viewIEncoders(self):
        """viewIEncoders(PolyDriver self) -> IEncoders"""
        return _yarp.PolyDriver_viewIEncoders(self)

    def viewIPidControl(self):
        """viewIPidControl(PolyDriver self) -> IPidControl"""
        return _yarp.PolyDriver_viewIPidControl(self)

    def viewIAmplifierControl(self):
        """viewIAmplifierControl(PolyDriver self) -> IAmplifierControl"""
        return _yarp.PolyDriver_viewIAmplifierControl(self)

    def viewIControlLimits(self):
        """viewIControlLimits(PolyDriver self) -> IControlLimits"""
        return _yarp.PolyDriver_viewIControlLimits(self)

    def viewICartesianControl(self):
        """viewICartesianControl(PolyDriver self) -> ICartesianControl"""
        return _yarp.PolyDriver_viewICartesianControl(self)

    def viewIGazeControl(self):
        """viewIGazeControl(PolyDriver self) -> IGazeControl"""
        return _yarp.PolyDriver_viewIGazeControl(self)

    def viewIImpedanceControl(self):
        """viewIImpedanceControl(PolyDriver self) -> IImpedanceControl"""
        return _yarp.PolyDriver_viewIImpedanceControl(self)

    def viewITorqueControl(self):
        """viewITorqueControl(PolyDriver self) -> ITorqueControl"""
        return _yarp.PolyDriver_viewITorqueControl(self)

    def viewIControlMode(self):
        """viewIControlMode(PolyDriver self) -> IControlMode"""
        return _yarp.PolyDriver_viewIControlMode(self)

    def viewIOpenLoopControl(self):
        """viewIOpenLoopControl(PolyDriver self) -> IOpenLoopControl"""
        return _yarp.PolyDriver_viewIOpenLoopControl(self)

PolyDriver_swigregister = _yarp.PolyDriver_swigregister
PolyDriver_swigregister(PolyDriver)

class DriverCreator(_object):
    """Proxy of C++ yarp::dev::DriverCreator class"""
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, DriverCreator, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, DriverCreator, name)
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _yarp.delete_DriverCreator
    __del__ = lambda self : None;
    def toString(self):
        """toString(DriverCreator self) -> ConstString"""
        return _yarp.DriverCreator_toString(self)

    def create(self):
        """create(DriverCreator self) -> DeviceDriver"""
        return _yarp.DriverCreator_create(self)

    def getName(self):
        """getName(DriverCreator self) -> ConstString"""
        return _yarp.DriverCreator_getName(self)

    def getWrapper(self):
        """getWrapper(DriverCreator self) -> ConstString"""
        return _yarp.DriverCreator_getWrapper(self)

    def getCode(self):
        """getCode(DriverCreator self) -> ConstString"""
        return _yarp.DriverCreator_getCode(self)

    def owner(self):
        """owner(DriverCreator self) -> PolyDriver"""
        return _yarp.DriverCreator_owner(self)

DriverCreator_swigregister = _yarp.DriverCreator_swigregister
DriverCreator_swigregister(DriverCreator)

class StubDriverCreator(DriverCreator):
    """Proxy of C++ yarp::dev::StubDriverCreator class"""
    __swig_setmethods__ = {}
    for _s in [DriverCreator]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, StubDriverCreator, name, value)
    __swig_getmethods__ = {}
    for _s in [DriverCreator]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, StubDriverCreator, name)
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """__init__(yarp::dev::StubDriverCreator self, char const * name, char const * wrap, char const * code, char const * libname) -> StubDriverCreator"""
        this = _yarp.new_StubDriverCreator(*args)
        try: self.this.append(this)
        except: self.this = this
    def toString(self):
        """toString(StubDriverCreator self) -> ConstString"""
        return _yarp.StubDriverCreator_toString(self)

    def getName(self):
        """getName(StubDriverCreator self) -> ConstString"""
        return _yarp.StubDriverCreator_getName(self)

    def getWrapper(self):
        """getWrapper(StubDriverCreator self) -> ConstString"""
        return _yarp.StubDriverCreator_getWrapper(self)

    def getCode(self):
        """getCode(StubDriverCreator self) -> ConstString"""
        return _yarp.StubDriverCreator_getCode(self)

    def create(self):
        """create(StubDriverCreator self) -> DeviceDriver"""
        return _yarp.StubDriverCreator_create(self)

    __swig_destroy__ = _yarp.delete_StubDriverCreator
    __del__ = lambda self : None;
StubDriverCreator_swigregister = _yarp.StubDriverCreator_swigregister
StubDriverCreator_swigregister(StubDriverCreator)

class Drivers(_object):
    """Proxy of C++ yarp::dev::Drivers class"""
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, Drivers, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, Drivers, name)
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    def factory():
        """factory() -> Drivers"""
        return _yarp.Drivers_factory()

    if _newclass:factory = staticmethod(factory)
    __swig_getmethods__["factory"] = lambda x: factory
    def open(self, *args):
        """
        open(Drivers self, char const * device) -> DeviceDriver
        open(Drivers self, Searchable config) -> DeviceDriver
        """
        return _yarp.Drivers_open(self, *args)

    def toString(self):
        """toString(Drivers self) -> ConstString"""
        return _yarp.Drivers_toString(self)

    __swig_destroy__ = _yarp.delete_Drivers
    __del__ = lambda self : None;
    def add(self, *args):
        """add(Drivers self, DriverCreator creator)"""
        return _yarp.Drivers_add(self, *args)

    def find(self, *args):
        """find(Drivers self, char const * name) -> DriverCreator"""
        return _yarp.Drivers_find(self, *args)

    def remove(self, *args):
        """remove(Drivers self, char const * name) -> bool"""
        return _yarp.Drivers_remove(self, *args)

    def yarpdev(*args):
        """yarpdev(int argc, char *[] argv) -> int"""
        return _yarp.Drivers_yarpdev(*args)

    if _newclass:yarpdev = staticmethod(yarpdev)
    __swig_getmethods__["yarpdev"] = lambda x: yarpdev
Drivers_swigregister = _yarp.Drivers_swigregister
Drivers_swigregister(Drivers)

def Drivers_factory():
  """Drivers_factory() -> Drivers"""
  return _yarp.Drivers_factory()

def Drivers_yarpdev(*args):
  """Drivers_yarpdev(int argc, char *[] argv) -> int"""
  return _yarp.Drivers_yarpdev(*args)

class IFrameGrabber(_object):
    """Proxy of C++ yarp::dev::IFrameGrabber class"""
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, IFrameGrabber, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, IFrameGrabber, name)
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _yarp.delete_IFrameGrabber
    __del__ = lambda self : None;
    def getRawBuffer(self, *args):
        """getRawBuffer(IFrameGrabber self, unsigned char * buffer) -> bool"""
        return _yarp.IFrameGrabber_getRawBuffer(self, *args)

    def getRawBufferSize(self):
        """getRawBufferSize(IFrameGrabber self) -> int"""
        return _yarp.IFrameGrabber_getRawBufferSize(self)

    def height(self):
        """height(IFrameGrabber self) -> int"""
        return _yarp.IFrameGrabber_height(self)

    def width(self):
        """width(IFrameGrabber self) -> int"""
        return _yarp.IFrameGrabber_width(self)

IFrameGrabber_swigregister = _yarp.IFrameGrabber_swigregister
IFrameGrabber_swigregister(IFrameGrabber)

class IFrameGrabberRgb(_object):
    """Proxy of C++ yarp::dev::IFrameGrabberRgb class"""
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, IFrameGrabberRgb, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, IFrameGrabberRgb, name)
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _yarp.delete_IFrameGrabberRgb
    __del__ = lambda self : None;
    def getRgbBuffer(self, *args):
        """getRgbBuffer(IFrameGrabberRgb self, unsigned char * buffer) -> bool"""
        return _yarp.IFrameGrabberRgb_getRgbBuffer(self, *args)

    def height(self):
        """height(IFrameGrabberRgb self) -> int"""
        return _yarp.IFrameGrabberRgb_height(self)

    def width(self):
        """width(IFrameGrabberRgb self) -> int"""
        return _yarp.IFrameGrabberRgb_width(self)

IFrameGrabberRgb_swigregister = _yarp.IFrameGrabberRgb_swigregister
IFrameGrabberRgb_swigregister(IFrameGrabberRgb)

class IFrameGrabberImage(_object):
    """Proxy of C++ yarp::dev::IFrameGrabberImage class"""
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, IFrameGrabberImage, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, IFrameGrabberImage, name)
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _yarp.delete_IFrameGrabberImage
    __del__ = lambda self : None;
    def getImage(self, *args):
        """getImage(IFrameGrabberImage self, ImageRgb image) -> bool"""
        return _yarp.IFrameGrabberImage_getImage(self, *args)

    def height(self):
        """height(IFrameGrabberImage self) -> int"""
        return _yarp.IFrameGrabberImage_height(self)

    def width(self):
        """width(IFrameGrabberImage self) -> int"""
        return _yarp.IFrameGrabberImage_width(self)

IFrameGrabberImage_swigregister = _yarp.IFrameGrabberImage_swigregister
IFrameGrabberImage_swigregister(IFrameGrabberImage)

class IFrameGrabberImageRaw(_object):
    """Proxy of C++ yarp::dev::IFrameGrabberImageRaw class"""
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, IFrameGrabberImageRaw, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, IFrameGrabberImageRaw, name)
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _yarp.delete_IFrameGrabberImageRaw
    __del__ = lambda self : None;
    def getImage(self, *args):
        """getImage(IFrameGrabberImageRaw self, ImageMono image) -> bool"""
        return _yarp.IFrameGrabberImageRaw_getImage(self, *args)

    def height(self):
        """height(IFrameGrabberImageRaw self) -> int"""
        return _yarp.IFrameGrabberImageRaw_height(self)

    def width(self):
        """width(IFrameGrabberImageRaw self) -> int"""
        return _yarp.IFrameGrabberImageRaw_width(self)

IFrameGrabberImageRaw_swigregister = _yarp.IFrameGrabberImageRaw_swigregister
IFrameGrabberImageRaw_swigregister(IFrameGrabberImageRaw)

class IFrameWriterImage(_object):
    """Proxy of C++ yarp::dev::IFrameWriterImage class"""
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, IFrameWriterImage, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, IFrameWriterImage, name)
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _yarp.delete_IFrameWriterImage
    __del__ = lambda self : None;
    def putImage(self, *args):
        """putImage(IFrameWriterImage self, ImageRgb image) -> bool"""
        return _yarp.IFrameWriterImage_putImage(self, *args)

IFrameWriterImage_swigregister = _yarp.IFrameWriterImage_swigregister
IFrameWriterImage_swigregister(IFrameWriterImage)

class IFrameGrabberControls(_object):
    """Proxy of C++ yarp::dev::IFrameGrabberControls class"""
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, IFrameGrabberControls, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, IFrameGrabberControls, name)
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _yarp.delete_IFrameGrabberControls
    __del__ = lambda self : None;
    def setBrightness(self, *args):
        """setBrightness(IFrameGrabberControls self, double v) -> bool"""
        return _yarp.IFrameGrabberControls_setBrightness(self, *args)

    def setExposure(self, *args):
        """setExposure(IFrameGrabberControls self, double v) -> bool"""
        return _yarp.IFrameGrabberControls_setExposure(self, *args)

    def setSharpness(self, *args):
        """setSharpness(IFrameGrabberControls self, double v) -> bool"""
        return _yarp.IFrameGrabberControls_setSharpness(self, *args)

    def setWhiteBalance(self, *args):
        """setWhiteBalance(IFrameGrabberControls self, double blue, double red) -> bool"""
        return _yarp.IFrameGrabberControls_setWhiteBalance(self, *args)

    def setHue(self, *args):
        """setHue(IFrameGrabberControls self, double v) -> bool"""
        return _yarp.IFrameGrabberControls_setHue(self, *args)

    def setSaturation(self, *args):
        """setSaturation(IFrameGrabberControls self, double v) -> bool"""
        return _yarp.IFrameGrabberControls_setSaturation(self, *args)

    def setGamma(self, *args):
        """setGamma(IFrameGrabberControls self, double v) -> bool"""
        return _yarp.IFrameGrabberControls_setGamma(self, *args)

    def setShutter(self, *args):
        """setShutter(IFrameGrabberControls self, double v) -> bool"""
        return _yarp.IFrameGrabberControls_setShutter(self, *args)

    def setGain(self, *args):
        """setGain(IFrameGrabberControls self, double v) -> bool"""
        return _yarp.IFrameGrabberControls_setGain(self, *args)

    def setIris(self, *args):
        """setIris(IFrameGrabberControls self, double v) -> bool"""
        return _yarp.IFrameGrabberControls_setIris(self, *args)

    def getBrightness(self):
        """getBrightness(IFrameGrabberControls self) -> double"""
        return _yarp.IFrameGrabberControls_getBrightness(self)

    def getExposure(self):
        """getExposure(IFrameGrabberControls self) -> double"""
        return _yarp.IFrameGrabberControls_getExposure(self)

    def getSharpness(self):
        """getSharpness(IFrameGrabberControls self) -> double"""
        return _yarp.IFrameGrabberControls_getSharpness(self)

    def getWhiteBalance(self, *args):
        """getWhiteBalance(IFrameGrabberControls self, double & blue, double & red) -> bool"""
        return _yarp.IFrameGrabberControls_getWhiteBalance(self, *args)

    def getHue(self):
        """getHue(IFrameGrabberControls self) -> double"""
        return _yarp.IFrameGrabberControls_getHue(self)

    def getSaturation(self):
        """getSaturation(IFrameGrabberControls self) -> double"""
        return _yarp.IFrameGrabberControls_getSaturation(self)

    def getGamma(self):
        """getGamma(IFrameGrabberControls self) -> double"""
        return _yarp.IFrameGrabberControls_getGamma(self)

    def getShutter(self):
        """getShutter(IFrameGrabberControls self) -> double"""
        return _yarp.IFrameGrabberControls_getShutter(self)

    def getGain(self):
        """getGain(IFrameGrabberControls self) -> double"""
        return _yarp.IFrameGrabberControls_getGain(self)

    def getIris(self):
        """getIris(IFrameGrabberControls self) -> double"""
        return _yarp.IFrameGrabberControls_getIris(self)

IFrameGrabberControls_swigregister = _yarp.IFrameGrabberControls_swigregister
IFrameGrabberControls_swigregister(IFrameGrabberControls)

class IFrameGrabberControlsDC1394(IFrameGrabberControls):
    """Proxy of C++ yarp::dev::IFrameGrabberControlsDC1394 class"""
    __swig_setmethods__ = {}
    for _s in [IFrameGrabberControls]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, IFrameGrabberControlsDC1394, name, value)
    __swig_getmethods__ = {}
    for _s in [IFrameGrabberControls]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, IFrameGrabberControlsDC1394, name)
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    def hasFeatureDC1394(self, *args):
        """hasFeatureDC1394(IFrameGrabberControlsDC1394 self, int feature) -> bool"""
        return _yarp.IFrameGrabberControlsDC1394_hasFeatureDC1394(self, *args)

    def setFeatureDC1394(self, *args):
        """setFeatureDC1394(IFrameGrabberControlsDC1394 self, int feature, double value) -> bool"""
        return _yarp.IFrameGrabberControlsDC1394_setFeatureDC1394(self, *args)

    def getFeatureDC1394(self, *args):
        """getFeatureDC1394(IFrameGrabberControlsDC1394 self, int feature) -> double"""
        return _yarp.IFrameGrabberControlsDC1394_getFeatureDC1394(self, *args)

    def hasOnOffDC1394(self, *args):
        """hasOnOffDC1394(IFrameGrabberControlsDC1394 self, int feature) -> bool"""
        return _yarp.IFrameGrabberControlsDC1394_hasOnOffDC1394(self, *args)

    def setActiveDC1394(self, *args):
        """setActiveDC1394(IFrameGrabberControlsDC1394 self, int feature, bool onoff) -> bool"""
        return _yarp.IFrameGrabberControlsDC1394_setActiveDC1394(self, *args)

    def getActiveDC1394(self, *args):
        """getActiveDC1394(IFrameGrabberControlsDC1394 self, int feature) -> bool"""
        return _yarp.IFrameGrabberControlsDC1394_getActiveDC1394(self, *args)

    def hasAutoDC1394(self, *args):
        """hasAutoDC1394(IFrameGrabberControlsDC1394 self, int feature) -> bool"""
        return _yarp.IFrameGrabberControlsDC1394_hasAutoDC1394(self, *args)

    def hasManualDC1394(self, *args):
        """hasManualDC1394(IFrameGrabberControlsDC1394 self, int feature) -> bool"""
        return _yarp.IFrameGrabberControlsDC1394_hasManualDC1394(self, *args)

    def hasOnePushDC1394(self, *args):
        """hasOnePushDC1394(IFrameGrabberControlsDC1394 self, int feature) -> bool"""
        return _yarp.IFrameGrabberControlsDC1394_hasOnePushDC1394(self, *args)

    def setModeDC1394(self, *args):
        """setModeDC1394(IFrameGrabberControlsDC1394 self, int feature, bool auto_onoff) -> bool"""
        return _yarp.IFrameGrabberControlsDC1394_setModeDC1394(self, *args)

    def getModeDC1394(self, *args):
        """getModeDC1394(IFrameGrabberControlsDC1394 self, int feature) -> bool"""
        return _yarp.IFrameGrabberControlsDC1394_getModeDC1394(self, *args)

    def setOnePushDC1394(self, *args):
        """setOnePushDC1394(IFrameGrabberControlsDC1394 self, int feature) -> bool"""
        return _yarp.IFrameGrabberControlsDC1394_setOnePushDC1394(self, *args)

    def getVideoModeMaskDC1394(self):
        """getVideoModeMaskDC1394(IFrameGrabberControlsDC1394 self) -> unsigned int"""
        return _yarp.IFrameGrabberControlsDC1394_getVideoModeMaskDC1394(self)

    def getVideoModeDC1394(self):
        """getVideoModeDC1394(IFrameGrabberControlsDC1394 self) -> unsigned int"""
        return _yarp.IFrameGrabberControlsDC1394_getVideoModeDC1394(self)

    def setVideoModeDC1394(self, *args):
        """setVideoModeDC1394(IFrameGrabberControlsDC1394 self, int video_mode) -> bool"""
        return _yarp.IFrameGrabberControlsDC1394_setVideoModeDC1394(self, *args)

    def getFPSMaskDC1394(self):
        """getFPSMaskDC1394(IFrameGrabberControlsDC1394 self) -> unsigned int"""
        return _yarp.IFrameGrabberControlsDC1394_getFPSMaskDC1394(self)

    def getFPSDC1394(self):
        """getFPSDC1394(IFrameGrabberControlsDC1394 self) -> unsigned int"""
        return _yarp.IFrameGrabberControlsDC1394_getFPSDC1394(self)

    def setFPSDC1394(self, *args):
        """setFPSDC1394(IFrameGrabberControlsDC1394 self, int fps) -> bool"""
        return _yarp.IFrameGrabberControlsDC1394_setFPSDC1394(self, *args)

    def getISOSpeedDC1394(self):
        """getISOSpeedDC1394(IFrameGrabberControlsDC1394 self) -> unsigned int"""
        return _yarp.IFrameGrabberControlsDC1394_getISOSpeedDC1394(self)

    def setISOSpeedDC1394(self, *args):
        """setISOSpeedDC1394(IFrameGrabberControlsDC1394 self, int speed) -> bool"""
        return _yarp.IFrameGrabberControlsDC1394_setISOSpeedDC1394(self, *args)

    def getColorCodingMaskDC1394(self, *args):
        """getColorCodingMaskDC1394(IFrameGrabberControlsDC1394 self, unsigned int video_mode) -> unsigned int"""
        return _yarp.IFrameGrabberControlsDC1394_getColorCodingMaskDC1394(self, *args)

    def getColorCodingDC1394(self):
        """getColorCodingDC1394(IFrameGrabberControlsDC1394 self) -> unsigned int"""
        return _yarp.IFrameGrabberControlsDC1394_getColorCodingDC1394(self)

    def setColorCodingDC1394(self, *args):
        """setColorCodingDC1394(IFrameGrabberControlsDC1394 self, int coding) -> bool"""
        return _yarp.IFrameGrabberControlsDC1394_setColorCodingDC1394(self, *args)

    def setWhiteBalanceDC1394(self, *args):
        """setWhiteBalanceDC1394(IFrameGrabberControlsDC1394 self, double b, double r) -> bool"""
        return _yarp.IFrameGrabberControlsDC1394_setWhiteBalanceDC1394(self, *args)

    def getWhiteBalanceDC1394(self, *args):
        """getWhiteBalanceDC1394(IFrameGrabberControlsDC1394 self, double & b, double & r) -> bool"""
        return _yarp.IFrameGrabberControlsDC1394_getWhiteBalanceDC1394(self, *args)

    def getFormat7MaxWindowDC1394(self, *args):
        """
        getFormat7MaxWindowDC1394(IFrameGrabberControlsDC1394 self, unsigned int & xdim, unsigned int & ydim, unsigned int & xstep, unsigned int & ystep, 
            unsigned int & xoffstep, unsigned int & yoffstep) -> bool
        """
        return _yarp.IFrameGrabberControlsDC1394_getFormat7MaxWindowDC1394(self, *args)

    def getFormat7WindowDC1394(self, *args):
        """getFormat7WindowDC1394(IFrameGrabberControlsDC1394 self, unsigned int & xdim, unsigned int & ydim, int & x0, int & y0) -> bool"""
        return _yarp.IFrameGrabberControlsDC1394_getFormat7WindowDC1394(self, *args)

    def setFormat7WindowDC1394(self, *args):
        """setFormat7WindowDC1394(IFrameGrabberControlsDC1394 self, unsigned int xdim, unsigned int ydim, int x0, int y0) -> bool"""
        return _yarp.IFrameGrabberControlsDC1394_setFormat7WindowDC1394(self, *args)

    def setOperationModeDC1394(self, *args):
        """setOperationModeDC1394(IFrameGrabberControlsDC1394 self, bool b1394b) -> bool"""
        return _yarp.IFrameGrabberControlsDC1394_setOperationModeDC1394(self, *args)

    def getOperationModeDC1394(self):
        """getOperationModeDC1394(IFrameGrabberControlsDC1394 self) -> bool"""
        return _yarp.IFrameGrabberControlsDC1394_getOperationModeDC1394(self)

    def setTransmissionDC1394(self, *args):
        """setTransmissionDC1394(IFrameGrabberControlsDC1394 self, bool bTxON) -> bool"""
        return _yarp.IFrameGrabberControlsDC1394_setTransmissionDC1394(self, *args)

    def getTransmissionDC1394(self):
        """getTransmissionDC1394(IFrameGrabberControlsDC1394 self) -> bool"""
        return _yarp.IFrameGrabberControlsDC1394_getTransmissionDC1394(self)

    def setBroadcastDC1394(self, *args):
        """setBroadcastDC1394(IFrameGrabberControlsDC1394 self, bool onoff) -> bool"""
        return _yarp.IFrameGrabberControlsDC1394_setBroadcastDC1394(self, *args)

    def setDefaultsDC1394(self):
        """setDefaultsDC1394(IFrameGrabberControlsDC1394 self) -> bool"""
        return _yarp.IFrameGrabberControlsDC1394_setDefaultsDC1394(self)

    def setResetDC1394(self):
        """setResetDC1394(IFrameGrabberControlsDC1394 self) -> bool"""
        return _yarp.IFrameGrabberControlsDC1394_setResetDC1394(self)

    def setPowerDC1394(self, *args):
        """setPowerDC1394(IFrameGrabberControlsDC1394 self, bool onoff) -> bool"""
        return _yarp.IFrameGrabberControlsDC1394_setPowerDC1394(self, *args)

    def setCaptureDC1394(self, *args):
        """setCaptureDC1394(IFrameGrabberControlsDC1394 self, bool bON) -> bool"""
        return _yarp.IFrameGrabberControlsDC1394_setCaptureDC1394(self, *args)

    def getBytesPerPacketDC1394(self):
        """getBytesPerPacketDC1394(IFrameGrabberControlsDC1394 self) -> unsigned int"""
        return _yarp.IFrameGrabberControlsDC1394_getBytesPerPacketDC1394(self)

    def setBytesPerPacketDC1394(self, *args):
        """setBytesPerPacketDC1394(IFrameGrabberControlsDC1394 self, unsigned int bpp) -> bool"""
        return _yarp.IFrameGrabberControlsDC1394_setBytesPerPacketDC1394(self, *args)

    __swig_destroy__ = _yarp.delete_IFrameGrabberControlsDC1394
    __del__ = lambda self : None;
IFrameGrabberControlsDC1394_swigregister = _yarp.IFrameGrabberControlsDC1394_swigregister
IFrameGrabberControlsDC1394_swigregister(IFrameGrabberControlsDC1394)

class IAudioVisualGrabber(_object):
    """Proxy of C++ yarp::dev::IAudioVisualGrabber class"""
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, IAudioVisualGrabber, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, IAudioVisualGrabber, name)
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _yarp.delete_IAudioVisualGrabber
    __del__ = lambda self : None;
    def getAudioVisual(self, *args):
        """getAudioVisual(IAudioVisualGrabber self, ImageRgb image, Sound sound) -> bool"""
        return _yarp.IAudioVisualGrabber_getAudioVisual(self, *args)

IAudioVisualGrabber_swigregister = _yarp.IAudioVisualGrabber_swigregister
IAudioVisualGrabber_swigregister(IAudioVisualGrabber)

class IFrameWriterAudioVisual(_object):
    """Proxy of C++ yarp::dev::IFrameWriterAudioVisual class"""
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, IFrameWriterAudioVisual, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, IFrameWriterAudioVisual, name)
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _yarp.delete_IFrameWriterAudioVisual
    __del__ = lambda self : None;
    def putAudioVisual(self, *args):
        """putAudioVisual(IFrameWriterAudioVisual self, ImageRgb image, Sound sound) -> bool"""
        return _yarp.IFrameWriterAudioVisual_putAudioVisual(self, *args)

IFrameWriterAudioVisual_swigregister = _yarp.IFrameWriterAudioVisual_swigregister
IFrameWriterAudioVisual_swigregister(IFrameWriterAudioVisual)

class IAudioVisualStream(_object):
    """Proxy of C++ yarp::dev::IAudioVisualStream class"""
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, IAudioVisualStream, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, IAudioVisualStream, name)
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _yarp.delete_IAudioVisualStream
    __del__ = lambda self : None;
    def hasAudio(self):
        """hasAudio(IAudioVisualStream self) -> bool"""
        return _yarp.IAudioVisualStream_hasAudio(self)

    def hasVideo(self):
        """hasVideo(IAudioVisualStream self) -> bool"""
        return _yarp.IAudioVisualStream_hasVideo(self)

    def hasRawVideo(self):
        """hasRawVideo(IAudioVisualStream self) -> bool"""
        return _yarp.IAudioVisualStream_hasRawVideo(self)

IAudioVisualStream_swigregister = _yarp.IAudioVisualStream_swigregister
IAudioVisualStream_swigregister(IAudioVisualStream)

class IPidControlRaw(_object):
    """Proxy of C++ yarp::dev::IPidControlRaw class"""
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, IPidControlRaw, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, IPidControlRaw, name)
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _yarp.delete_IPidControlRaw
    __del__ = lambda self : None;
    def setPidRaw(self, *args):
        """setPidRaw(IPidControlRaw self, int j, Pid const & pid) -> bool"""
        return _yarp.IPidControlRaw_setPidRaw(self, *args)

    def setPidsRaw(self, *args):
        """setPidsRaw(IPidControlRaw self, Pid const * pids) -> bool"""
        return _yarp.IPidControlRaw_setPidsRaw(self, *args)

    def setReferenceRaw(self, *args):
        """setReferenceRaw(IPidControlRaw self, int j, double ref) -> bool"""
        return _yarp.IPidControlRaw_setReferenceRaw(self, *args)

    def setReferencesRaw(self, *args):
        """setReferencesRaw(IPidControlRaw self, double const * refs) -> bool"""
        return _yarp.IPidControlRaw_setReferencesRaw(self, *args)

    def setErrorLimitRaw(self, *args):
        """setErrorLimitRaw(IPidControlRaw self, int j, double limit) -> bool"""
        return _yarp.IPidControlRaw_setErrorLimitRaw(self, *args)

    def setErrorLimitsRaw(self, *args):
        """setErrorLimitsRaw(IPidControlRaw self, double const * limits) -> bool"""
        return _yarp.IPidControlRaw_setErrorLimitsRaw(self, *args)

    def getErrorRaw(self, *args):
        """getErrorRaw(IPidControlRaw self, int j, double * err) -> bool"""
        return _yarp.IPidControlRaw_getErrorRaw(self, *args)

    def getErrorsRaw(self, *args):
        """getErrorsRaw(IPidControlRaw self, double * errs) -> bool"""
        return _yarp.IPidControlRaw_getErrorsRaw(self, *args)

    def getOutputRaw(self, *args):
        """getOutputRaw(IPidControlRaw self, int j, double * out) -> bool"""
        return _yarp.IPidControlRaw_getOutputRaw(self, *args)

    def getOutputsRaw(self, *args):
        """getOutputsRaw(IPidControlRaw self, double * outs) -> bool"""
        return _yarp.IPidControlRaw_getOutputsRaw(self, *args)

    def getPidRaw(self, *args):
        """getPidRaw(IPidControlRaw self, int j, Pid * pid) -> bool"""
        return _yarp.IPidControlRaw_getPidRaw(self, *args)

    def getPidsRaw(self, *args):
        """getPidsRaw(IPidControlRaw self, Pid * pids) -> bool"""
        return _yarp.IPidControlRaw_getPidsRaw(self, *args)

    def getReferenceRaw(self, *args):
        """getReferenceRaw(IPidControlRaw self, int j, double * ref) -> bool"""
        return _yarp.IPidControlRaw_getReferenceRaw(self, *args)

    def getReferencesRaw(self, *args):
        """getReferencesRaw(IPidControlRaw self, double * refs) -> bool"""
        return _yarp.IPidControlRaw_getReferencesRaw(self, *args)

    def getErrorLimitRaw(self, *args):
        """getErrorLimitRaw(IPidControlRaw self, int j, double * limit) -> bool"""
        return _yarp.IPidControlRaw_getErrorLimitRaw(self, *args)

    def getErrorLimitsRaw(self, *args):
        """getErrorLimitsRaw(IPidControlRaw self, double * limits) -> bool"""
        return _yarp.IPidControlRaw_getErrorLimitsRaw(self, *args)

    def resetPidRaw(self, *args):
        """resetPidRaw(IPidControlRaw self, int j) -> bool"""
        return _yarp.IPidControlRaw_resetPidRaw(self, *args)

    def disablePidRaw(self, *args):
        """disablePidRaw(IPidControlRaw self, int j) -> bool"""
        return _yarp.IPidControlRaw_disablePidRaw(self, *args)

    def enablePidRaw(self, *args):
        """enablePidRaw(IPidControlRaw self, int j) -> bool"""
        return _yarp.IPidControlRaw_enablePidRaw(self, *args)

    def setOffsetRaw(self, *args):
        """setOffsetRaw(IPidControlRaw self, int j, double v) -> bool"""
        return _yarp.IPidControlRaw_setOffsetRaw(self, *args)

IPidControlRaw_swigregister = _yarp.IPidControlRaw_swigregister
IPidControlRaw_swigregister(IPidControlRaw)

class IPidControl(_object):
    """Proxy of C++ yarp::dev::IPidControl class"""
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, IPidControl, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, IPidControl, name)
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _yarp.delete_IPidControl
    __del__ = lambda self : None;
    def setReference(self, *args):
        """setReference(IPidControl self, int j, double ref) -> bool"""
        return _yarp.IPidControl_setReference(self, *args)

    def setErrorLimit(self, *args):
        """setErrorLimit(IPidControl self, int j, double limit) -> bool"""
        return _yarp.IPidControl_setErrorLimit(self, *args)

    def resetPid(self, *args):
        """resetPid(IPidControl self, int j) -> bool"""
        return _yarp.IPidControl_resetPid(self, *args)

    def disablePid(self, *args):
        """disablePid(IPidControl self, int j) -> bool"""
        return _yarp.IPidControl_disablePid(self, *args)

    def enablePid(self, *args):
        """enablePid(IPidControl self, int j) -> bool"""
        return _yarp.IPidControl_enablePid(self, *args)

    def setOffset(self, *args):
        """setOffset(IPidControl self, int j, double v) -> bool"""
        return _yarp.IPidControl_setOffset(self, *args)

    def setReferences(self, *args):
        """
        setReferences(IPidControl self, double const * refs) -> bool
        setReferences(IPidControl self, DVector data) -> bool
        """
        return _yarp.IPidControl_setReferences(self, *args)

    def getReference(self, *args):
        """
        getReference(IPidControl self, int j, double * ref) -> bool
        getReference(IPidControl self, int j, DVector data) -> bool
        """
        return _yarp.IPidControl_getReference(self, *args)

    def getReferences(self, *args):
        """
        getReferences(IPidControl self, double * refs) -> bool
        getReferences(IPidControl self, DVector data) -> bool
        """
        return _yarp.IPidControl_getReferences(self, *args)

    def setErrorLimits(self, *args):
        """
        setErrorLimits(IPidControl self, double const * limits) -> bool
        setErrorLimits(IPidControl self, DVector data) -> bool
        """
        return _yarp.IPidControl_setErrorLimits(self, *args)

    def getErrorLimit(self, *args):
        """
        getErrorLimit(IPidControl self, int j, double * limit) -> bool
        getErrorLimit(IPidControl self, int j, DVector data) -> bool
        """
        return _yarp.IPidControl_getErrorLimit(self, *args)

    def getErrorLimits(self, *args):
        """
        getErrorLimits(IPidControl self, double * limits) -> bool
        getErrorLimits(IPidControl self, DVector data) -> bool
        """
        return _yarp.IPidControl_getErrorLimits(self, *args)

    def getError(self, *args):
        """
        getError(IPidControl self, int j, double * err) -> bool
        getError(IPidControl self, int j, DVector data) -> bool
        """
        return _yarp.IPidControl_getError(self, *args)

    def getErrors(self, *args):
        """
        getErrors(IPidControl self, double * errs) -> bool
        getErrors(IPidControl self, DVector data) -> bool
        """
        return _yarp.IPidControl_getErrors(self, *args)

    def getOutput(self, *args):
        """
        getOutput(IPidControl self, int j, double * out) -> bool
        getOutput(IPidControl self, int j, DVector data) -> bool
        """
        return _yarp.IPidControl_getOutput(self, *args)

    def getOutputs(self, *args):
        """
        getOutputs(IPidControl self, double * outs) -> bool
        getOutputs(IPidControl self, DVector data) -> bool
        """
        return _yarp.IPidControl_getOutputs(self, *args)

    def setPid(self, *args):
        """setPid(IPidControl self, int j, Pid pid) -> bool"""
        return _yarp.IPidControl_setPid(self, *args)

    def setPids(self, *args):
        """
        setPids(IPidControl self, Pid const * pids) -> bool
        setPids(IPidControl self, PidVector pids) -> bool
        """
        return _yarp.IPidControl_setPids(self, *args)

    def getPid(self, *args):
        """getPid(IPidControl self, int j, PidVector pid) -> bool"""
        return _yarp.IPidControl_getPid(self, *args)

    def getPids(self, *args):
        """
        getPids(IPidControl self, Pid * pids) -> bool
        getPids(IPidControl self, PidVector pids) -> bool
        """
        return _yarp.IPidControl_getPids(self, *args)

IPidControl_swigregister = _yarp.IPidControl_swigregister
IPidControl_swigregister(IPidControl)

class IAmplifierControl(_object):
    """Proxy of C++ yarp::dev::IAmplifierControl class"""
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, IAmplifierControl, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, IAmplifierControl, name)
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _yarp.delete_IAmplifierControl
    __del__ = lambda self : None;
    def enableAmp(self, *args):
        """enableAmp(IAmplifierControl self, int j) -> bool"""
        return _yarp.IAmplifierControl_enableAmp(self, *args)

    def disableAmp(self, *args):
        """disableAmp(IAmplifierControl self, int j) -> bool"""
        return _yarp.IAmplifierControl_disableAmp(self, *args)

    def setMaxCurrent(self, *args):
        """setMaxCurrent(IAmplifierControl self, int j, double v) -> bool"""
        return _yarp.IAmplifierControl_setMaxCurrent(self, *args)

    def getAmpStatus(self, *args):
        """
        getAmpStatus(IAmplifierControl self, int * st) -> bool
        getAmpStatus(IAmplifierControl self, int j, int * v) -> bool
        """
        return _yarp.IAmplifierControl_getAmpStatus(self, *args)

    def getCurrents(self, *args):
        """
        getCurrents(IAmplifierControl self, double * vals) -> bool
        getCurrents(IAmplifierControl self, DVector data) -> bool
        """
        return _yarp.IAmplifierControl_getCurrents(self, *args)

    def getCurrent(self, *args):
        """
        getCurrent(IAmplifierControl self, int j, double * val) -> bool
        getCurrent(IAmplifierControl self, int j, DVector data) -> bool
        """
        return _yarp.IAmplifierControl_getCurrent(self, *args)

IAmplifierControl_swigregister = _yarp.IAmplifierControl_swigregister
IAmplifierControl_swigregister(IAmplifierControl)

class IAmplifierControlRaw(_object):
    """Proxy of C++ yarp::dev::IAmplifierControlRaw class"""
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, IAmplifierControlRaw, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, IAmplifierControlRaw, name)
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _yarp.delete_IAmplifierControlRaw
    __del__ = lambda self : None;
    def enableAmpRaw(self, *args):
        """enableAmpRaw(IAmplifierControlRaw self, int j) -> bool"""
        return _yarp.IAmplifierControlRaw_enableAmpRaw(self, *args)

    def disableAmpRaw(self, *args):
        """disableAmpRaw(IAmplifierControlRaw self, int j) -> bool"""
        return _yarp.IAmplifierControlRaw_disableAmpRaw(self, *args)

    def getCurrentsRaw(self, *args):
        """getCurrentsRaw(IAmplifierControlRaw self, double * vals) -> bool"""
        return _yarp.IAmplifierControlRaw_getCurrentsRaw(self, *args)

    def getCurrentRaw(self, *args):
        """getCurrentRaw(IAmplifierControlRaw self, int j, double * val) -> bool"""
        return _yarp.IAmplifierControlRaw_getCurrentRaw(self, *args)

    def setMaxCurrentRaw(self, *args):
        """setMaxCurrentRaw(IAmplifierControlRaw self, int j, double v) -> bool"""
        return _yarp.IAmplifierControlRaw_setMaxCurrentRaw(self, *args)

    def getAmpStatusRaw(self, *args):
        """
        getAmpStatusRaw(IAmplifierControlRaw self, int * st) -> bool
        getAmpStatusRaw(IAmplifierControlRaw self, int j, int * st) -> bool
        """
        return _yarp.IAmplifierControlRaw_getAmpStatusRaw(self, *args)

IAmplifierControlRaw_swigregister = _yarp.IAmplifierControlRaw_swigregister
IAmplifierControlRaw_swigregister(IAmplifierControlRaw)

class IControlCalibrationRaw(_object):
    """Proxy of C++ yarp::dev::IControlCalibrationRaw class"""
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, IControlCalibrationRaw, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, IControlCalibrationRaw, name)
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _yarp.delete_IControlCalibrationRaw
    __del__ = lambda self : None;
    def calibrateRaw(self, *args):
        """calibrateRaw(IControlCalibrationRaw self, int j, double p) -> bool"""
        return _yarp.IControlCalibrationRaw_calibrateRaw(self, *args)

    def doneRaw(self, *args):
        """doneRaw(IControlCalibrationRaw self, int j) -> bool"""
        return _yarp.IControlCalibrationRaw_doneRaw(self, *args)

IControlCalibrationRaw_swigregister = _yarp.IControlCalibrationRaw_swigregister
IControlCalibrationRaw_swigregister(IControlCalibrationRaw)

class IControlCalibration2Raw(_object):
    """Proxy of C++ yarp::dev::IControlCalibration2Raw class"""
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, IControlCalibration2Raw, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, IControlCalibration2Raw, name)
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _yarp.delete_IControlCalibration2Raw
    __del__ = lambda self : None;
    def calibrate2Raw(self, *args):
        """calibrate2Raw(IControlCalibration2Raw self, int axis, unsigned int type, double p1, double p2, double p3) -> bool"""
        return _yarp.IControlCalibration2Raw_calibrate2Raw(self, *args)

    def doneRaw(self, *args):
        """doneRaw(IControlCalibration2Raw self, int j) -> bool"""
        return _yarp.IControlCalibration2Raw_doneRaw(self, *args)

IControlCalibration2Raw_swigregister = _yarp.IControlCalibration2Raw_swigregister
IControlCalibration2Raw_swigregister(IControlCalibration2Raw)

class IControlCalibration(_object):
    """Proxy of C++ yarp::dev::IControlCalibration class"""
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, IControlCalibration, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, IControlCalibration, name)
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _yarp.delete_IControlCalibration
    __del__ = lambda self : None;
    def done(self, *args):
        """done(IControlCalibration self, int j) -> bool"""
        return _yarp.IControlCalibration_done(self, *args)

    def setCalibrator(self, *args):
        """setCalibrator(IControlCalibration self, ICalibrator * c) -> bool"""
        return _yarp.IControlCalibration_setCalibrator(self, *args)

    def calibrate(self, *args):
        """
        calibrate(IControlCalibration self, int j, double p) -> bool
        calibrate(IControlCalibration self) -> bool
        """
        return _yarp.IControlCalibration_calibrate(self, *args)

    def park(self, wait=True):
        """
        park(IControlCalibration self, bool wait=True) -> bool
        park(IControlCalibration self) -> bool
        """
        return _yarp.IControlCalibration_park(self, wait)

IControlCalibration_swigregister = _yarp.IControlCalibration_swigregister
IControlCalibration_swigregister(IControlCalibration)

class IControlCalibration2(_object):
    """Proxy of C++ yarp::dev::IControlCalibration2 class"""
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, IControlCalibration2, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, IControlCalibration2, name)
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _yarp.delete_IControlCalibration2
    __del__ = lambda self : None;
    def calibrate2(self, *args):
        """calibrate2(IControlCalibration2 self, int axis, unsigned int type, double p1, double p2, double p3) -> bool"""
        return _yarp.IControlCalibration2_calibrate2(self, *args)

    def done(self, *args):
        """done(IControlCalibration2 self, int j) -> bool"""
        return _yarp.IControlCalibration2_done(self, *args)

    def setCalibrator(self, *args):
        """setCalibrator(IControlCalibration2 self, ICalibrator * c) -> bool"""
        return _yarp.IControlCalibration2_setCalibrator(self, *args)

    def calibrate(self):
        """calibrate(IControlCalibration2 self) -> bool"""
        return _yarp.IControlCalibration2_calibrate(self)

    def park(self, wait=True):
        """
        park(IControlCalibration2 self, bool wait=True) -> bool
        park(IControlCalibration2 self) -> bool
        """
        return _yarp.IControlCalibration2_park(self, wait)

    def abortCalibration(self):
        """abortCalibration(IControlCalibration2 self) -> bool"""
        return _yarp.IControlCalibration2_abortCalibration(self)

    def abortPark(self):
        """abortPark(IControlCalibration2 self) -> bool"""
        return _yarp.IControlCalibration2_abortPark(self)

IControlCalibration2_swigregister = _yarp.IControlCalibration2_swigregister
IControlCalibration2_swigregister(IControlCalibration2)

class IControlDebug(_object):
    """Proxy of C++ yarp::dev::IControlDebug class"""
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, IControlDebug, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, IControlDebug, name)
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _yarp.delete_IControlDebug
    __del__ = lambda self : None;
    def setPrintFunction(self, *args):
        """setPrintFunction(IControlDebug self, int (*)(char const *,...) f) -> bool"""
        return _yarp.IControlDebug_setPrintFunction(self, *args)

    def loadBootMemory(self):
        """loadBootMemory(IControlDebug self) -> bool"""
        return _yarp.IControlDebug_loadBootMemory(self)

    def saveBootMemory(self):
        """saveBootMemory(IControlDebug self) -> bool"""
        return _yarp.IControlDebug_saveBootMemory(self)

IControlDebug_swigregister = _yarp.IControlDebug_swigregister
IControlDebug_swigregister(IControlDebug)

class IControlLimits(_object):
    """Proxy of C++ yarp::dev::IControlLimits class"""
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, IControlLimits, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, IControlLimits, name)
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _yarp.delete_IControlLimits
    __del__ = lambda self : None;
    def setLimits(self, *args):
        """setLimits(IControlLimits self, int axis, double min, double max) -> bool"""
        return _yarp.IControlLimits_setLimits(self, *args)

    def getLimits(self, *args):
        """
        getLimits(IControlLimits self, int axis, double * min, double * max) -> bool
        getLimits(IControlLimits self, int axis, DVector min, DVector max) -> bool
        """
        return _yarp.IControlLimits_getLimits(self, *args)

IControlLimits_swigregister = _yarp.IControlLimits_swigregister
IControlLimits_swigregister(IControlLimits)

class IControlLimitsRaw(_object):
    """Proxy of C++ yarp::dev::IControlLimitsRaw class"""
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, IControlLimitsRaw, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, IControlLimitsRaw, name)
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _yarp.delete_IControlLimitsRaw
    __del__ = lambda self : None;
    def setLimitsRaw(self, *args):
        """setLimitsRaw(IControlLimitsRaw self, int axis, double min, double max) -> bool"""
        return _yarp.IControlLimitsRaw_setLimitsRaw(self, *args)

    def getLimitsRaw(self, *args):
        """getLimitsRaw(IControlLimitsRaw self, int axis, double * min, double * max) -> bool"""
        return _yarp.IControlLimitsRaw_getLimitsRaw(self, *args)

IControlLimitsRaw_swigregister = _yarp.IControlLimitsRaw_swigregister
IControlLimitsRaw_swigregister(IControlLimitsRaw)

class IAxisInfo(_object):
    """Proxy of C++ yarp::dev::IAxisInfo class"""
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, IAxisInfo, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, IAxisInfo, name)
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _yarp.delete_IAxisInfo
    __del__ = lambda self : None;
    def getAxisName(self, *args):
        """getAxisName(IAxisInfo self, int axis, ConstString name) -> bool"""
        return _yarp.IAxisInfo_getAxisName(self, *args)

IAxisInfo_swigregister = _yarp.IAxisInfo_swigregister
IAxisInfo_swigregister(IAxisInfo)

class Pid(_object):
    """Proxy of C++ yarp::dev::Pid class"""
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, Pid, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, Pid, name)
    __repr__ = _swig_repr
    __swig_setmethods__["kp"] = _yarp.Pid_kp_set
    __swig_getmethods__["kp"] = _yarp.Pid_kp_get
    if _newclass:kp = _swig_property(_yarp.Pid_kp_get, _yarp.Pid_kp_set)
    __swig_setmethods__["kd"] = _yarp.Pid_kd_set
    __swig_getmethods__["kd"] = _yarp.Pid_kd_get
    if _newclass:kd = _swig_property(_yarp.Pid_kd_get, _yarp.Pid_kd_set)
    __swig_setmethods__["ki"] = _yarp.Pid_ki_set
    __swig_getmethods__["ki"] = _yarp.Pid_ki_get
    if _newclass:ki = _swig_property(_yarp.Pid_ki_get, _yarp.Pid_ki_set)
    __swig_setmethods__["max_int"] = _yarp.Pid_max_int_set
    __swig_getmethods__["max_int"] = _yarp.Pid_max_int_get
    if _newclass:max_int = _swig_property(_yarp.Pid_max_int_get, _yarp.Pid_max_int_set)
    __swig_setmethods__["scale"] = _yarp.Pid_scale_set
    __swig_getmethods__["scale"] = _yarp.Pid_scale_get
    if _newclass:scale = _swig_property(_yarp.Pid_scale_get, _yarp.Pid_scale_set)
    __swig_setmethods__["max_output"] = _yarp.Pid_max_output_set
    __swig_getmethods__["max_output"] = _yarp.Pid_max_output_get
    if _newclass:max_output = _swig_property(_yarp.Pid_max_output_get, _yarp.Pid_max_output_set)
    __swig_setmethods__["offset"] = _yarp.Pid_offset_set
    __swig_getmethods__["offset"] = _yarp.Pid_offset_get
    if _newclass:offset = _swig_property(_yarp.Pid_offset_get, _yarp.Pid_offset_set)
    __swig_setmethods__["stiction_up_val"] = _yarp.Pid_stiction_up_val_set
    __swig_getmethods__["stiction_up_val"] = _yarp.Pid_stiction_up_val_get
    if _newclass:stiction_up_val = _swig_property(_yarp.Pid_stiction_up_val_get, _yarp.Pid_stiction_up_val_set)
    __swig_setmethods__["stiction_down_val"] = _yarp.Pid_stiction_down_val_set
    __swig_getmethods__["stiction_down_val"] = _yarp.Pid_stiction_down_val_get
    if _newclass:stiction_down_val = _swig_property(_yarp.Pid_stiction_down_val_get, _yarp.Pid_stiction_down_val_set)
    __swig_setmethods__["kff"] = _yarp.Pid_kff_set
    __swig_getmethods__["kff"] = _yarp.Pid_kff_get
    if _newclass:kff = _swig_property(_yarp.Pid_kff_get, _yarp.Pid_kff_set)
    __swig_destroy__ = _yarp.delete_Pid
    __del__ = lambda self : None;
    def __init__(self, *args): 
        """
        __init__(yarp::dev::Pid self) -> Pid
        __init__(yarp::dev::Pid self, double p, double d, double i, double intm, double sc, double omax) -> Pid
        __init__(yarp::dev::Pid self, double kp, double kd, double ki, double int_max, double scale, double out_max, double st_up, 
            double st_down, double kff) -> Pid
        """
        this = _yarp.new_Pid(*args)
        try: self.this.append(this)
        except: self.this = this
    def setMaxInt(self, *args):
        """setMaxInt(Pid self, double m)"""
        return _yarp.Pid_setMaxInt(self, *args)

    def setMaxOut(self, *args):
        """setMaxOut(Pid self, double m)"""
        return _yarp.Pid_setMaxOut(self, *args)

    def setStictionValues(self, *args):
        """setStictionValues(Pid self, double up_value, double down_value)"""
        return _yarp.Pid_setStictionValues(self, *args)

    def setKff(self, *args):
        """setKff(Pid self, double ff)"""
        return _yarp.Pid_setKff(self, *args)

Pid_swigregister = _yarp.Pid_swigregister
Pid_swigregister(Pid)

class CartesianEventParameters(_object):
    """Proxy of C++ yarp::dev::CartesianEventParameters class"""
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, CartesianEventParameters, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, CartesianEventParameters, name)
    __repr__ = _swig_repr
    __swig_setmethods__["type"] = _yarp.CartesianEventParameters_type_set
    __swig_getmethods__["type"] = _yarp.CartesianEventParameters_type_get
    if _newclass:type = _swig_property(_yarp.CartesianEventParameters_type_get, _yarp.CartesianEventParameters_type_set)
    __swig_setmethods__["motionOngoingCheckPoint"] = _yarp.CartesianEventParameters_motionOngoingCheckPoint_set
    __swig_getmethods__["motionOngoingCheckPoint"] = _yarp.CartesianEventParameters_motionOngoingCheckPoint_get
    if _newclass:motionOngoingCheckPoint = _swig_property(_yarp.CartesianEventParameters_motionOngoingCheckPoint_get, _yarp.CartesianEventParameters_motionOngoingCheckPoint_set)
    def __init__(self): 
        """__init__(yarp::dev::CartesianEventParameters self) -> CartesianEventParameters"""
        this = _yarp.new_CartesianEventParameters()
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _yarp.delete_CartesianEventParameters
    __del__ = lambda self : None;
CartesianEventParameters_swigregister = _yarp.CartesianEventParameters_swigregister
CartesianEventParameters_swigregister(CartesianEventParameters)

class CartesianEventVariables(_object):
    """Proxy of C++ yarp::dev::CartesianEventVariables class"""
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, CartesianEventVariables, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, CartesianEventVariables, name)
    __repr__ = _swig_repr
    __swig_setmethods__["type"] = _yarp.CartesianEventVariables_type_set
    __swig_getmethods__["type"] = _yarp.CartesianEventVariables_type_get
    if _newclass:type = _swig_property(_yarp.CartesianEventVariables_type_get, _yarp.CartesianEventVariables_type_set)
    __swig_setmethods__["time"] = _yarp.CartesianEventVariables_time_set
    __swig_getmethods__["time"] = _yarp.CartesianEventVariables_time_get
    if _newclass:time = _swig_property(_yarp.CartesianEventVariables_time_get, _yarp.CartesianEventVariables_time_set)
    __swig_setmethods__["motionOngoingCheckPoint"] = _yarp.CartesianEventVariables_motionOngoingCheckPoint_set
    __swig_getmethods__["motionOngoingCheckPoint"] = _yarp.CartesianEventVariables_motionOngoingCheckPoint_get
    if _newclass:motionOngoingCheckPoint = _swig_property(_yarp.CartesianEventVariables_motionOngoingCheckPoint_get, _yarp.CartesianEventVariables_motionOngoingCheckPoint_set)
    def __init__(self): 
        """__init__(yarp::dev::CartesianEventVariables self) -> CartesianEventVariables"""
        this = _yarp.new_CartesianEventVariables()
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _yarp.delete_CartesianEventVariables
    __del__ = lambda self : None;
CartesianEventVariables_swigregister = _yarp.CartesianEventVariables_swigregister
CartesianEventVariables_swigregister(CartesianEventVariables)

class CartesianEvent(_object):
    """Proxy of C++ yarp::dev::CartesianEvent class"""
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, CartesianEvent, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, CartesianEvent, name)
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_setmethods__["cartesianEventParameters"] = _yarp.CartesianEvent_cartesianEventParameters_set
    __swig_getmethods__["cartesianEventParameters"] = _yarp.CartesianEvent_cartesianEventParameters_get
    if _newclass:cartesianEventParameters = _swig_property(_yarp.CartesianEvent_cartesianEventParameters_get, _yarp.CartesianEvent_cartesianEventParameters_set)
    __swig_setmethods__["cartesianEventVariables"] = _yarp.CartesianEvent_cartesianEventVariables_set
    __swig_getmethods__["cartesianEventVariables"] = _yarp.CartesianEvent_cartesianEventVariables_get
    if _newclass:cartesianEventVariables = _swig_property(_yarp.CartesianEvent_cartesianEventVariables_get, _yarp.CartesianEvent_cartesianEventVariables_set)
    def cartesianEventCallback(self):
        """cartesianEventCallback(CartesianEvent self)"""
        return _yarp.CartesianEvent_cartesianEventCallback(self)

    __swig_destroy__ = _yarp.delete_CartesianEvent
    __del__ = lambda self : None;
CartesianEvent_swigregister = _yarp.CartesianEvent_swigregister
CartesianEvent_swigregister(CartesianEvent)

class ICartesianControl(_object):
    """Proxy of C++ yarp::dev::ICartesianControl class"""
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, ICartesianControl, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, ICartesianControl, name)
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _yarp.delete_ICartesianControl
    __del__ = lambda self : None;
    def setTrackingMode(self, *args):
        """setTrackingMode(ICartesianControl self, bool const f) -> bool"""
        return _yarp.ICartesianControl_setTrackingMode(self, *args)

    def getTrackingMode(self, *args):
        """getTrackingMode(ICartesianControl self, bool * f) -> bool"""
        return _yarp.ICartesianControl_getTrackingMode(self, *args)

    def setReferenceMode(self, *args):
        """setReferenceMode(ICartesianControl self, bool const f) -> bool"""
        return _yarp.ICartesianControl_setReferenceMode(self, *args)

    def getReferenceMode(self, *args):
        """getReferenceMode(ICartesianControl self, bool * f) -> bool"""
        return _yarp.ICartesianControl_getReferenceMode(self, *args)

    def getPose(self, *args):
        """
        getPose(ICartesianControl self, Vector x, Vector o, Stamp stamp=None) -> bool
        getPose(ICartesianControl self, Vector x, Vector o) -> bool
        getPose(ICartesianControl self, int const axis, Vector x, Vector o, Stamp stamp=None) -> bool
        getPose(ICartesianControl self, int const axis, Vector x, Vector o) -> bool
        """
        return _yarp.ICartesianControl_getPose(self, *args)

    def goToPose(self, *args):
        """
        goToPose(ICartesianControl self, Vector xd, Vector od, double const t=0.0) -> bool
        goToPose(ICartesianControl self, Vector xd, Vector od) -> bool
        """
        return _yarp.ICartesianControl_goToPose(self, *args)

    def goToPosition(self, *args):
        """
        goToPosition(ICartesianControl self, Vector xd, double const t=0.0) -> bool
        goToPosition(ICartesianControl self, Vector xd) -> bool
        """
        return _yarp.ICartesianControl_goToPosition(self, *args)

    def goToPoseSync(self, *args):
        """
        goToPoseSync(ICartesianControl self, Vector xd, Vector od, double const t=0.0) -> bool
        goToPoseSync(ICartesianControl self, Vector xd, Vector od) -> bool
        """
        return _yarp.ICartesianControl_goToPoseSync(self, *args)

    def goToPositionSync(self, *args):
        """
        goToPositionSync(ICartesianControl self, Vector xd, double const t=0.0) -> bool
        goToPositionSync(ICartesianControl self, Vector xd) -> bool
        """
        return _yarp.ICartesianControl_goToPositionSync(self, *args)

    def getDesired(self, *args):
        """getDesired(ICartesianControl self, Vector xdhat, Vector odhat, Vector qdhat) -> bool"""
        return _yarp.ICartesianControl_getDesired(self, *args)

    def askForPose(self, *args):
        """
        askForPose(ICartesianControl self, Vector xd, Vector od, Vector xdhat, Vector odhat, Vector qdhat) -> bool
        askForPose(ICartesianControl self, Vector q0, Vector xd, Vector od, Vector xdhat, Vector odhat, Vector qdhat) -> bool
        """
        return _yarp.ICartesianControl_askForPose(self, *args)

    def askForPosition(self, *args):
        """
        askForPosition(ICartesianControl self, Vector xd, Vector xdhat, Vector odhat, Vector qdhat) -> bool
        askForPosition(ICartesianControl self, Vector q0, Vector xd, Vector xdhat, Vector odhat, Vector qdhat) -> bool
        """
        return _yarp.ICartesianControl_askForPosition(self, *args)

    def getDOF(self, *args):
        """getDOF(ICartesianControl self, Vector curDof) -> bool"""
        return _yarp.ICartesianControl_getDOF(self, *args)

    def setDOF(self, *args):
        """setDOF(ICartesianControl self, Vector newDof, Vector curDof) -> bool"""
        return _yarp.ICartesianControl_setDOF(self, *args)

    def getRestPos(self, *args):
        """getRestPos(ICartesianControl self, Vector curRestPos) -> bool"""
        return _yarp.ICartesianControl_getRestPos(self, *args)

    def setRestPos(self, *args):
        """setRestPos(ICartesianControl self, Vector newRestPos, Vector curRestPos) -> bool"""
        return _yarp.ICartesianControl_setRestPos(self, *args)

    def getRestWeights(self, *args):
        """getRestWeights(ICartesianControl self, Vector curRestWeights) -> bool"""
        return _yarp.ICartesianControl_getRestWeights(self, *args)

    def setRestWeights(self, *args):
        """setRestWeights(ICartesianControl self, Vector newRestWeights, Vector curRestWeights) -> bool"""
        return _yarp.ICartesianControl_setRestWeights(self, *args)

    def getLimits(self, *args):
        """getLimits(ICartesianControl self, int const axis, double * min, double * max) -> bool"""
        return _yarp.ICartesianControl_getLimits(self, *args)

    def setLimits(self, *args):
        """setLimits(ICartesianControl self, int const axis, double const min, double const max) -> bool"""
        return _yarp.ICartesianControl_setLimits(self, *args)

    def getTrajTime(self, *args):
        """getTrajTime(ICartesianControl self, double * t) -> bool"""
        return _yarp.ICartesianControl_getTrajTime(self, *args)

    def setTrajTime(self, *args):
        """setTrajTime(ICartesianControl self, double const t) -> bool"""
        return _yarp.ICartesianControl_setTrajTime(self, *args)

    def getInTargetTol(self, *args):
        """getInTargetTol(ICartesianControl self, double * tol) -> bool"""
        return _yarp.ICartesianControl_getInTargetTol(self, *args)

    def setInTargetTol(self, *args):
        """setInTargetTol(ICartesianControl self, double const tol) -> bool"""
        return _yarp.ICartesianControl_setInTargetTol(self, *args)

    def getJointsVelocities(self, *args):
        """getJointsVelocities(ICartesianControl self, Vector qdot) -> bool"""
        return _yarp.ICartesianControl_getJointsVelocities(self, *args)

    def getTaskVelocities(self, *args):
        """getTaskVelocities(ICartesianControl self, Vector xdot, Vector odot) -> bool"""
        return _yarp.ICartesianControl_getTaskVelocities(self, *args)

    def setTaskVelocities(self, *args):
        """setTaskVelocities(ICartesianControl self, Vector xdot, Vector odot) -> bool"""
        return _yarp.ICartesianControl_setTaskVelocities(self, *args)

    def attachTipFrame(self, *args):
        """attachTipFrame(ICartesianControl self, Vector x, Vector o) -> bool"""
        return _yarp.ICartesianControl_attachTipFrame(self, *args)

    def getTipFrame(self, *args):
        """getTipFrame(ICartesianControl self, Vector x, Vector o) -> bool"""
        return _yarp.ICartesianControl_getTipFrame(self, *args)

    def removeTipFrame(self):
        """removeTipFrame(ICartesianControl self) -> bool"""
        return _yarp.ICartesianControl_removeTipFrame(self)

    def waitMotionDone(self, period=0.1, timeout=0.0):
        """
        waitMotionDone(ICartesianControl self, double const period=0.1, double const timeout=0.0) -> bool
        waitMotionDone(ICartesianControl self, double const period=0.1) -> bool
        waitMotionDone(ICartesianControl self) -> bool
        """
        return _yarp.ICartesianControl_waitMotionDone(self, period, timeout)

    def stopControl(self):
        """stopControl(ICartesianControl self) -> bool"""
        return _yarp.ICartesianControl_stopControl(self)

    def storeContext(self, *args):
        """storeContext(ICartesianControl self, int * id) -> bool"""
        return _yarp.ICartesianControl_storeContext(self, *args)

    def restoreContext(self, *args):
        """restoreContext(ICartesianControl self, int const id) -> bool"""
        return _yarp.ICartesianControl_restoreContext(self, *args)

    def deleteContext(self, *args):
        """deleteContext(ICartesianControl self, int const id) -> bool"""
        return _yarp.ICartesianControl_deleteContext(self, *args)

    def getInfo(self, *args):
        """getInfo(ICartesianControl self, Bottle info) -> bool"""
        return _yarp.ICartesianControl_getInfo(self, *args)

    def registerEvent(self, *args):
        """registerEvent(ICartesianControl self, CartesianEvent event) -> bool"""
        return _yarp.ICartesianControl_registerEvent(self, *args)

    def unregisterEvent(self, *args):
        """unregisterEvent(ICartesianControl self, CartesianEvent event) -> bool"""
        return _yarp.ICartesianControl_unregisterEvent(self, *args)

    def tweakSet(self, *args):
        """tweakSet(ICartesianControl self, Bottle options) -> bool"""
        return _yarp.ICartesianControl_tweakSet(self, *args)

    def tweakGet(self, *args):
        """tweakGet(ICartesianControl self, Bottle options) -> bool"""
        return _yarp.ICartesianControl_tweakGet(self, *args)

    def checkMotionDone(self, *args):
        """
        checkMotionDone(ICartesianControl self, bool * f) -> bool
        checkMotionDone(ICartesianControl self, BVector flag) -> bool
        checkMotionDone(ICartesianControl self) -> bool
        """
        return _yarp.ICartesianControl_checkMotionDone(self, *args)

    def isMotionDone(self):
        """isMotionDone(ICartesianControl self) -> bool"""
        return _yarp.ICartesianControl_isMotionDone(self)

ICartesianControl_swigregister = _yarp.ICartesianControl_swigregister
ICartesianControl_swigregister(ICartesianControl)

class GazeEventParameters(_object):
    """Proxy of C++ yarp::dev::GazeEventParameters class"""
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, GazeEventParameters, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, GazeEventParameters, name)
    __repr__ = _swig_repr
    __swig_setmethods__["type"] = _yarp.GazeEventParameters_type_set
    __swig_getmethods__["type"] = _yarp.GazeEventParameters_type_get
    if _newclass:type = _swig_property(_yarp.GazeEventParameters_type_get, _yarp.GazeEventParameters_type_set)
    __swig_setmethods__["motionOngoingCheckPoint"] = _yarp.GazeEventParameters_motionOngoingCheckPoint_set
    __swig_getmethods__["motionOngoingCheckPoint"] = _yarp.GazeEventParameters_motionOngoingCheckPoint_get
    if _newclass:motionOngoingCheckPoint = _swig_property(_yarp.GazeEventParameters_motionOngoingCheckPoint_get, _yarp.GazeEventParameters_motionOngoingCheckPoint_set)
    def __init__(self): 
        """__init__(yarp::dev::GazeEventParameters self) -> GazeEventParameters"""
        this = _yarp.new_GazeEventParameters()
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _yarp.delete_GazeEventParameters
    __del__ = lambda self : None;
GazeEventParameters_swigregister = _yarp.GazeEventParameters_swigregister
GazeEventParameters_swigregister(GazeEventParameters)

class GazeEventVariables(_object):
    """Proxy of C++ yarp::dev::GazeEventVariables class"""
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, GazeEventVariables, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, GazeEventVariables, name)
    __repr__ = _swig_repr
    __swig_setmethods__["type"] = _yarp.GazeEventVariables_type_set
    __swig_getmethods__["type"] = _yarp.GazeEventVariables_type_get
    if _newclass:type = _swig_property(_yarp.GazeEventVariables_type_get, _yarp.GazeEventVariables_type_set)
    __swig_setmethods__["time"] = _yarp.GazeEventVariables_time_set
    __swig_getmethods__["time"] = _yarp.GazeEventVariables_time_get
    if _newclass:time = _swig_property(_yarp.GazeEventVariables_time_get, _yarp.GazeEventVariables_time_set)
    __swig_setmethods__["motionOngoingCheckPoint"] = _yarp.GazeEventVariables_motionOngoingCheckPoint_set
    __swig_getmethods__["motionOngoingCheckPoint"] = _yarp.GazeEventVariables_motionOngoingCheckPoint_get
    if _newclass:motionOngoingCheckPoint = _swig_property(_yarp.GazeEventVariables_motionOngoingCheckPoint_get, _yarp.GazeEventVariables_motionOngoingCheckPoint_set)
    def __init__(self): 
        """__init__(yarp::dev::GazeEventVariables self) -> GazeEventVariables"""
        this = _yarp.new_GazeEventVariables()
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _yarp.delete_GazeEventVariables
    __del__ = lambda self : None;
GazeEventVariables_swigregister = _yarp.GazeEventVariables_swigregister
GazeEventVariables_swigregister(GazeEventVariables)

class GazeEvent(_object):
    """Proxy of C++ yarp::dev::GazeEvent class"""
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, GazeEvent, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, GazeEvent, name)
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_setmethods__["gazeEventParameters"] = _yarp.GazeEvent_gazeEventParameters_set
    __swig_getmethods__["gazeEventParameters"] = _yarp.GazeEvent_gazeEventParameters_get
    if _newclass:gazeEventParameters = _swig_property(_yarp.GazeEvent_gazeEventParameters_get, _yarp.GazeEvent_gazeEventParameters_set)
    __swig_setmethods__["gazeEventVariables"] = _yarp.GazeEvent_gazeEventVariables_set
    __swig_getmethods__["gazeEventVariables"] = _yarp.GazeEvent_gazeEventVariables_get
    if _newclass:gazeEventVariables = _swig_property(_yarp.GazeEvent_gazeEventVariables_get, _yarp.GazeEvent_gazeEventVariables_set)
    def gazeEventCallback(self):
        """gazeEventCallback(GazeEvent self)"""
        return _yarp.GazeEvent_gazeEventCallback(self)

    __swig_destroy__ = _yarp.delete_GazeEvent
    __del__ = lambda self : None;
GazeEvent_swigregister = _yarp.GazeEvent_swigregister
GazeEvent_swigregister(GazeEvent)

class IGazeControl(_object):
    """Proxy of C++ yarp::dev::IGazeControl class"""
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, IGazeControl, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, IGazeControl, name)
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _yarp.delete_IGazeControl
    __del__ = lambda self : None;
    def setTrackingMode(self, *args):
        """setTrackingMode(IGazeControl self, bool const f) -> bool"""
        return _yarp.IGazeControl_setTrackingMode(self, *args)

    def getFixationPoint(self, *args):
        """
        getFixationPoint(IGazeControl self, Vector fp, Stamp stamp=None) -> bool
        getFixationPoint(IGazeControl self, Vector fp) -> bool
        """
        return _yarp.IGazeControl_getFixationPoint(self, *args)

    def getAngles(self, *args):
        """
        getAngles(IGazeControl self, Vector ang, Stamp stamp=None) -> bool
        getAngles(IGazeControl self, Vector ang) -> bool
        """
        return _yarp.IGazeControl_getAngles(self, *args)

    def lookAtFixationPoint(self, *args):
        """lookAtFixationPoint(IGazeControl self, Vector fp) -> bool"""
        return _yarp.IGazeControl_lookAtFixationPoint(self, *args)

    def lookAtAbsAngles(self, *args):
        """lookAtAbsAngles(IGazeControl self, Vector ang) -> bool"""
        return _yarp.IGazeControl_lookAtAbsAngles(self, *args)

    def lookAtRelAngles(self, *args):
        """lookAtRelAngles(IGazeControl self, Vector ang) -> bool"""
        return _yarp.IGazeControl_lookAtRelAngles(self, *args)

    def lookAtMonoPixel(self, *args):
        """
        lookAtMonoPixel(IGazeControl self, int const camSel, Vector px, double const z=1.0) -> bool
        lookAtMonoPixel(IGazeControl self, int const camSel, Vector px) -> bool
        """
        return _yarp.IGazeControl_lookAtMonoPixel(self, *args)

    def lookAtMonoPixelWithVergence(self, *args):
        """lookAtMonoPixelWithVergence(IGazeControl self, int const camSel, Vector px, double const ver) -> bool"""
        return _yarp.IGazeControl_lookAtMonoPixelWithVergence(self, *args)

    def lookAtStereoPixels(self, *args):
        """lookAtStereoPixels(IGazeControl self, Vector pxl, Vector pxr) -> bool"""
        return _yarp.IGazeControl_lookAtStereoPixels(self, *args)

    def getVORGain(self, *args):
        """getVORGain(IGazeControl self, double * gain) -> bool"""
        return _yarp.IGazeControl_getVORGain(self, *args)

    def getOCRGain(self, *args):
        """getOCRGain(IGazeControl self, double * gain) -> bool"""
        return _yarp.IGazeControl_getOCRGain(self, *args)

    def getSaccadesStatus(self, *args):
        """getSaccadesStatus(IGazeControl self, bool * f) -> bool"""
        return _yarp.IGazeControl_getSaccadesStatus(self, *args)

    def getSaccadesInhibitionPeriod(self, *args):
        """getSaccadesInhibitionPeriod(IGazeControl self, double * period) -> bool"""
        return _yarp.IGazeControl_getSaccadesInhibitionPeriod(self, *args)

    def getSaccadesActivationAngle(self, *args):
        """getSaccadesActivationAngle(IGazeControl self, double * angle) -> bool"""
        return _yarp.IGazeControl_getSaccadesActivationAngle(self, *args)

    def getLeftEyePose(self, *args):
        """
        getLeftEyePose(IGazeControl self, Vector x, Vector o, Stamp stamp=None) -> bool
        getLeftEyePose(IGazeControl self, Vector x, Vector o) -> bool
        """
        return _yarp.IGazeControl_getLeftEyePose(self, *args)

    def getRightEyePose(self, *args):
        """
        getRightEyePose(IGazeControl self, Vector x, Vector o, Stamp stamp=None) -> bool
        getRightEyePose(IGazeControl self, Vector x, Vector o) -> bool
        """
        return _yarp.IGazeControl_getRightEyePose(self, *args)

    def getHeadPose(self, *args):
        """
        getHeadPose(IGazeControl self, Vector x, Vector o, Stamp stamp=None) -> bool
        getHeadPose(IGazeControl self, Vector x, Vector o) -> bool
        """
        return _yarp.IGazeControl_getHeadPose(self, *args)

    def get2DPixel(self, *args):
        """get2DPixel(IGazeControl self, int const camSel, Vector x, Vector px) -> bool"""
        return _yarp.IGazeControl_get2DPixel(self, *args)

    def get3DPoint(self, *args):
        """get3DPoint(IGazeControl self, int const camSel, Vector px, double const z, Vector x) -> bool"""
        return _yarp.IGazeControl_get3DPoint(self, *args)

    def get3DPointOnPlane(self, *args):
        """get3DPointOnPlane(IGazeControl self, int const camSel, Vector px, Vector plane, Vector x) -> bool"""
        return _yarp.IGazeControl_get3DPointOnPlane(self, *args)

    def get3DPointFromAngles(self, *args):
        """get3DPointFromAngles(IGazeControl self, int const mode, Vector ang, Vector x) -> bool"""
        return _yarp.IGazeControl_get3DPointFromAngles(self, *args)

    def getAnglesFrom3DPoint(self, *args):
        """getAnglesFrom3DPoint(IGazeControl self, Vector x, Vector ang) -> bool"""
        return _yarp.IGazeControl_getAnglesFrom3DPoint(self, *args)

    def triangulate3DPoint(self, *args):
        """triangulate3DPoint(IGazeControl self, Vector pxl, Vector pxr, Vector x) -> bool"""
        return _yarp.IGazeControl_triangulate3DPoint(self, *args)

    def getJointsDesired(self, *args):
        """getJointsDesired(IGazeControl self, Vector qdes) -> bool"""
        return _yarp.IGazeControl_getJointsDesired(self, *args)

    def getJointsVelocities(self, *args):
        """getJointsVelocities(IGazeControl self, Vector qdot) -> bool"""
        return _yarp.IGazeControl_getJointsVelocities(self, *args)

    def getStereoOptions(self, *args):
        """getStereoOptions(IGazeControl self, Bottle options) -> bool"""
        return _yarp.IGazeControl_getStereoOptions(self, *args)

    def setNeckTrajTime(self, *args):
        """setNeckTrajTime(IGazeControl self, double const t) -> bool"""
        return _yarp.IGazeControl_setNeckTrajTime(self, *args)

    def setEyesTrajTime(self, *args):
        """setEyesTrajTime(IGazeControl self, double const t) -> bool"""
        return _yarp.IGazeControl_setEyesTrajTime(self, *args)

    def setVORGain(self, *args):
        """setVORGain(IGazeControl self, double const gain) -> bool"""
        return _yarp.IGazeControl_setVORGain(self, *args)

    def setOCRGain(self, *args):
        """setOCRGain(IGazeControl self, double const gain) -> bool"""
        return _yarp.IGazeControl_setOCRGain(self, *args)

    def setSaccadesStatus(self, *args):
        """setSaccadesStatus(IGazeControl self, bool const f) -> bool"""
        return _yarp.IGazeControl_setSaccadesStatus(self, *args)

    def setSaccadesInhibitionPeriod(self, *args):
        """setSaccadesInhibitionPeriod(IGazeControl self, double const period) -> bool"""
        return _yarp.IGazeControl_setSaccadesInhibitionPeriod(self, *args)

    def setSaccadesActivationAngle(self, *args):
        """setSaccadesActivationAngle(IGazeControl self, double const angle) -> bool"""
        return _yarp.IGazeControl_setSaccadesActivationAngle(self, *args)

    def setStereoOptions(self, *args):
        """setStereoOptions(IGazeControl self, Bottle options) -> bool"""
        return _yarp.IGazeControl_setStereoOptions(self, *args)

    def bindNeckPitch(self, *args):
        """bindNeckPitch(IGazeControl self, double const min, double const max) -> bool"""
        return _yarp.IGazeControl_bindNeckPitch(self, *args)

    def blockNeckPitch(self, *args):
        """
        blockNeckPitch(IGazeControl self, double const val) -> bool
        blockNeckPitch(IGazeControl self) -> bool
        """
        return _yarp.IGazeControl_blockNeckPitch(self, *args)

    def bindNeckRoll(self, *args):
        """bindNeckRoll(IGazeControl self, double const min, double const max) -> bool"""
        return _yarp.IGazeControl_bindNeckRoll(self, *args)

    def blockNeckRoll(self, *args):
        """
        blockNeckRoll(IGazeControl self, double const val) -> bool
        blockNeckRoll(IGazeControl self) -> bool
        """
        return _yarp.IGazeControl_blockNeckRoll(self, *args)

    def bindNeckYaw(self, *args):
        """bindNeckYaw(IGazeControl self, double const min, double const max) -> bool"""
        return _yarp.IGazeControl_bindNeckYaw(self, *args)

    def blockNeckYaw(self, *args):
        """
        blockNeckYaw(IGazeControl self, double const val) -> bool
        blockNeckYaw(IGazeControl self) -> bool
        """
        return _yarp.IGazeControl_blockNeckYaw(self, *args)

    def blockEyes(self, *args):
        """
        blockEyes(IGazeControl self, double const ver) -> bool
        blockEyes(IGazeControl self) -> bool
        """
        return _yarp.IGazeControl_blockEyes(self, *args)

    def getNeckPitchRange(self, *args):
        """getNeckPitchRange(IGazeControl self, double * min, double * max) -> bool"""
        return _yarp.IGazeControl_getNeckPitchRange(self, *args)

    def getNeckRollRange(self, *args):
        """getNeckRollRange(IGazeControl self, double * min, double * max) -> bool"""
        return _yarp.IGazeControl_getNeckRollRange(self, *args)

    def getNeckYawRange(self, *args):
        """getNeckYawRange(IGazeControl self, double * min, double * max) -> bool"""
        return _yarp.IGazeControl_getNeckYawRange(self, *args)

    def getBlockedVergence(self, *args):
        """getBlockedVergence(IGazeControl self, double * ver) -> bool"""
        return _yarp.IGazeControl_getBlockedVergence(self, *args)

    def clearNeckPitch(self):
        """clearNeckPitch(IGazeControl self) -> bool"""
        return _yarp.IGazeControl_clearNeckPitch(self)

    def clearNeckRoll(self):
        """clearNeckRoll(IGazeControl self) -> bool"""
        return _yarp.IGazeControl_clearNeckRoll(self)

    def clearNeckYaw(self):
        """clearNeckYaw(IGazeControl self) -> bool"""
        return _yarp.IGazeControl_clearNeckYaw(self)

    def clearEyes(self):
        """clearEyes(IGazeControl self) -> bool"""
        return _yarp.IGazeControl_clearEyes(self)

    def getNeckAngleUserTolerance(self, *args):
        """getNeckAngleUserTolerance(IGazeControl self, double * angle) -> bool"""
        return _yarp.IGazeControl_getNeckAngleUserTolerance(self, *args)

    def setNeckAngleUserTolerance(self, *args):
        """setNeckAngleUserTolerance(IGazeControl self, double const angle) -> bool"""
        return _yarp.IGazeControl_setNeckAngleUserTolerance(self, *args)

    def waitMotionDone(self, period=0.1, timeout=0.0):
        """
        waitMotionDone(IGazeControl self, double const period=0.1, double const timeout=0.0) -> bool
        waitMotionDone(IGazeControl self, double const period=0.1) -> bool
        waitMotionDone(IGazeControl self) -> bool
        """
        return _yarp.IGazeControl_waitMotionDone(self, period, timeout)

    def checkSaccadeDone(self, *args):
        """checkSaccadeDone(IGazeControl self, bool * f) -> bool"""
        return _yarp.IGazeControl_checkSaccadeDone(self, *args)

    def waitSaccadeDone(self, period=0.1, timeout=0.0):
        """
        waitSaccadeDone(IGazeControl self, double const period=0.1, double const timeout=0.0) -> bool
        waitSaccadeDone(IGazeControl self, double const period=0.1) -> bool
        waitSaccadeDone(IGazeControl self) -> bool
        """
        return _yarp.IGazeControl_waitSaccadeDone(self, period, timeout)

    def stopControl(self):
        """stopControl(IGazeControl self) -> bool"""
        return _yarp.IGazeControl_stopControl(self)

    def storeContext(self, *args):
        """storeContext(IGazeControl self, int * id) -> bool"""
        return _yarp.IGazeControl_storeContext(self, *args)

    def restoreContext(self, *args):
        """restoreContext(IGazeControl self, int const id) -> bool"""
        return _yarp.IGazeControl_restoreContext(self, *args)

    def deleteContext(self, *args):
        """deleteContext(IGazeControl self, int const id) -> bool"""
        return _yarp.IGazeControl_deleteContext(self, *args)

    def getInfo(self, *args):
        """getInfo(IGazeControl self, Bottle info) -> bool"""
        return _yarp.IGazeControl_getInfo(self, *args)

    def registerEvent(self, *args):
        """registerEvent(IGazeControl self, GazeEvent event) -> bool"""
        return _yarp.IGazeControl_registerEvent(self, *args)

    def unregisterEvent(self, *args):
        """unregisterEvent(IGazeControl self, GazeEvent event) -> bool"""
        return _yarp.IGazeControl_unregisterEvent(self, *args)

    def tweakSet(self, *args):
        """tweakSet(IGazeControl self, Bottle options) -> bool"""
        return _yarp.IGazeControl_tweakSet(self, *args)

    def tweakGet(self, *args):
        """tweakGet(IGazeControl self, Bottle options) -> bool"""
        return _yarp.IGazeControl_tweakGet(self, *args)

    def getTrackingMode(self, *args):
        """
        getTrackingMode(IGazeControl self, bool * f) -> bool
        getTrackingMode(IGazeControl self) -> bool
        """
        return _yarp.IGazeControl_getTrackingMode(self, *args)

    def getNeckTrajTime(self, *args):
        """
        getNeckTrajTime(IGazeControl self, double * t) -> bool
        getNeckTrajTime(IGazeControl self) -> double
        """
        return _yarp.IGazeControl_getNeckTrajTime(self, *args)

    def getEyesTrajTime(self, *args):
        """
        getEyesTrajTime(IGazeControl self, double * t) -> bool
        getEyesTrajTime(IGazeControl self) -> double
        """
        return _yarp.IGazeControl_getEyesTrajTime(self, *args)

    def checkMotionDone(self, *args):
        """
        checkMotionDone(IGazeControl self, bool * f) -> bool
        checkMotionDone(IGazeControl self) -> bool
        """
        return _yarp.IGazeControl_checkMotionDone(self, *args)

IGazeControl_swigregister = _yarp.IGazeControl_swigregister
IGazeControl_swigregister(IGazeControl)

class IPositionControlRaw(_object):
    """Proxy of C++ yarp::dev::IPositionControlRaw class"""
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, IPositionControlRaw, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, IPositionControlRaw, name)
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _yarp.delete_IPositionControlRaw
    __del__ = lambda self : None;
    def getAxes(self, *args):
        """getAxes(IPositionControlRaw self, int * ax) -> bool"""
        return _yarp.IPositionControlRaw_getAxes(self, *args)

    def setPositionModeRaw(self):
        """setPositionModeRaw(IPositionControlRaw self) -> bool"""
        return _yarp.IPositionControlRaw_setPositionModeRaw(self)

    def positionMoveRaw(self, *args):
        """
        positionMoveRaw(IPositionControlRaw self, int j, double ref) -> bool
        positionMoveRaw(IPositionControlRaw self, double const * refs) -> bool
        """
        return _yarp.IPositionControlRaw_positionMoveRaw(self, *args)

    def relativeMoveRaw(self, *args):
        """
        relativeMoveRaw(IPositionControlRaw self, int j, double delta) -> bool
        relativeMoveRaw(IPositionControlRaw self, double const * deltas) -> bool
        """
        return _yarp.IPositionControlRaw_relativeMoveRaw(self, *args)

    def checkMotionDoneRaw(self, *args):
        """
        checkMotionDoneRaw(IPositionControlRaw self, int j, bool * flag) -> bool
        checkMotionDoneRaw(IPositionControlRaw self, bool * flag) -> bool
        """
        return _yarp.IPositionControlRaw_checkMotionDoneRaw(self, *args)

    def setRefSpeedRaw(self, *args):
        """setRefSpeedRaw(IPositionControlRaw self, int j, double sp) -> bool"""
        return _yarp.IPositionControlRaw_setRefSpeedRaw(self, *args)

    def setRefSpeedsRaw(self, *args):
        """setRefSpeedsRaw(IPositionControlRaw self, double const * spds) -> bool"""
        return _yarp.IPositionControlRaw_setRefSpeedsRaw(self, *args)

    def setRefAccelerationRaw(self, *args):
        """setRefAccelerationRaw(IPositionControlRaw self, int j, double acc) -> bool"""
        return _yarp.IPositionControlRaw_setRefAccelerationRaw(self, *args)

    def setRefAccelerationsRaw(self, *args):
        """setRefAccelerationsRaw(IPositionControlRaw self, double const * accs) -> bool"""
        return _yarp.IPositionControlRaw_setRefAccelerationsRaw(self, *args)

    def getRefSpeedRaw(self, *args):
        """getRefSpeedRaw(IPositionControlRaw self, int j, double * ref) -> bool"""
        return _yarp.IPositionControlRaw_getRefSpeedRaw(self, *args)

    def getRefSpeedsRaw(self, *args):
        """getRefSpeedsRaw(IPositionControlRaw self, double * spds) -> bool"""
        return _yarp.IPositionControlRaw_getRefSpeedsRaw(self, *args)

    def getRefAccelerationRaw(self, *args):
        """getRefAccelerationRaw(IPositionControlRaw self, int j, double * acc) -> bool"""
        return _yarp.IPositionControlRaw_getRefAccelerationRaw(self, *args)

    def getRefAccelerationsRaw(self, *args):
        """getRefAccelerationsRaw(IPositionControlRaw self, double * accs) -> bool"""
        return _yarp.IPositionControlRaw_getRefAccelerationsRaw(self, *args)

    def stopRaw(self, *args):
        """
        stopRaw(IPositionControlRaw self, int j) -> bool
        stopRaw(IPositionControlRaw self) -> bool
        """
        return _yarp.IPositionControlRaw_stopRaw(self, *args)

IPositionControlRaw_swigregister = _yarp.IPositionControlRaw_swigregister
IPositionControlRaw_swigregister(IPositionControlRaw)

class IPositionControl(_object):
    """Proxy of C++ yarp::dev::IPositionControl class"""
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, IPositionControl, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, IPositionControl, name)
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _yarp.delete_IPositionControl
    __del__ = lambda self : None;
    def setPositionMode(self):
        """setPositionMode(IPositionControl self) -> bool"""
        return _yarp.IPositionControl_setPositionMode(self)

    def setRefSpeed(self, *args):
        """setRefSpeed(IPositionControl self, int j, double sp) -> bool"""
        return _yarp.IPositionControl_setRefSpeed(self, *args)

    def setRefAcceleration(self, *args):
        """setRefAcceleration(IPositionControl self, int j, double acc) -> bool"""
        return _yarp.IPositionControl_setRefAcceleration(self, *args)

    def setRefAccelerations(self, *args):
        """setRefAccelerations(IPositionControl self, double const * accs) -> bool"""
        return _yarp.IPositionControl_setRefAccelerations(self, *args)

    def stop(self, *args):
        """
        stop(IPositionControl self, int j) -> bool
        stop(IPositionControl self) -> bool
        """
        return _yarp.IPositionControl_stop(self, *args)

    def getAxes(self, *args):
        """
        getAxes(IPositionControl self, int * ax) -> bool
        getAxes(IPositionControl self) -> int
        """
        return _yarp.IPositionControl_getAxes(self, *args)

    def positionMove(self, *args):
        """
        positionMove(IPositionControl self, int j, double ref) -> bool
        positionMove(IPositionControl self, double const * refs) -> bool
        positionMove(IPositionControl self, DVector data) -> bool
        """
        return _yarp.IPositionControl_positionMove(self, *args)

    def relativeMove(self, *args):
        """
        relativeMove(IPositionControl self, int j, double delta) -> bool
        relativeMove(IPositionControl self, double const * deltas) -> bool
        relativeMove(IPositionControl self, DVector data) -> bool
        """
        return _yarp.IPositionControl_relativeMove(self, *args)

    def setRefSpeeds(self, *args):
        """
        setRefSpeeds(IPositionControl self, double const * spds) -> bool
        setRefSpeeds(IPositionControl self, DVector data) -> bool
        """
        return _yarp.IPositionControl_setRefSpeeds(self, *args)

    def getRefSpeed(self, *args):
        """
        getRefSpeed(IPositionControl self, int j, double * ref) -> bool
        getRefSpeed(IPositionControl self, int j, DVector data) -> bool
        """
        return _yarp.IPositionControl_getRefSpeed(self, *args)

    def getRefSpeeds(self, *args):
        """
        getRefSpeeds(IPositionControl self, double * spds) -> bool
        getRefSpeeds(IPositionControl self, DVector data) -> bool
        """
        return _yarp.IPositionControl_getRefSpeeds(self, *args)

    def getRefAcceleration(self, *args):
        """
        getRefAcceleration(IPositionControl self, int j, double * acc) -> bool
        getRefAcceleration(IPositionControl self, int j, DVector data) -> bool
        """
        return _yarp.IPositionControl_getRefAcceleration(self, *args)

    def getRefAccelerations(self, *args):
        """
        getRefAccelerations(IPositionControl self, double * accs) -> bool
        getRefAccelerations(IPositionControl self, DVector data) -> bool
        """
        return _yarp.IPositionControl_getRefAccelerations(self, *args)

    def checkMotionDone(self, *args):
        """
        checkMotionDone(IPositionControl self, int j, bool * flag) -> bool
        checkMotionDone(IPositionControl self, bool * flag) -> bool
        checkMotionDone(IPositionControl self) -> bool
        checkMotionDone(IPositionControl self, BVector flag) -> bool
        checkMotionDone(IPositionControl self, int i, BVector flag) -> bool
        """
        return _yarp.IPositionControl_checkMotionDone(self, *args)

    def isMotionDone(self, *args):
        """
        isMotionDone(IPositionControl self, int i) -> bool
        isMotionDone(IPositionControl self) -> bool
        """
        return _yarp.IPositionControl_isMotionDone(self, *args)

IPositionControl_swigregister = _yarp.IPositionControl_swigregister
IPositionControl_swigregister(IPositionControl)

class IEncodersRaw(_object):
    """Proxy of C++ yarp::dev::IEncodersRaw class"""
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, IEncodersRaw, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, IEncodersRaw, name)
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _yarp.delete_IEncodersRaw
    __del__ = lambda self : None;
    def getAxes(self, *args):
        """getAxes(IEncodersRaw self, int * ax) -> bool"""
        return _yarp.IEncodersRaw_getAxes(self, *args)

    def resetEncoderRaw(self, *args):
        """resetEncoderRaw(IEncodersRaw self, int j) -> bool"""
        return _yarp.IEncodersRaw_resetEncoderRaw(self, *args)

    def resetEncodersRaw(self):
        """resetEncodersRaw(IEncodersRaw self) -> bool"""
        return _yarp.IEncodersRaw_resetEncodersRaw(self)

    def setEncoderRaw(self, *args):
        """setEncoderRaw(IEncodersRaw self, int j, double val) -> bool"""
        return _yarp.IEncodersRaw_setEncoderRaw(self, *args)

    def setEncodersRaw(self, *args):
        """setEncodersRaw(IEncodersRaw self, double const * vals) -> bool"""
        return _yarp.IEncodersRaw_setEncodersRaw(self, *args)

    def getEncoderRaw(self, *args):
        """getEncoderRaw(IEncodersRaw self, int j, double * v) -> bool"""
        return _yarp.IEncodersRaw_getEncoderRaw(self, *args)

    def getEncodersRaw(self, *args):
        """getEncodersRaw(IEncodersRaw self, double * encs) -> bool"""
        return _yarp.IEncodersRaw_getEncodersRaw(self, *args)

    def getEncoderSpeedRaw(self, *args):
        """getEncoderSpeedRaw(IEncodersRaw self, int j, double * sp) -> bool"""
        return _yarp.IEncodersRaw_getEncoderSpeedRaw(self, *args)

    def getEncoderSpeedsRaw(self, *args):
        """getEncoderSpeedsRaw(IEncodersRaw self, double * spds) -> bool"""
        return _yarp.IEncodersRaw_getEncoderSpeedsRaw(self, *args)

    def getEncoderAccelerationRaw(self, *args):
        """getEncoderAccelerationRaw(IEncodersRaw self, int j, double * spds) -> bool"""
        return _yarp.IEncodersRaw_getEncoderAccelerationRaw(self, *args)

    def getEncoderAccelerationsRaw(self, *args):
        """getEncoderAccelerationsRaw(IEncodersRaw self, double * accs) -> bool"""
        return _yarp.IEncodersRaw_getEncoderAccelerationsRaw(self, *args)

IEncodersRaw_swigregister = _yarp.IEncodersRaw_swigregister
IEncodersRaw_swigregister(IEncodersRaw)

class IEncoders(_object):
    """Proxy of C++ yarp::dev::IEncoders class"""
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, IEncoders, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, IEncoders, name)
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _yarp.delete_IEncoders
    __del__ = lambda self : None;
    def resetEncoder(self, *args):
        """resetEncoder(IEncoders self, int j) -> bool"""
        return _yarp.IEncoders_resetEncoder(self, *args)

    def resetEncoders(self):
        """resetEncoders(IEncoders self) -> bool"""
        return _yarp.IEncoders_resetEncoders(self)

    def setEncoder(self, *args):
        """setEncoder(IEncoders self, int j, double val) -> bool"""
        return _yarp.IEncoders_setEncoder(self, *args)

    def getAxes(self, *args):
        """
        getAxes(IEncoders self, int * ax) -> bool
        getAxes(IEncoders self) -> int
        """
        return _yarp.IEncoders_getAxes(self, *args)

    def setEncoders(self, *args):
        """
        setEncoders(IEncoders self, double const * vals) -> bool
        setEncoders(IEncoders self, DVector data) -> bool
        """
        return _yarp.IEncoders_setEncoders(self, *args)

    def getEncoder(self, *args):
        """
        getEncoder(IEncoders self, int j, double * v) -> bool
        getEncoder(IEncoders self, int j) -> double
        """
        return _yarp.IEncoders_getEncoder(self, *args)

    def getEncoders(self, *args):
        """
        getEncoders(IEncoders self, double * encs) -> bool
        getEncoders(IEncoders self, DVector data) -> bool
        """
        return _yarp.IEncoders_getEncoders(self, *args)

    def getEncoderSpeed(self, *args):
        """
        getEncoderSpeed(IEncoders self, int j, double * sp) -> bool
        getEncoderSpeed(IEncoders self, int j) -> double
        """
        return _yarp.IEncoders_getEncoderSpeed(self, *args)

    def getEncoderSpeeds(self, *args):
        """
        getEncoderSpeeds(IEncoders self, double * spds) -> bool
        getEncoderSpeeds(IEncoders self, DVector data) -> bool
        """
        return _yarp.IEncoders_getEncoderSpeeds(self, *args)

    def getEncoderAcceleration(self, *args):
        """
        getEncoderAcceleration(IEncoders self, int j, double * spds) -> bool
        getEncoderAcceleration(IEncoders self, int j) -> double
        """
        return _yarp.IEncoders_getEncoderAcceleration(self, *args)

    def getEncoderAccelerations(self, *args):
        """
        getEncoderAccelerations(IEncoders self, double * accs) -> bool
        getEncoderAccelerations(IEncoders self, DVector data) -> bool
        """
        return _yarp.IEncoders_getEncoderAccelerations(self, *args)

IEncoders_swigregister = _yarp.IEncoders_swigregister
IEncoders_swigregister(IEncoders)

class ICalibrator(_object):
    """Proxy of C++ yarp::dev::ICalibrator class"""
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, ICalibrator, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, ICalibrator, name)
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _yarp.delete_ICalibrator
    __del__ = lambda self : None;
    def calibrate(self, *args):
        """calibrate(ICalibrator self, DeviceDriver dd) -> bool"""
        return _yarp.ICalibrator_calibrate(self, *args)

    def park(self, *args):
        """
        park(ICalibrator self, DeviceDriver dd, bool wait=True) -> bool
        park(ICalibrator self, DeviceDriver dd) -> bool
        """
        return _yarp.ICalibrator_park(self, *args)

    def quitCalibrate(self):
        """quitCalibrate(ICalibrator self) -> bool"""
        return _yarp.ICalibrator_quitCalibrate(self)

    def quitPark(self):
        """quitPark(ICalibrator self) -> bool"""
        return _yarp.ICalibrator_quitPark(self)

ICalibrator_swigregister = _yarp.ICalibrator_swigregister
ICalibrator_swigregister(ICalibrator)

class IControlMode(_object):
    """Proxy of C++ yarp::dev::IControlMode class"""
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, IControlMode, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, IControlMode, name)
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _yarp.delete_IControlMode
    __del__ = lambda self : None;
    def setPositionMode(self, *args):
        """setPositionMode(IControlMode self, int j) -> bool"""
        return _yarp.IControlMode_setPositionMode(self, *args)

    def setVelocityMode(self, *args):
        """setVelocityMode(IControlMode self, int j) -> bool"""
        return _yarp.IControlMode_setVelocityMode(self, *args)

    def setTorqueMode(self, *args):
        """setTorqueMode(IControlMode self, int j) -> bool"""
        return _yarp.IControlMode_setTorqueMode(self, *args)

    def setImpedancePositionMode(self, *args):
        """setImpedancePositionMode(IControlMode self, int j) -> bool"""
        return _yarp.IControlMode_setImpedancePositionMode(self, *args)

    def setImpedanceVelocityMode(self, *args):
        """setImpedanceVelocityMode(IControlMode self, int j) -> bool"""
        return _yarp.IControlMode_setImpedanceVelocityMode(self, *args)

    def setOpenLoopMode(self, *args):
        """setOpenLoopMode(IControlMode self, int j) -> bool"""
        return _yarp.IControlMode_setOpenLoopMode(self, *args)

    def getControlMode(self, *args):
        """getControlMode(IControlMode self, int j, int * mode) -> bool"""
        return _yarp.IControlMode_getControlMode(self, *args)

    def getControlModes(self, *args):
        """getControlModes(IControlMode self, int * modes) -> bool"""
        return _yarp.IControlMode_getControlModes(self, *args)

IControlMode_swigregister = _yarp.IControlMode_swigregister
IControlMode_swigregister(IControlMode)

class IControlModeRaw(_object):
    """Proxy of C++ yarp::dev::IControlModeRaw class"""
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, IControlModeRaw, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, IControlModeRaw, name)
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _yarp.delete_IControlModeRaw
    __del__ = lambda self : None;
    def setPositionModeRaw(self, *args):
        """setPositionModeRaw(IControlModeRaw self, int j) -> bool"""
        return _yarp.IControlModeRaw_setPositionModeRaw(self, *args)

    def setVelocityModeRaw(self, *args):
        """setVelocityModeRaw(IControlModeRaw self, int j) -> bool"""
        return _yarp.IControlModeRaw_setVelocityModeRaw(self, *args)

    def setTorqueModeRaw(self, *args):
        """setTorqueModeRaw(IControlModeRaw self, int j) -> bool"""
        return _yarp.IControlModeRaw_setTorqueModeRaw(self, *args)

    def setImpedancePositionModeRaw(self, *args):
        """setImpedancePositionModeRaw(IControlModeRaw self, int j) -> bool"""
        return _yarp.IControlModeRaw_setImpedancePositionModeRaw(self, *args)

    def setImpedanceVelocityModeRaw(self, *args):
        """setImpedanceVelocityModeRaw(IControlModeRaw self, int j) -> bool"""
        return _yarp.IControlModeRaw_setImpedanceVelocityModeRaw(self, *args)

    def setOpenLoopModeRaw(self, *args):
        """setOpenLoopModeRaw(IControlModeRaw self, int j) -> bool"""
        return _yarp.IControlModeRaw_setOpenLoopModeRaw(self, *args)

    def getControlModeRaw(self, *args):
        """getControlModeRaw(IControlModeRaw self, int j, int * mode) -> bool"""
        return _yarp.IControlModeRaw_getControlModeRaw(self, *args)

    def getControlModesRaw(self, *args):
        """getControlModesRaw(IControlModeRaw self, int * modes) -> bool"""
        return _yarp.IControlModeRaw_getControlModesRaw(self, *args)

IControlModeRaw_swigregister = _yarp.IControlModeRaw_swigregister
IControlModeRaw_swigregister(IControlModeRaw)

class ITorqueControl(_object):
    """Proxy of C++ yarp::dev::ITorqueControl class"""
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, ITorqueControl, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, ITorqueControl, name)
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _yarp.delete_ITorqueControl
    __del__ = lambda self : None;
    def getAxes(self, *args):
        """getAxes(ITorqueControl self, int * ax) -> bool"""
        return _yarp.ITorqueControl_getAxes(self, *args)

    def setTorqueMode(self):
        """setTorqueMode(ITorqueControl self) -> bool"""
        return _yarp.ITorqueControl_setTorqueMode(self)

    def getRefTorques(self, *args):
        """getRefTorques(ITorqueControl self, double * t) -> bool"""
        return _yarp.ITorqueControl_getRefTorques(self, *args)

    def getRefTorque(self, *args):
        """getRefTorque(ITorqueControl self, int j, double * t) -> bool"""
        return _yarp.ITorqueControl_getRefTorque(self, *args)

    def setRefTorques(self, *args):
        """setRefTorques(ITorqueControl self, double const * t) -> bool"""
        return _yarp.ITorqueControl_setRefTorques(self, *args)

    def setRefTorque(self, *args):
        """setRefTorque(ITorqueControl self, int j, double t) -> bool"""
        return _yarp.ITorqueControl_setRefTorque(self, *args)

    def getBemfParam(self, *args):
        """getBemfParam(ITorqueControl self, int j, double * bemf) -> bool"""
        return _yarp.ITorqueControl_getBemfParam(self, *args)

    def setBemfParam(self, *args):
        """setBemfParam(ITorqueControl self, int j, double bemf) -> bool"""
        return _yarp.ITorqueControl_setBemfParam(self, *args)

    def setTorquePid(self, *args):
        """setTorquePid(ITorqueControl self, int j, Pid pid) -> bool"""
        return _yarp.ITorqueControl_setTorquePid(self, *args)

    def getTorque(self, *args):
        """getTorque(ITorqueControl self, int j, double * t) -> bool"""
        return _yarp.ITorqueControl_getTorque(self, *args)

    def getTorques(self, *args):
        """getTorques(ITorqueControl self, double * t) -> bool"""
        return _yarp.ITorqueControl_getTorques(self, *args)

    def getTorqueRange(self, *args):
        """getTorqueRange(ITorqueControl self, int j, double * min, double * max) -> bool"""
        return _yarp.ITorqueControl_getTorqueRange(self, *args)

    def getTorqueRanges(self, *args):
        """getTorqueRanges(ITorqueControl self, double * min, double * max) -> bool"""
        return _yarp.ITorqueControl_getTorqueRanges(self, *args)

    def setTorquePids(self, *args):
        """setTorquePids(ITorqueControl self, Pid pids) -> bool"""
        return _yarp.ITorqueControl_setTorquePids(self, *args)

    def setTorqueErrorLimit(self, *args):
        """setTorqueErrorLimit(ITorqueControl self, int j, double limit) -> bool"""
        return _yarp.ITorqueControl_setTorqueErrorLimit(self, *args)

    def setTorqueErrorLimits(self, *args):
        """setTorqueErrorLimits(ITorqueControl self, double const * limits) -> bool"""
        return _yarp.ITorqueControl_setTorqueErrorLimits(self, *args)

    def getTorqueError(self, *args):
        """getTorqueError(ITorqueControl self, int j, double * err) -> bool"""
        return _yarp.ITorqueControl_getTorqueError(self, *args)

    def getTorqueErrors(self, *args):
        """getTorqueErrors(ITorqueControl self, double * errs) -> bool"""
        return _yarp.ITorqueControl_getTorqueErrors(self, *args)

    def getTorquePidOutput(self, *args):
        """getTorquePidOutput(ITorqueControl self, int j, double * out) -> bool"""
        return _yarp.ITorqueControl_getTorquePidOutput(self, *args)

    def getTorquePidOutputs(self, *args):
        """getTorquePidOutputs(ITorqueControl self, double * outs) -> bool"""
        return _yarp.ITorqueControl_getTorquePidOutputs(self, *args)

    def getTorquePid(self, *args):
        """getTorquePid(ITorqueControl self, int j, Pid pid) -> bool"""
        return _yarp.ITorqueControl_getTorquePid(self, *args)

    def getTorquePids(self, *args):
        """getTorquePids(ITorqueControl self, Pid pids) -> bool"""
        return _yarp.ITorqueControl_getTorquePids(self, *args)

    def getTorqueErrorLimit(self, *args):
        """getTorqueErrorLimit(ITorqueControl self, int j, double * limit) -> bool"""
        return _yarp.ITorqueControl_getTorqueErrorLimit(self, *args)

    def getTorqueErrorLimits(self, *args):
        """getTorqueErrorLimits(ITorqueControl self, double * limits) -> bool"""
        return _yarp.ITorqueControl_getTorqueErrorLimits(self, *args)

    def resetTorquePid(self, *args):
        """resetTorquePid(ITorqueControl self, int j) -> bool"""
        return _yarp.ITorqueControl_resetTorquePid(self, *args)

    def disableTorquePid(self, *args):
        """disableTorquePid(ITorqueControl self, int j) -> bool"""
        return _yarp.ITorqueControl_disableTorquePid(self, *args)

    def enableTorquePid(self, *args):
        """enableTorquePid(ITorqueControl self, int j) -> bool"""
        return _yarp.ITorqueControl_enableTorquePid(self, *args)

    def setTorqueOffset(self, *args):
        """setTorqueOffset(ITorqueControl self, int j, double v) -> bool"""
        return _yarp.ITorqueControl_setTorqueOffset(self, *args)

ITorqueControl_swigregister = _yarp.ITorqueControl_swigregister
ITorqueControl_swigregister(ITorqueControl)

class ITorqueControlRaw(_object):
    """Proxy of C++ yarp::dev::ITorqueControlRaw class"""
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, ITorqueControlRaw, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, ITorqueControlRaw, name)
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _yarp.delete_ITorqueControlRaw
    __del__ = lambda self : None;
    def getAxes(self, *args):
        """getAxes(ITorqueControlRaw self, int * ax) -> bool"""
        return _yarp.ITorqueControlRaw_getAxes(self, *args)

    def setTorqueModeRaw(self):
        """setTorqueModeRaw(ITorqueControlRaw self) -> bool"""
        return _yarp.ITorqueControlRaw_setTorqueModeRaw(self)

    def getTorqueRaw(self, *args):
        """getTorqueRaw(ITorqueControlRaw self, int j, double * t) -> bool"""
        return _yarp.ITorqueControlRaw_getTorqueRaw(self, *args)

    def getTorquesRaw(self, *args):
        """getTorquesRaw(ITorqueControlRaw self, double * t) -> bool"""
        return _yarp.ITorqueControlRaw_getTorquesRaw(self, *args)

    def getTorqueRangeRaw(self, *args):
        """getTorqueRangeRaw(ITorqueControlRaw self, int j, double * min, double * max) -> bool"""
        return _yarp.ITorqueControlRaw_getTorqueRangeRaw(self, *args)

    def getTorqueRangesRaw(self, *args):
        """getTorqueRangesRaw(ITorqueControlRaw self, double * min, double * max) -> bool"""
        return _yarp.ITorqueControlRaw_getTorqueRangesRaw(self, *args)

    def setRefTorquesRaw(self, *args):
        """setRefTorquesRaw(ITorqueControlRaw self, double const * t) -> bool"""
        return _yarp.ITorqueControlRaw_setRefTorquesRaw(self, *args)

    def setRefTorqueRaw(self, *args):
        """setRefTorqueRaw(ITorqueControlRaw self, int j, double t) -> bool"""
        return _yarp.ITorqueControlRaw_setRefTorqueRaw(self, *args)

    def getRefTorquesRaw(self, *args):
        """getRefTorquesRaw(ITorqueControlRaw self, double * t) -> bool"""
        return _yarp.ITorqueControlRaw_getRefTorquesRaw(self, *args)

    def getRefTorqueRaw(self, *args):
        """getRefTorqueRaw(ITorqueControlRaw self, int j, double * t) -> bool"""
        return _yarp.ITorqueControlRaw_getRefTorqueRaw(self, *args)

    def getBemfParamRaw(self, *args):
        """getBemfParamRaw(ITorqueControlRaw self, int j, double * bemf) -> bool"""
        return _yarp.ITorqueControlRaw_getBemfParamRaw(self, *args)

    def setBemfParamRaw(self, *args):
        """setBemfParamRaw(ITorqueControlRaw self, int j, double bemf) -> bool"""
        return _yarp.ITorqueControlRaw_setBemfParamRaw(self, *args)

    def setTorquePidRaw(self, *args):
        """setTorquePidRaw(ITorqueControlRaw self, int j, Pid pid) -> bool"""
        return _yarp.ITorqueControlRaw_setTorquePidRaw(self, *args)

    def setTorquePidsRaw(self, *args):
        """setTorquePidsRaw(ITorqueControlRaw self, Pid pids) -> bool"""
        return _yarp.ITorqueControlRaw_setTorquePidsRaw(self, *args)

    def setTorqueErrorLimitRaw(self, *args):
        """setTorqueErrorLimitRaw(ITorqueControlRaw self, int j, double limit) -> bool"""
        return _yarp.ITorqueControlRaw_setTorqueErrorLimitRaw(self, *args)

    def setTorqueErrorLimitsRaw(self, *args):
        """setTorqueErrorLimitsRaw(ITorqueControlRaw self, double const * limits) -> bool"""
        return _yarp.ITorqueControlRaw_setTorqueErrorLimitsRaw(self, *args)

    def getTorqueErrorRaw(self, *args):
        """getTorqueErrorRaw(ITorqueControlRaw self, int j, double * err) -> bool"""
        return _yarp.ITorqueControlRaw_getTorqueErrorRaw(self, *args)

    def getTorqueErrorsRaw(self, *args):
        """getTorqueErrorsRaw(ITorqueControlRaw self, double * errs) -> bool"""
        return _yarp.ITorqueControlRaw_getTorqueErrorsRaw(self, *args)

    def getTorquePidOutputRaw(self, *args):
        """getTorquePidOutputRaw(ITorqueControlRaw self, int j, double * out) -> bool"""
        return _yarp.ITorqueControlRaw_getTorquePidOutputRaw(self, *args)

    def getTorquePidOutputsRaw(self, *args):
        """getTorquePidOutputsRaw(ITorqueControlRaw self, double * outs) -> bool"""
        return _yarp.ITorqueControlRaw_getTorquePidOutputsRaw(self, *args)

    def getTorquePidRaw(self, *args):
        """getTorquePidRaw(ITorqueControlRaw self, int j, Pid pid) -> bool"""
        return _yarp.ITorqueControlRaw_getTorquePidRaw(self, *args)

    def getTorquePidsRaw(self, *args):
        """getTorquePidsRaw(ITorqueControlRaw self, Pid pids) -> bool"""
        return _yarp.ITorqueControlRaw_getTorquePidsRaw(self, *args)

    def getTorqueErrorLimitRaw(self, *args):
        """getTorqueErrorLimitRaw(ITorqueControlRaw self, int j, double * limit) -> bool"""
        return _yarp.ITorqueControlRaw_getTorqueErrorLimitRaw(self, *args)

    def getTorqueErrorLimitsRaw(self, *args):
        """getTorqueErrorLimitsRaw(ITorqueControlRaw self, double * limits) -> bool"""
        return _yarp.ITorqueControlRaw_getTorqueErrorLimitsRaw(self, *args)

    def resetTorquePidRaw(self, *args):
        """resetTorquePidRaw(ITorqueControlRaw self, int j) -> bool"""
        return _yarp.ITorqueControlRaw_resetTorquePidRaw(self, *args)

    def disableTorquePidRaw(self, *args):
        """disableTorquePidRaw(ITorqueControlRaw self, int j) -> bool"""
        return _yarp.ITorqueControlRaw_disableTorquePidRaw(self, *args)

    def enableTorquePidRaw(self, *args):
        """enableTorquePidRaw(ITorqueControlRaw self, int j) -> bool"""
        return _yarp.ITorqueControlRaw_enableTorquePidRaw(self, *args)

    def setTorqueOffsetRaw(self, *args):
        """setTorqueOffsetRaw(ITorqueControlRaw self, int j, double v) -> bool"""
        return _yarp.ITorqueControlRaw_setTorqueOffsetRaw(self, *args)

ITorqueControlRaw_swigregister = _yarp.ITorqueControlRaw_swigregister
ITorqueControlRaw_swigregister(ITorqueControlRaw)

class IImpedanceControlRaw(_object):
    """Proxy of C++ yarp::dev::IImpedanceControlRaw class"""
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, IImpedanceControlRaw, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, IImpedanceControlRaw, name)
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _yarp.delete_IImpedanceControlRaw
    __del__ = lambda self : None;
    def getAxes(self, *args):
        """getAxes(IImpedanceControlRaw self, int * ax) -> bool"""
        return _yarp.IImpedanceControlRaw_getAxes(self, *args)

    def getImpedanceRaw(self, *args):
        """getImpedanceRaw(IImpedanceControlRaw self, int j, double * stiffness, double * damping) -> bool"""
        return _yarp.IImpedanceControlRaw_getImpedanceRaw(self, *args)

    def setImpedanceRaw(self, *args):
        """setImpedanceRaw(IImpedanceControlRaw self, int j, double stiffness, double damping) -> bool"""
        return _yarp.IImpedanceControlRaw_setImpedanceRaw(self, *args)

    def setImpedanceOffsetRaw(self, *args):
        """setImpedanceOffsetRaw(IImpedanceControlRaw self, int j, double offset) -> bool"""
        return _yarp.IImpedanceControlRaw_setImpedanceOffsetRaw(self, *args)

    def getImpedanceOffsetRaw(self, *args):
        """getImpedanceOffsetRaw(IImpedanceControlRaw self, int j, double * offset) -> bool"""
        return _yarp.IImpedanceControlRaw_getImpedanceOffsetRaw(self, *args)

    def getCurrentImpedanceLimitRaw(self, *args):
        """getCurrentImpedanceLimitRaw(IImpedanceControlRaw self, int j, double * min_stiff, double * max_stiff, double * min_damp, double * max_damp) -> bool"""
        return _yarp.IImpedanceControlRaw_getCurrentImpedanceLimitRaw(self, *args)

IImpedanceControlRaw_swigregister = _yarp.IImpedanceControlRaw_swigregister
IImpedanceControlRaw_swigregister(IImpedanceControlRaw)

class IImpedanceControl(_object):
    """Proxy of C++ yarp::dev::IImpedanceControl class"""
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, IImpedanceControl, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, IImpedanceControl, name)
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _yarp.delete_IImpedanceControl
    __del__ = lambda self : None;
    def getAxes(self, *args):
        """getAxes(IImpedanceControl self, int * ax) -> bool"""
        return _yarp.IImpedanceControl_getAxes(self, *args)

    def getImpedance(self, *args):
        """getImpedance(IImpedanceControl self, int j, double * stiffness, double * damping) -> bool"""
        return _yarp.IImpedanceControl_getImpedance(self, *args)

    def setImpedance(self, *args):
        """setImpedance(IImpedanceControl self, int j, double stiffness, double damping) -> bool"""
        return _yarp.IImpedanceControl_setImpedance(self, *args)

    def setImpedanceOffset(self, *args):
        """setImpedanceOffset(IImpedanceControl self, int j, double offset) -> bool"""
        return _yarp.IImpedanceControl_setImpedanceOffset(self, *args)

    def getImpedanceOffset(self, *args):
        """getImpedanceOffset(IImpedanceControl self, int j, double * offset) -> bool"""
        return _yarp.IImpedanceControl_getImpedanceOffset(self, *args)

    def getCurrentImpedanceLimit(self, *args):
        """getCurrentImpedanceLimit(IImpedanceControl self, int j, double * min_stiff, double * max_stiff, double * min_damp, double * max_damp) -> bool"""
        return _yarp.IImpedanceControl_getCurrentImpedanceLimit(self, *args)

IImpedanceControl_swigregister = _yarp.IImpedanceControl_swigregister
IImpedanceControl_swigregister(IImpedanceControl)

class IVelocityControlRaw(_object):
    """Proxy of C++ yarp::dev::IVelocityControlRaw class"""
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, IVelocityControlRaw, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, IVelocityControlRaw, name)
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _yarp.delete_IVelocityControlRaw
    __del__ = lambda self : None;
    def getAxes(self, *args):
        """getAxes(IVelocityControlRaw self, int * axis) -> bool"""
        return _yarp.IVelocityControlRaw_getAxes(self, *args)

    def setVelocityModeRaw(self):
        """setVelocityModeRaw(IVelocityControlRaw self) -> bool"""
        return _yarp.IVelocityControlRaw_setVelocityModeRaw(self)

    def velocityMoveRaw(self, *args):
        """
        velocityMoveRaw(IVelocityControlRaw self, int j, double sp) -> bool
        velocityMoveRaw(IVelocityControlRaw self, double const * sp) -> bool
        """
        return _yarp.IVelocityControlRaw_velocityMoveRaw(self, *args)

    def setRefAccelerationRaw(self, *args):
        """setRefAccelerationRaw(IVelocityControlRaw self, int j, double acc) -> bool"""
        return _yarp.IVelocityControlRaw_setRefAccelerationRaw(self, *args)

    def setRefAccelerationsRaw(self, *args):
        """setRefAccelerationsRaw(IVelocityControlRaw self, double const * accs) -> bool"""
        return _yarp.IVelocityControlRaw_setRefAccelerationsRaw(self, *args)

    def getRefAccelerationRaw(self, *args):
        """getRefAccelerationRaw(IVelocityControlRaw self, int j, double * acc) -> bool"""
        return _yarp.IVelocityControlRaw_getRefAccelerationRaw(self, *args)

    def getRefAccelerationsRaw(self, *args):
        """getRefAccelerationsRaw(IVelocityControlRaw self, double * accs) -> bool"""
        return _yarp.IVelocityControlRaw_getRefAccelerationsRaw(self, *args)

    def stopRaw(self, *args):
        """
        stopRaw(IVelocityControlRaw self, int j) -> bool
        stopRaw(IVelocityControlRaw self) -> bool
        """
        return _yarp.IVelocityControlRaw_stopRaw(self, *args)

IVelocityControlRaw_swigregister = _yarp.IVelocityControlRaw_swigregister
IVelocityControlRaw_swigregister(IVelocityControlRaw)

class IVelocityControl(_object):
    """Proxy of C++ yarp::dev::IVelocityControl class"""
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, IVelocityControl, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, IVelocityControl, name)
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _yarp.delete_IVelocityControl
    __del__ = lambda self : None;
    def setVelocityMode(self):
        """setVelocityMode(IVelocityControl self) -> bool"""
        return _yarp.IVelocityControl_setVelocityMode(self)

    def setRefAcceleration(self, *args):
        """setRefAcceleration(IVelocityControl self, int j, double acc) -> bool"""
        return _yarp.IVelocityControl_setRefAcceleration(self, *args)

    def stop(self, *args):
        """
        stop(IVelocityControl self, int j) -> bool
        stop(IVelocityControl self) -> bool
        """
        return _yarp.IVelocityControl_stop(self, *args)

    def getAxes(self, *args):
        """
        getAxes(IVelocityControl self, int * axes) -> bool
        getAxes(IVelocityControl self) -> int
        """
        return _yarp.IVelocityControl_getAxes(self, *args)

    def velocityMove(self, *args):
        """
        velocityMove(IVelocityControl self, int j, double sp) -> bool
        velocityMove(IVelocityControl self, double const * sp) -> bool
        velocityMove(IVelocityControl self, DVector data) -> bool
        """
        return _yarp.IVelocityControl_velocityMove(self, *args)

    def setRefAccelerations(self, *args):
        """
        setRefAccelerations(IVelocityControl self, double const * accs) -> bool
        setRefAccelerations(IVelocityControl self, DVector data) -> bool
        """
        return _yarp.IVelocityControl_setRefAccelerations(self, *args)

    def getRefAcceleration(self, *args):
        """
        getRefAcceleration(IVelocityControl self, int j, double * acc) -> bool
        getRefAcceleration(IVelocityControl self, int j, DVector data) -> bool
        """
        return _yarp.IVelocityControl_getRefAcceleration(self, *args)

    def getRefAccelerations(self, *args):
        """
        getRefAccelerations(IVelocityControl self, double * accs) -> bool
        getRefAccelerations(IVelocityControl self, DVector data) -> bool
        """
        return _yarp.IVelocityControl_getRefAccelerations(self, *args)

IVelocityControl_swigregister = _yarp.IVelocityControl_swigregister
IVelocityControl_swigregister(IVelocityControl)

class IOpenLoopControlRaw(_object):
    """Proxy of C++ yarp::dev::IOpenLoopControlRaw class"""
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, IOpenLoopControlRaw, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, IOpenLoopControlRaw, name)
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _yarp.delete_IOpenLoopControlRaw
    __del__ = lambda self : None;
    def setOutputRaw(self, *args):
        """setOutputRaw(IOpenLoopControlRaw self, int j, double v) -> bool"""
        return _yarp.IOpenLoopControlRaw_setOutputRaw(self, *args)

    def setOutputsRaw(self, *args):
        """setOutputsRaw(IOpenLoopControlRaw self, double const * v) -> bool"""
        return _yarp.IOpenLoopControlRaw_setOutputsRaw(self, *args)

    def getOutputsRaw(self, *args):
        """getOutputsRaw(IOpenLoopControlRaw self, double * v) -> bool"""
        return _yarp.IOpenLoopControlRaw_getOutputsRaw(self, *args)

    def getOutputRaw(self, *args):
        """getOutputRaw(IOpenLoopControlRaw self, int j, double * v) -> bool"""
        return _yarp.IOpenLoopControlRaw_getOutputRaw(self, *args)

    def setOpenLoopModeRaw(self):
        """setOpenLoopModeRaw(IOpenLoopControlRaw self) -> bool"""
        return _yarp.IOpenLoopControlRaw_setOpenLoopModeRaw(self)

IOpenLoopControlRaw_swigregister = _yarp.IOpenLoopControlRaw_swigregister
IOpenLoopControlRaw_swigregister(IOpenLoopControlRaw)

class IOpenLoopControl(_object):
    """Proxy of C++ yarp::dev::IOpenLoopControl class"""
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, IOpenLoopControl, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, IOpenLoopControl, name)
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _yarp.delete_IOpenLoopControl
    __del__ = lambda self : None;
    def setOutput(self, *args):
        """setOutput(IOpenLoopControl self, int j, double v) -> bool"""
        return _yarp.IOpenLoopControl_setOutput(self, *args)

    def setOutputs(self, *args):
        """setOutputs(IOpenLoopControl self, double const * v) -> bool"""
        return _yarp.IOpenLoopControl_setOutputs(self, *args)

    def getOutput(self, *args):
        """getOutput(IOpenLoopControl self, int j, double * v) -> bool"""
        return _yarp.IOpenLoopControl_getOutput(self, *args)

    def getOutputs(self, *args):
        """getOutputs(IOpenLoopControl self, double * v) -> bool"""
        return _yarp.IOpenLoopControl_getOutputs(self, *args)

    def setOpenLoopMode(self):
        """setOpenLoopMode(IOpenLoopControl self) -> bool"""
        return _yarp.IOpenLoopControl_setOpenLoopMode(self)

IOpenLoopControl_swigregister = _yarp.IOpenLoopControl_swigregister
IOpenLoopControl_swigregister(IOpenLoopControl)

class DVector(_object):
    """Proxy of C++ std::vector<(double)> class"""
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, DVector, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, DVector, name)
    __repr__ = _swig_repr
    def iterator(self):
        """iterator(DVector self) -> SwigPyIterator"""
        return _yarp.DVector_iterator(self)

    def __iter__(self): return self.iterator()
    def __nonzero__(self):
        """__nonzero__(DVector self) -> bool"""
        return _yarp.DVector___nonzero__(self)

    def __bool__(self):
        """__bool__(DVector self) -> bool"""
        return _yarp.DVector___bool__(self)

    def __len__(self):
        """__len__(DVector self) -> std::vector< double >::size_type"""
        return _yarp.DVector___len__(self)

    def pop(self):
        """pop(DVector self) -> std::vector< double >::value_type"""
        return _yarp.DVector_pop(self)

    def __getslice__(self, *args):
        """__getslice__(DVector self, std::vector< double >::difference_type i, std::vector< double >::difference_type j) -> DVector"""
        return _yarp.DVector___getslice__(self, *args)

    def __setslice__(self, *args):
        """
        __setslice__(DVector self, std::vector< double >::difference_type i, std::vector< double >::difference_type j, 
            DVector v=std::vector< double,std::allocator< double > >())
        __setslice__(DVector self, std::vector< double >::difference_type i, std::vector< double >::difference_type j)
        """
        return _yarp.DVector___setslice__(self, *args)

    def __delslice__(self, *args):
        """__delslice__(DVector self, std::vector< double >::difference_type i, std::vector< double >::difference_type j)"""
        return _yarp.DVector___delslice__(self, *args)

    def __delitem__(self, *args):
        """
        __delitem__(DVector self, std::vector< double >::difference_type i)
        __delitem__(DVector self, PySliceObject * slice)
        """
        return _yarp.DVector___delitem__(self, *args)

    def __getitem__(self, *args):
        """
        __getitem__(DVector self, PySliceObject * slice) -> DVector
        __getitem__(DVector self, std::vector< double >::difference_type i) -> std::vector< double >::value_type const &
        """
        return _yarp.DVector___getitem__(self, *args)

    def __setitem__(self, *args):
        """
        __setitem__(DVector self, PySliceObject * slice, DVector v)
        __setitem__(DVector self, PySliceObject * slice)
        __setitem__(DVector self, std::vector< double >::difference_type i, std::vector< double >::value_type const & x)
        """
        return _yarp.DVector___setitem__(self, *args)

    def append(self, *args):
        """append(DVector self, std::vector< double >::value_type const & x)"""
        return _yarp.DVector_append(self, *args)

    def empty(self):
        """empty(DVector self) -> bool"""
        return _yarp.DVector_empty(self)

    def size(self):
        """size(DVector self) -> std::vector< double >::size_type"""
        return _yarp.DVector_size(self)

    def clear(self):
        """clear(DVector self)"""
        return _yarp.DVector_clear(self)

    def swap(self, *args):
        """swap(DVector self, DVector v)"""
        return _yarp.DVector_swap(self, *args)

    def get_allocator(self):
        """get_allocator(DVector self) -> std::vector< double >::allocator_type"""
        return _yarp.DVector_get_allocator(self)

    def begin(self):
        """begin(DVector self) -> std::vector< double >::iterator"""
        return _yarp.DVector_begin(self)

    def end(self):
        """end(DVector self) -> std::vector< double >::iterator"""
        return _yarp.DVector_end(self)

    def rbegin(self):
        """rbegin(DVector self) -> std::vector< double >::reverse_iterator"""
        return _yarp.DVector_rbegin(self)

    def rend(self):
        """rend(DVector self) -> std::vector< double >::reverse_iterator"""
        return _yarp.DVector_rend(self)

    def pop_back(self):
        """pop_back(DVector self)"""
        return _yarp.DVector_pop_back(self)

    def erase(self, *args):
        """
        erase(DVector self, std::vector< double >::iterator pos) -> std::vector< double >::iterator
        erase(DVector self, std::vector< double >::iterator first, std::vector< double >::iterator last) -> std::vector< double >::iterator
        """
        return _yarp.DVector_erase(self, *args)

    def __init__(self, *args): 
        """
        __init__(std::vector<(double)> self) -> DVector
        __init__(std::vector<(double)> self, DVector arg2) -> DVector
        __init__(std::vector<(double)> self, std::vector< double >::size_type size) -> DVector
        __init__(std::vector<(double)> self, std::vector< double >::size_type size, std::vector< double >::value_type const & value) -> DVector
        """
        this = _yarp.new_DVector(*args)
        try: self.this.append(this)
        except: self.this = this
    def push_back(self, *args):
        """push_back(DVector self, std::vector< double >::value_type const & x)"""
        return _yarp.DVector_push_back(self, *args)

    def front(self):
        """front(DVector self) -> std::vector< double >::value_type const &"""
        return _yarp.DVector_front(self)

    def back(self):
        """back(DVector self) -> std::vector< double >::value_type const &"""
        return _yarp.DVector_back(self)

    def assign(self, *args):
        """assign(DVector self, std::vector< double >::size_type n, std::vector< double >::value_type const & x)"""
        return _yarp.DVector_assign(self, *args)

    def resize(self, *args):
        """
        resize(DVector self, std::vector< double >::size_type new_size)
        resize(DVector self, std::vector< double >::size_type new_size, std::vector< double >::value_type const & x)
        """
        return _yarp.DVector_resize(self, *args)

    def insert(self, *args):
        """
        insert(DVector self, std::vector< double >::iterator pos, std::vector< double >::value_type const & x) -> std::vector< double >::iterator
        insert(DVector self, std::vector< double >::iterator pos, std::vector< double >::size_type n, std::vector< double >::value_type const & x)
        """
        return _yarp.DVector_insert(self, *args)

    def reserve(self, *args):
        """reserve(DVector self, std::vector< double >::size_type n)"""
        return _yarp.DVector_reserve(self, *args)

    def capacity(self):
        """capacity(DVector self) -> std::vector< double >::size_type"""
        return _yarp.DVector_capacity(self)

    __swig_destroy__ = _yarp.delete_DVector
    __del__ = lambda self : None;
DVector_swigregister = _yarp.DVector_swigregister
DVector_swigregister(DVector)

class BVector(_object):
    """Proxy of C++ std::vector<(bool)> class"""
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, BVector, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, BVector, name)
    __repr__ = _swig_repr
    def iterator(self):
        """iterator(BVector self) -> SwigPyIterator"""
        return _yarp.BVector_iterator(self)

    def __iter__(self): return self.iterator()
    def __nonzero__(self):
        """__nonzero__(BVector self) -> bool"""
        return _yarp.BVector___nonzero__(self)

    def __bool__(self):
        """__bool__(BVector self) -> bool"""
        return _yarp.BVector___bool__(self)

    def __len__(self):
        """__len__(BVector self) -> std::vector< bool >::size_type"""
        return _yarp.BVector___len__(self)

    def pop(self):
        """pop(BVector self) -> std::vector< bool >::value_type"""
        return _yarp.BVector_pop(self)

    def __getslice__(self, *args):
        """__getslice__(BVector self, std::vector< bool >::difference_type i, std::vector< bool >::difference_type j) -> BVector"""
        return _yarp.BVector___getslice__(self, *args)

    def __setslice__(self, *args):
        """
        __setslice__(BVector self, std::vector< bool >::difference_type i, std::vector< bool >::difference_type j, BVector v=std::vector< bool,std::allocator< bool > >())
        __setslice__(BVector self, std::vector< bool >::difference_type i, std::vector< bool >::difference_type j)
        """
        return _yarp.BVector___setslice__(self, *args)

    def __delslice__(self, *args):
        """__delslice__(BVector self, std::vector< bool >::difference_type i, std::vector< bool >::difference_type j)"""
        return _yarp.BVector___delslice__(self, *args)

    def __delitem__(self, *args):
        """
        __delitem__(BVector self, std::vector< bool >::difference_type i)
        __delitem__(BVector self, PySliceObject * slice)
        """
        return _yarp.BVector___delitem__(self, *args)

    def __getitem__(self, *args):
        """
        __getitem__(BVector self, PySliceObject * slice) -> BVector
        __getitem__(BVector self, std::vector< bool >::difference_type i) -> std::vector< bool >::value_type
        """
        return _yarp.BVector___getitem__(self, *args)

    def __setitem__(self, *args):
        """
        __setitem__(BVector self, PySliceObject * slice, BVector v)
        __setitem__(BVector self, PySliceObject * slice)
        __setitem__(BVector self, std::vector< bool >::difference_type i, std::vector< bool >::value_type x)
        """
        return _yarp.BVector___setitem__(self, *args)

    def append(self, *args):
        """append(BVector self, std::vector< bool >::value_type x)"""
        return _yarp.BVector_append(self, *args)

    def empty(self):
        """empty(BVector self) -> bool"""
        return _yarp.BVector_empty(self)

    def size(self):
        """size(BVector self) -> std::vector< bool >::size_type"""
        return _yarp.BVector_size(self)

    def clear(self):
        """clear(BVector self)"""
        return _yarp.BVector_clear(self)

    def swap(self, *args):
        """swap(BVector self, BVector v)"""
        return _yarp.BVector_swap(self, *args)

    def get_allocator(self):
        """get_allocator(BVector self) -> std::vector< bool >::allocator_type"""
        return _yarp.BVector_get_allocator(self)

    def begin(self):
        """begin(BVector self) -> std::vector< bool >::iterator"""
        return _yarp.BVector_begin(self)

    def end(self):
        """end(BVector self) -> std::vector< bool >::iterator"""
        return _yarp.BVector_end(self)

    def rbegin(self):
        """rbegin(BVector self) -> std::vector< bool >::reverse_iterator"""
        return _yarp.BVector_rbegin(self)

    def rend(self):
        """rend(BVector self) -> std::vector< bool >::reverse_iterator"""
        return _yarp.BVector_rend(self)

    def pop_back(self):
        """pop_back(BVector self)"""
        return _yarp.BVector_pop_back(self)

    def erase(self, *args):
        """
        erase(BVector self, std::vector< bool >::iterator pos) -> std::vector< bool >::iterator
        erase(BVector self, std::vector< bool >::iterator first, std::vector< bool >::iterator last) -> std::vector< bool >::iterator
        """
        return _yarp.BVector_erase(self, *args)

    def __init__(self, *args): 
        """
        __init__(std::vector<(bool)> self) -> BVector
        __init__(std::vector<(bool)> self, BVector arg2) -> BVector
        __init__(std::vector<(bool)> self, std::vector< bool >::size_type size) -> BVector
        __init__(std::vector<(bool)> self, std::vector< bool >::size_type size, std::vector< bool >::value_type value) -> BVector
        """
        this = _yarp.new_BVector(*args)
        try: self.this.append(this)
        except: self.this = this
    def push_back(self, *args):
        """push_back(BVector self, std::vector< bool >::value_type x)"""
        return _yarp.BVector_push_back(self, *args)

    def front(self):
        """front(BVector self) -> std::vector< bool >::value_type"""
        return _yarp.BVector_front(self)

    def back(self):
        """back(BVector self) -> std::vector< bool >::value_type"""
        return _yarp.BVector_back(self)

    def assign(self, *args):
        """assign(BVector self, std::vector< bool >::size_type n, std::vector< bool >::value_type x)"""
        return _yarp.BVector_assign(self, *args)

    def resize(self, *args):
        """
        resize(BVector self, std::vector< bool >::size_type new_size)
        resize(BVector self, std::vector< bool >::size_type new_size, std::vector< bool >::value_type x)
        """
        return _yarp.BVector_resize(self, *args)

    def insert(self, *args):
        """
        insert(BVector self, std::vector< bool >::iterator pos, std::vector< bool >::value_type x) -> std::vector< bool >::iterator
        insert(BVector self, std::vector< bool >::iterator pos, std::vector< bool >::size_type n, std::vector< bool >::value_type x)
        """
        return _yarp.BVector_insert(self, *args)

    def reserve(self, *args):
        """reserve(BVector self, std::vector< bool >::size_type n)"""
        return _yarp.BVector_reserve(self, *args)

    def capacity(self):
        """capacity(BVector self) -> std::vector< bool >::size_type"""
        return _yarp.BVector_capacity(self)

    __swig_destroy__ = _yarp.delete_BVector
    __del__ = lambda self : None;
BVector_swigregister = _yarp.BVector_swigregister
BVector_swigregister(BVector)

class SVector(_object):
    """Proxy of C++ std::vector<(std::string)> class"""
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, SVector, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, SVector, name)
    __repr__ = _swig_repr
    def iterator(self):
        """iterator(SVector self) -> SwigPyIterator"""
        return _yarp.SVector_iterator(self)

    def __iter__(self): return self.iterator()
    def __nonzero__(self):
        """__nonzero__(SVector self) -> bool"""
        return _yarp.SVector___nonzero__(self)

    def __bool__(self):
        """__bool__(SVector self) -> bool"""
        return _yarp.SVector___bool__(self)

    def __len__(self):
        """__len__(SVector self) -> std::vector< std::string >::size_type"""
        return _yarp.SVector___len__(self)

    def pop(self):
        """pop(SVector self) -> std::vector< std::string >::value_type"""
        return _yarp.SVector_pop(self)

    def __getslice__(self, *args):
        """__getslice__(SVector self, std::vector< std::string >::difference_type i, std::vector< std::string >::difference_type j) -> SVector"""
        return _yarp.SVector___getslice__(self, *args)

    def __setslice__(self, *args):
        """
        __setslice__(SVector self, std::vector< std::string >::difference_type i, std::vector< std::string >::difference_type j, 
            SVector v=std::vector< std::string,std::allocator< std::string > >())
        __setslice__(SVector self, std::vector< std::string >::difference_type i, std::vector< std::string >::difference_type j)
        """
        return _yarp.SVector___setslice__(self, *args)

    def __delslice__(self, *args):
        """__delslice__(SVector self, std::vector< std::string >::difference_type i, std::vector< std::string >::difference_type j)"""
        return _yarp.SVector___delslice__(self, *args)

    def __delitem__(self, *args):
        """
        __delitem__(SVector self, std::vector< std::string >::difference_type i)
        __delitem__(SVector self, PySliceObject * slice)
        """
        return _yarp.SVector___delitem__(self, *args)

    def __getitem__(self, *args):
        """
        __getitem__(SVector self, PySliceObject * slice) -> SVector
        __getitem__(SVector self, std::vector< std::string >::difference_type i) -> std::vector< std::string >::value_type const &
        """
        return _yarp.SVector___getitem__(self, *args)

    def __setitem__(self, *args):
        """
        __setitem__(SVector self, PySliceObject * slice, SVector v)
        __setitem__(SVector self, PySliceObject * slice)
        __setitem__(SVector self, std::vector< std::string >::difference_type i, std::vector< std::string >::value_type const & x)
        """
        return _yarp.SVector___setitem__(self, *args)

    def append(self, *args):
        """append(SVector self, std::vector< std::string >::value_type const & x)"""
        return _yarp.SVector_append(self, *args)

    def empty(self):
        """empty(SVector self) -> bool"""
        return _yarp.SVector_empty(self)

    def size(self):
        """size(SVector self) -> std::vector< std::string >::size_type"""
        return _yarp.SVector_size(self)

    def clear(self):
        """clear(SVector self)"""
        return _yarp.SVector_clear(self)

    def swap(self, *args):
        """swap(SVector self, SVector v)"""
        return _yarp.SVector_swap(self, *args)

    def get_allocator(self):
        """get_allocator(SVector self) -> std::vector< std::string >::allocator_type"""
        return _yarp.SVector_get_allocator(self)

    def begin(self):
        """begin(SVector self) -> std::vector< std::string >::iterator"""
        return _yarp.SVector_begin(self)

    def end(self):
        """end(SVector self) -> std::vector< std::string >::iterator"""
        return _yarp.SVector_end(self)

    def rbegin(self):
        """rbegin(SVector self) -> std::vector< std::string >::reverse_iterator"""
        return _yarp.SVector_rbegin(self)

    def rend(self):
        """rend(SVector self) -> std::vector< std::string >::reverse_iterator"""
        return _yarp.SVector_rend(self)

    def pop_back(self):
        """pop_back(SVector self)"""
        return _yarp.SVector_pop_back(self)

    def erase(self, *args):
        """
        erase(SVector self, std::vector< std::string >::iterator pos) -> std::vector< std::string >::iterator
        erase(SVector self, std::vector< std::string >::iterator first, std::vector< std::string >::iterator last) -> std::vector< std::string >::iterator
        """
        return _yarp.SVector_erase(self, *args)

    def __init__(self, *args): 
        """
        __init__(std::vector<(std::string)> self) -> SVector
        __init__(std::vector<(std::string)> self, SVector arg2) -> SVector
        __init__(std::vector<(std::string)> self, std::vector< std::string >::size_type size) -> SVector
        __init__(std::vector<(std::string)> self, std::vector< std::string >::size_type size, std::vector< std::string >::value_type const & value) -> SVector
        """
        this = _yarp.new_SVector(*args)
        try: self.this.append(this)
        except: self.this = this
    def push_back(self, *args):
        """push_back(SVector self, std::vector< std::string >::value_type const & x)"""
        return _yarp.SVector_push_back(self, *args)

    def front(self):
        """front(SVector self) -> std::vector< std::string >::value_type const &"""
        return _yarp.SVector_front(self)

    def back(self):
        """back(SVector self) -> std::vector< std::string >::value_type const &"""
        return _yarp.SVector_back(self)

    def assign(self, *args):
        """assign(SVector self, std::vector< std::string >::size_type n, std::vector< std::string >::value_type const & x)"""
        return _yarp.SVector_assign(self, *args)

    def resize(self, *args):
        """
        resize(SVector self, std::vector< std::string >::size_type new_size)
        resize(SVector self, std::vector< std::string >::size_type new_size, std::vector< std::string >::value_type const & x)
        """
        return _yarp.SVector_resize(self, *args)

    def insert(self, *args):
        """
        insert(SVector self, std::vector< std::string >::iterator pos, std::vector< std::string >::value_type const & x) -> std::vector< std::string >::iterator
        insert(SVector self, std::vector< std::string >::iterator pos, std::vector< std::string >::size_type n, 
            std::vector< std::string >::value_type const & x)
        """
        return _yarp.SVector_insert(self, *args)

    def reserve(self, *args):
        """reserve(SVector self, std::vector< std::string >::size_type n)"""
        return _yarp.SVector_reserve(self, *args)

    def capacity(self):
        """capacity(SVector self) -> std::vector< std::string >::size_type"""
        return _yarp.SVector_capacity(self)

    __swig_destroy__ = _yarp.delete_SVector
    __del__ = lambda self : None;
SVector_swigregister = _yarp.SVector_swigregister
SVector_swigregister(SVector)

class PidVector(_object):
    """Proxy of C++ std::vector<(yarp::dev::Pid)> class"""
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, PidVector, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, PidVector, name)
    __repr__ = _swig_repr
    def iterator(self):
        """iterator(PidVector self) -> SwigPyIterator"""
        return _yarp.PidVector_iterator(self)

    def __iter__(self): return self.iterator()
    def __nonzero__(self):
        """__nonzero__(PidVector self) -> bool"""
        return _yarp.PidVector___nonzero__(self)

    def __bool__(self):
        """__bool__(PidVector self) -> bool"""
        return _yarp.PidVector___bool__(self)

    def __len__(self):
        """__len__(PidVector self) -> std::vector< yarp::dev::Pid >::size_type"""
        return _yarp.PidVector___len__(self)

    def pop(self):
        """pop(PidVector self) -> Pid"""
        return _yarp.PidVector_pop(self)

    def __getslice__(self, *args):
        """__getslice__(PidVector self, std::vector< yarp::dev::Pid >::difference_type i, std::vector< yarp::dev::Pid >::difference_type j) -> PidVector"""
        return _yarp.PidVector___getslice__(self, *args)

    def __setslice__(self, *args):
        """
        __setslice__(PidVector self, std::vector< yarp::dev::Pid >::difference_type i, std::vector< yarp::dev::Pid >::difference_type j, 
            PidVector v=std::vector< yarp::dev::Pid,std::allocator< yarp::dev::Pid > >())
        __setslice__(PidVector self, std::vector< yarp::dev::Pid >::difference_type i, std::vector< yarp::dev::Pid >::difference_type j)
        """
        return _yarp.PidVector___setslice__(self, *args)

    def __delslice__(self, *args):
        """__delslice__(PidVector self, std::vector< yarp::dev::Pid >::difference_type i, std::vector< yarp::dev::Pid >::difference_type j)"""
        return _yarp.PidVector___delslice__(self, *args)

    def __delitem__(self, *args):
        """
        __delitem__(PidVector self, std::vector< yarp::dev::Pid >::difference_type i)
        __delitem__(PidVector self, PySliceObject * slice)
        """
        return _yarp.PidVector___delitem__(self, *args)

    def __getitem__(self, *args):
        """
        __getitem__(PidVector self, PySliceObject * slice) -> PidVector
        __getitem__(PidVector self, std::vector< yarp::dev::Pid >::difference_type i) -> Pid
        """
        return _yarp.PidVector___getitem__(self, *args)

    def __setitem__(self, *args):
        """
        __setitem__(PidVector self, PySliceObject * slice, PidVector v)
        __setitem__(PidVector self, PySliceObject * slice)
        __setitem__(PidVector self, std::vector< yarp::dev::Pid >::difference_type i, Pid x)
        """
        return _yarp.PidVector___setitem__(self, *args)

    def append(self, *args):
        """append(PidVector self, Pid x)"""
        return _yarp.PidVector_append(self, *args)

    def empty(self):
        """empty(PidVector self) -> bool"""
        return _yarp.PidVector_empty(self)

    def size(self):
        """size(PidVector self) -> std::vector< yarp::dev::Pid >::size_type"""
        return _yarp.PidVector_size(self)

    def clear(self):
        """clear(PidVector self)"""
        return _yarp.PidVector_clear(self)

    def swap(self, *args):
        """swap(PidVector self, PidVector v)"""
        return _yarp.PidVector_swap(self, *args)

    def get_allocator(self):
        """get_allocator(PidVector self) -> std::vector< yarp::dev::Pid >::allocator_type"""
        return _yarp.PidVector_get_allocator(self)

    def begin(self):
        """begin(PidVector self) -> std::vector< yarp::dev::Pid >::iterator"""
        return _yarp.PidVector_begin(self)

    def end(self):
        """end(PidVector self) -> std::vector< yarp::dev::Pid >::iterator"""
        return _yarp.PidVector_end(self)

    def rbegin(self):
        """rbegin(PidVector self) -> std::vector< yarp::dev::Pid >::reverse_iterator"""
        return _yarp.PidVector_rbegin(self)

    def rend(self):
        """rend(PidVector self) -> std::vector< yarp::dev::Pid >::reverse_iterator"""
        return _yarp.PidVector_rend(self)

    def pop_back(self):
        """pop_back(PidVector self)"""
        return _yarp.PidVector_pop_back(self)

    def erase(self, *args):
        """
        erase(PidVector self, std::vector< yarp::dev::Pid >::iterator pos) -> std::vector< yarp::dev::Pid >::iterator
        erase(PidVector self, std::vector< yarp::dev::Pid >::iterator first, std::vector< yarp::dev::Pid >::iterator last) -> std::vector< yarp::dev::Pid >::iterator
        """
        return _yarp.PidVector_erase(self, *args)

    def __init__(self, *args): 
        """
        __init__(std::vector<(yarp::dev::Pid)> self) -> PidVector
        __init__(std::vector<(yarp::dev::Pid)> self, PidVector arg2) -> PidVector
        __init__(std::vector<(yarp::dev::Pid)> self, std::vector< yarp::dev::Pid >::size_type size) -> PidVector
        __init__(std::vector<(yarp::dev::Pid)> self, std::vector< yarp::dev::Pid >::size_type size, Pid value) -> PidVector
        """
        this = _yarp.new_PidVector(*args)
        try: self.this.append(this)
        except: self.this = this
    def push_back(self, *args):
        """push_back(PidVector self, Pid x)"""
        return _yarp.PidVector_push_back(self, *args)

    def front(self):
        """front(PidVector self) -> Pid"""
        return _yarp.PidVector_front(self)

    def back(self):
        """back(PidVector self) -> Pid"""
        return _yarp.PidVector_back(self)

    def assign(self, *args):
        """assign(PidVector self, std::vector< yarp::dev::Pid >::size_type n, Pid x)"""
        return _yarp.PidVector_assign(self, *args)

    def resize(self, *args):
        """
        resize(PidVector self, std::vector< yarp::dev::Pid >::size_type new_size)
        resize(PidVector self, std::vector< yarp::dev::Pid >::size_type new_size, Pid x)
        """
        return _yarp.PidVector_resize(self, *args)

    def insert(self, *args):
        """
        insert(PidVector self, std::vector< yarp::dev::Pid >::iterator pos, Pid x) -> std::vector< yarp::dev::Pid >::iterator
        insert(PidVector self, std::vector< yarp::dev::Pid >::iterator pos, std::vector< yarp::dev::Pid >::size_type n, 
            Pid x)
        """
        return _yarp.PidVector_insert(self, *args)

    def reserve(self, *args):
        """reserve(PidVector self, std::vector< yarp::dev::Pid >::size_type n)"""
        return _yarp.PidVector_reserve(self, *args)

    def capacity(self):
        """capacity(PidVector self) -> std::vector< yarp::dev::Pid >::size_type"""
        return _yarp.PidVector_capacity(self)

    __swig_destroy__ = _yarp.delete_PidVector
    __del__ = lambda self : None;
PidVector_swigregister = _yarp.PidVector_swigregister
PidVector_swigregister(PidVector)

class ImageRgb(Image):
    """Proxy of C++ yarp::sig::ImageOf<(yarp::sig::PixelRgb)> class"""
    __swig_setmethods__ = {}
    for _s in [Image]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, ImageRgb, name, value)
    __swig_getmethods__ = {}
    for _s in [Image]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, ImageRgb, name)
    __repr__ = _swig_repr
    def getPixelSize(self):
        """getPixelSize(ImageRgb self) -> int"""
        return _yarp.ImageRgb_getPixelSize(self)

    def getPixelCode(self):
        """getPixelCode(ImageRgb self) -> int"""
        return _yarp.ImageRgb_getPixelCode(self)

    def pixel(self, *args):
        """pixel(ImageRgb self, int x, int y) -> PixelRgb"""
        return _yarp.ImageRgb_pixel(self, *args)

    def access(self, *args):
        """access(ImageRgb self, int x, int y) -> PixelRgb"""
        return _yarp.ImageRgb_access(self, *args)

    def safePixel(self, *args):
        """
        safePixel(ImageRgb self, int x, int y) -> PixelRgb
        safePixel(ImageRgb self, int x, int y) -> PixelRgb
        """
        return _yarp.ImageRgb_safePixel(self, *args)

    def __init__(self): 
        """__init__(yarp::sig::ImageOf<(yarp::sig::PixelRgb)> self) -> ImageRgb"""
        this = _yarp.new_ImageRgb()
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _yarp.delete_ImageRgb
    __del__ = lambda self : None;
ImageRgb_swigregister = _yarp.ImageRgb_swigregister
ImageRgb_swigregister(ImageRgb)

class TypedReaderImageRgb(_object):
    """Proxy of C++ yarp::os::TypedReader<(yarp::sig::ImageOf<(yarp::sig::PixelRgb)>)> class"""
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, TypedReaderImageRgb, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, TypedReaderImageRgb, name)
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    def setStrict(self, strict=True):
        """
        setStrict(TypedReaderImageRgb self, bool strict=True)
        setStrict(TypedReaderImageRgb self)
        """
        return _yarp.TypedReaderImageRgb_setStrict(self, strict)

    def read(self, shouldWait=True):
        """
        read(TypedReaderImageRgb self, bool shouldWait=True) -> ImageRgb
        read(TypedReaderImageRgb self) -> ImageRgb
        """
        return _yarp.TypedReaderImageRgb_read(self, shouldWait)

    def interrupt(self):
        """interrupt(TypedReaderImageRgb self)"""
        return _yarp.TypedReaderImageRgb_interrupt(self)

    def lastRead(self):
        """lastRead(TypedReaderImageRgb self) -> ImageRgb"""
        return _yarp.TypedReaderImageRgb_lastRead(self)

    def isClosed(self):
        """isClosed(TypedReaderImageRgb self) -> bool"""
        return _yarp.TypedReaderImageRgb_isClosed(self)

    def useCallback(self, *args):
        """useCallback(TypedReaderImageRgb self, TypedReaderCallbackImageRgb callback)"""
        return _yarp.TypedReaderImageRgb_useCallback(self, *args)

    def disableCallback(self):
        """disableCallback(TypedReaderImageRgb self)"""
        return _yarp.TypedReaderImageRgb_disableCallback(self)

    def getPendingReads(self):
        """getPendingReads(TypedReaderImageRgb self) -> int"""
        return _yarp.TypedReaderImageRgb_getPendingReads(self)

    __swig_destroy__ = _yarp.delete_TypedReaderImageRgb
    __del__ = lambda self : None;
    def getName(self):
        """getName(TypedReaderImageRgb self) -> ConstString"""
        return _yarp.TypedReaderImageRgb_getName(self)

    def setReplier(self, *args):
        """setReplier(TypedReaderImageRgb self, PortReader reader)"""
        return _yarp.TypedReaderImageRgb_setReplier(self, *args)

    def acquire(self):
        """acquire(TypedReaderImageRgb self) -> void *"""
        return _yarp.TypedReaderImageRgb_acquire(self)

    def release(self, *args):
        """release(TypedReaderImageRgb self, void * handle)"""
        return _yarp.TypedReaderImageRgb_release(self, *args)

    def setTargetPeriod(self, *args):
        """setTargetPeriod(TypedReaderImageRgb self, double period)"""
        return _yarp.TypedReaderImageRgb_setTargetPeriod(self, *args)

TypedReaderImageRgb_swigregister = _yarp.TypedReaderImageRgb_swigregister
TypedReaderImageRgb_swigregister(TypedReaderImageRgb)

class TypedReaderCallbackImageRgb(_object):
    """Proxy of C++ yarp::os::TypedReaderCallback<(yarp::sig::ImageOf<(yarp::sig::PixelRgb)>)> class"""
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, TypedReaderCallbackImageRgb, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, TypedReaderCallbackImageRgb, name)
    __repr__ = _swig_repr
    __swig_destroy__ = _yarp.delete_TypedReaderCallbackImageRgb
    __del__ = lambda self : None;
    def onRead(self, *args):
        """
        onRead(TypedReaderCallbackImageRgb self, ImageRgb datum)
        onRead(TypedReaderCallbackImageRgb self, ImageRgb datum, TypedReaderImageRgb reader)
        """
        return _yarp.TypedReaderCallbackImageRgb_onRead(self, *args)

    def __init__(self): 
        """__init__(yarp::os::TypedReaderCallback<(yarp::sig::ImageOf<(yarp::sig::PixelRgb)>)> self) -> TypedReaderCallbackImageRgb"""
        this = _yarp.new_TypedReaderCallbackImageRgb()
        try: self.this.append(this)
        except: self.this = this
TypedReaderCallbackImageRgb_swigregister = _yarp.TypedReaderCallbackImageRgb_swigregister
TypedReaderCallbackImageRgb_swigregister(TypedReaderCallbackImageRgb)

class BufferedPortImageRgb(Contactable,TypedReaderImageRgb,TypedReaderCallbackImageRgb):
    """Proxy of C++ yarp::os::BufferedPort<(yarp::sig::ImageOf<(yarp::sig::PixelRgb)>)> class"""
    __swig_setmethods__ = {}
    for _s in [Contactable,TypedReaderImageRgb,TypedReaderCallbackImageRgb]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, BufferedPortImageRgb, name, value)
    __swig_getmethods__ = {}
    for _s in [Contactable,TypedReaderImageRgb,TypedReaderCallbackImageRgb]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, BufferedPortImageRgb, name)
    __repr__ = _swig_repr
    def __init__(self): 
        """__init__(yarp::os::BufferedPort<(yarp::sig::ImageOf<(yarp::sig::PixelRgb)>)> self) -> BufferedPortImageRgb"""
        this = _yarp.new_BufferedPortImageRgb()
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _yarp.delete_BufferedPortImageRgb
    __del__ = lambda self : None;
    def addOutput(self, *args):
        """
        addOutput(BufferedPortImageRgb self, char const * name) -> bool
        addOutput(BufferedPortImageRgb self, char const * name, char const * carrier) -> bool
        addOutput(BufferedPortImageRgb self, Contact contact) -> bool
        """
        return _yarp.BufferedPortImageRgb_addOutput(self, *args)

    def close(self):
        """close(BufferedPortImageRgb self)"""
        return _yarp.BufferedPortImageRgb_close(self)

    def interrupt(self):
        """interrupt(BufferedPortImageRgb self)"""
        return _yarp.BufferedPortImageRgb_interrupt(self)

    def resume(self):
        """resume(BufferedPortImageRgb self)"""
        return _yarp.BufferedPortImageRgb_resume(self)

    def getPendingReads(self):
        """getPendingReads(BufferedPortImageRgb self) -> int"""
        return _yarp.BufferedPortImageRgb_getPendingReads(self)

    def where(self):
        """where(BufferedPortImageRgb self) -> Contact"""
        return _yarp.BufferedPortImageRgb_where(self)

    def getName(self):
        """getName(BufferedPortImageRgb self) -> ConstString"""
        return _yarp.BufferedPortImageRgb_getName(self)

    def prepare(self):
        """prepare(BufferedPortImageRgb self) -> ImageRgb"""
        return _yarp.BufferedPortImageRgb_prepare(self)

    def unprepare(self):
        """unprepare(BufferedPortImageRgb self) -> bool"""
        return _yarp.BufferedPortImageRgb_unprepare(self)

    def write(self, forceStrict=False):
        """
        write(BufferedPortImageRgb self, bool forceStrict=False)
        write(BufferedPortImageRgb self)
        """
        return _yarp.BufferedPortImageRgb_write(self, forceStrict)

    def writeStrict(self):
        """writeStrict(BufferedPortImageRgb self)"""
        return _yarp.BufferedPortImageRgb_writeStrict(self)

    def setStrict(self, strict=True):
        """
        setStrict(BufferedPortImageRgb self, bool strict=True)
        setStrict(BufferedPortImageRgb self)
        """
        return _yarp.BufferedPortImageRgb_setStrict(self, strict)

    def read(self, shouldWait=True):
        """
        read(BufferedPortImageRgb self, bool shouldWait=True) -> ImageRgb
        read(BufferedPortImageRgb self) -> ImageRgb
        """
        return _yarp.BufferedPortImageRgb_read(self, shouldWait)

    def lastRead(self):
        """lastRead(BufferedPortImageRgb self) -> ImageRgb"""
        return _yarp.BufferedPortImageRgb_lastRead(self)

    def isClosed(self):
        """isClosed(BufferedPortImageRgb self) -> bool"""
        return _yarp.BufferedPortImageRgb_isClosed(self)

    def setReplier(self, *args):
        """setReplier(BufferedPortImageRgb self, PortReader reader)"""
        return _yarp.BufferedPortImageRgb_setReplier(self, *args)

    def setReader(self, *args):
        """setReader(BufferedPortImageRgb self, PortReader reader)"""
        return _yarp.BufferedPortImageRgb_setReader(self, *args)

    def onRead(self, *args):
        """onRead(BufferedPortImageRgb self, ImageRgb datum)"""
        return _yarp.BufferedPortImageRgb_onRead(self, *args)

    def useCallback(self, *args):
        """
        useCallback(BufferedPortImageRgb self, TypedReaderCallbackImageRgb callback)
        useCallback(BufferedPortImageRgb self)
        """
        return _yarp.BufferedPortImageRgb_useCallback(self, *args)

    def disableCallback(self):
        """disableCallback(BufferedPortImageRgb self)"""
        return _yarp.BufferedPortImageRgb_disableCallback(self)

    def setEnvelope(self, *args):
        """setEnvelope(BufferedPortImageRgb self, PortWriter envelope) -> bool"""
        return _yarp.BufferedPortImageRgb_setEnvelope(self, *args)

    def getEnvelope(self, *args):
        """getEnvelope(BufferedPortImageRgb self, PortReader envelope) -> bool"""
        return _yarp.BufferedPortImageRgb_getEnvelope(self, *args)

    def getInputCount(self):
        """getInputCount(BufferedPortImageRgb self) -> int"""
        return _yarp.BufferedPortImageRgb_getInputCount(self)

    def getOutputCount(self):
        """getOutputCount(BufferedPortImageRgb self) -> int"""
        return _yarp.BufferedPortImageRgb_getOutputCount(self)

    def isWriting(self):
        """isWriting(BufferedPortImageRgb self) -> bool"""
        return _yarp.BufferedPortImageRgb_isWriting(self)

    def getReport(self, *args):
        """getReport(BufferedPortImageRgb self, PortReport reporter)"""
        return _yarp.BufferedPortImageRgb_getReport(self, *args)

    def setReporter(self, *args):
        """setReporter(BufferedPortImageRgb self, PortReport reporter)"""
        return _yarp.BufferedPortImageRgb_setReporter(self, *args)

    def acquire(self):
        """acquire(BufferedPortImageRgb self) -> void *"""
        return _yarp.BufferedPortImageRgb_acquire(self)

    def release(self, *args):
        """release(BufferedPortImageRgb self, void * handle)"""
        return _yarp.BufferedPortImageRgb_release(self, *args)

    def setTargetPeriod(self, *args):
        """setTargetPeriod(BufferedPortImageRgb self, double period)"""
        return _yarp.BufferedPortImageRgb_setTargetPeriod(self, *args)

BufferedPortImageRgb_swigregister = _yarp.BufferedPortImageRgb_swigregister
BufferedPortImageRgb_swigregister(BufferedPortImageRgb)

class ImageRgba(Image):
    """Proxy of C++ yarp::sig::ImageOf<(yarp::sig::PixelRgba)> class"""
    __swig_setmethods__ = {}
    for _s in [Image]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, ImageRgba, name, value)
    __swig_getmethods__ = {}
    for _s in [Image]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, ImageRgba, name)
    __repr__ = _swig_repr
    def getPixelSize(self):
        """getPixelSize(ImageRgba self) -> int"""
        return _yarp.ImageRgba_getPixelSize(self)

    def getPixelCode(self):
        """getPixelCode(ImageRgba self) -> int"""
        return _yarp.ImageRgba_getPixelCode(self)

    def pixel(self, *args):
        """pixel(ImageRgba self, int x, int y) -> PixelRgba"""
        return _yarp.ImageRgba_pixel(self, *args)

    def access(self, *args):
        """access(ImageRgba self, int x, int y) -> PixelRgba"""
        return _yarp.ImageRgba_access(self, *args)

    def safePixel(self, *args):
        """
        safePixel(ImageRgba self, int x, int y) -> PixelRgba
        safePixel(ImageRgba self, int x, int y) -> PixelRgba
        """
        return _yarp.ImageRgba_safePixel(self, *args)

    def __init__(self): 
        """__init__(yarp::sig::ImageOf<(yarp::sig::PixelRgba)> self) -> ImageRgba"""
        this = _yarp.new_ImageRgba()
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _yarp.delete_ImageRgba
    __del__ = lambda self : None;
ImageRgba_swigregister = _yarp.ImageRgba_swigregister
ImageRgba_swigregister(ImageRgba)

class TypedReaderImageRgba(_object):
    """Proxy of C++ yarp::os::TypedReader<(yarp::sig::ImageOf<(yarp::sig::PixelRgba)>)> class"""
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, TypedReaderImageRgba, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, TypedReaderImageRgba, name)
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    def setStrict(self, strict=True):
        """
        setStrict(TypedReaderImageRgba self, bool strict=True)
        setStrict(TypedReaderImageRgba self)
        """
        return _yarp.TypedReaderImageRgba_setStrict(self, strict)

    def read(self, shouldWait=True):
        """
        read(TypedReaderImageRgba self, bool shouldWait=True) -> ImageRgba
        read(TypedReaderImageRgba self) -> ImageRgba
        """
        return _yarp.TypedReaderImageRgba_read(self, shouldWait)

    def interrupt(self):
        """interrupt(TypedReaderImageRgba self)"""
        return _yarp.TypedReaderImageRgba_interrupt(self)

    def lastRead(self):
        """lastRead(TypedReaderImageRgba self) -> ImageRgba"""
        return _yarp.TypedReaderImageRgba_lastRead(self)

    def isClosed(self):
        """isClosed(TypedReaderImageRgba self) -> bool"""
        return _yarp.TypedReaderImageRgba_isClosed(self)

    def useCallback(self, *args):
        """useCallback(TypedReaderImageRgba self, TypedReaderCallbackImageRgba callback)"""
        return _yarp.TypedReaderImageRgba_useCallback(self, *args)

    def disableCallback(self):
        """disableCallback(TypedReaderImageRgba self)"""
        return _yarp.TypedReaderImageRgba_disableCallback(self)

    def getPendingReads(self):
        """getPendingReads(TypedReaderImageRgba self) -> int"""
        return _yarp.TypedReaderImageRgba_getPendingReads(self)

    __swig_destroy__ = _yarp.delete_TypedReaderImageRgba
    __del__ = lambda self : None;
    def getName(self):
        """getName(TypedReaderImageRgba self) -> ConstString"""
        return _yarp.TypedReaderImageRgba_getName(self)

    def setReplier(self, *args):
        """setReplier(TypedReaderImageRgba self, PortReader reader)"""
        return _yarp.TypedReaderImageRgba_setReplier(self, *args)

    def acquire(self):
        """acquire(TypedReaderImageRgba self) -> void *"""
        return _yarp.TypedReaderImageRgba_acquire(self)

    def release(self, *args):
        """release(TypedReaderImageRgba self, void * handle)"""
        return _yarp.TypedReaderImageRgba_release(self, *args)

    def setTargetPeriod(self, *args):
        """setTargetPeriod(TypedReaderImageRgba self, double period)"""
        return _yarp.TypedReaderImageRgba_setTargetPeriod(self, *args)

TypedReaderImageRgba_swigregister = _yarp.TypedReaderImageRgba_swigregister
TypedReaderImageRgba_swigregister(TypedReaderImageRgba)

class TypedReaderCallbackImageRgba(_object):
    """Proxy of C++ yarp::os::TypedReaderCallback<(yarp::sig::ImageOf<(yarp::sig::PixelRgba)>)> class"""
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, TypedReaderCallbackImageRgba, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, TypedReaderCallbackImageRgba, name)
    __repr__ = _swig_repr
    __swig_destroy__ = _yarp.delete_TypedReaderCallbackImageRgba
    __del__ = lambda self : None;
    def onRead(self, *args):
        """
        onRead(TypedReaderCallbackImageRgba self, ImageRgba datum)
        onRead(TypedReaderCallbackImageRgba self, ImageRgba datum, TypedReaderImageRgba reader)
        """
        return _yarp.TypedReaderCallbackImageRgba_onRead(self, *args)

    def __init__(self): 
        """__init__(yarp::os::TypedReaderCallback<(yarp::sig::ImageOf<(yarp::sig::PixelRgba)>)> self) -> TypedReaderCallbackImageRgba"""
        this = _yarp.new_TypedReaderCallbackImageRgba()
        try: self.this.append(this)
        except: self.this = this
TypedReaderCallbackImageRgba_swigregister = _yarp.TypedReaderCallbackImageRgba_swigregister
TypedReaderCallbackImageRgba_swigregister(TypedReaderCallbackImageRgba)

class BufferedPortImageRgba(Contactable,TypedReaderImageRgba,TypedReaderCallbackImageRgba):
    """Proxy of C++ yarp::os::BufferedPort<(yarp::sig::ImageOf<(yarp::sig::PixelRgba)>)> class"""
    __swig_setmethods__ = {}
    for _s in [Contactable,TypedReaderImageRgba,TypedReaderCallbackImageRgba]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, BufferedPortImageRgba, name, value)
    __swig_getmethods__ = {}
    for _s in [Contactable,TypedReaderImageRgba,TypedReaderCallbackImageRgba]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, BufferedPortImageRgba, name)
    __repr__ = _swig_repr
    def __init__(self): 
        """__init__(yarp::os::BufferedPort<(yarp::sig::ImageOf<(yarp::sig::PixelRgba)>)> self) -> BufferedPortImageRgba"""
        this = _yarp.new_BufferedPortImageRgba()
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _yarp.delete_BufferedPortImageRgba
    __del__ = lambda self : None;
    def addOutput(self, *args):
        """
        addOutput(BufferedPortImageRgba self, char const * name) -> bool
        addOutput(BufferedPortImageRgba self, char const * name, char const * carrier) -> bool
        addOutput(BufferedPortImageRgba self, Contact contact) -> bool
        """
        return _yarp.BufferedPortImageRgba_addOutput(self, *args)

    def close(self):
        """close(BufferedPortImageRgba self)"""
        return _yarp.BufferedPortImageRgba_close(self)

    def interrupt(self):
        """interrupt(BufferedPortImageRgba self)"""
        return _yarp.BufferedPortImageRgba_interrupt(self)

    def resume(self):
        """resume(BufferedPortImageRgba self)"""
        return _yarp.BufferedPortImageRgba_resume(self)

    def getPendingReads(self):
        """getPendingReads(BufferedPortImageRgba self) -> int"""
        return _yarp.BufferedPortImageRgba_getPendingReads(self)

    def where(self):
        """where(BufferedPortImageRgba self) -> Contact"""
        return _yarp.BufferedPortImageRgba_where(self)

    def getName(self):
        """getName(BufferedPortImageRgba self) -> ConstString"""
        return _yarp.BufferedPortImageRgba_getName(self)

    def prepare(self):
        """prepare(BufferedPortImageRgba self) -> ImageRgba"""
        return _yarp.BufferedPortImageRgba_prepare(self)

    def unprepare(self):
        """unprepare(BufferedPortImageRgba self) -> bool"""
        return _yarp.BufferedPortImageRgba_unprepare(self)

    def write(self, forceStrict=False):
        """
        write(BufferedPortImageRgba self, bool forceStrict=False)
        write(BufferedPortImageRgba self)
        """
        return _yarp.BufferedPortImageRgba_write(self, forceStrict)

    def writeStrict(self):
        """writeStrict(BufferedPortImageRgba self)"""
        return _yarp.BufferedPortImageRgba_writeStrict(self)

    def setStrict(self, strict=True):
        """
        setStrict(BufferedPortImageRgba self, bool strict=True)
        setStrict(BufferedPortImageRgba self)
        """
        return _yarp.BufferedPortImageRgba_setStrict(self, strict)

    def read(self, shouldWait=True):
        """
        read(BufferedPortImageRgba self, bool shouldWait=True) -> ImageRgba
        read(BufferedPortImageRgba self) -> ImageRgba
        """
        return _yarp.BufferedPortImageRgba_read(self, shouldWait)

    def lastRead(self):
        """lastRead(BufferedPortImageRgba self) -> ImageRgba"""
        return _yarp.BufferedPortImageRgba_lastRead(self)

    def isClosed(self):
        """isClosed(BufferedPortImageRgba self) -> bool"""
        return _yarp.BufferedPortImageRgba_isClosed(self)

    def setReplier(self, *args):
        """setReplier(BufferedPortImageRgba self, PortReader reader)"""
        return _yarp.BufferedPortImageRgba_setReplier(self, *args)

    def setReader(self, *args):
        """setReader(BufferedPortImageRgba self, PortReader reader)"""
        return _yarp.BufferedPortImageRgba_setReader(self, *args)

    def onRead(self, *args):
        """onRead(BufferedPortImageRgba self, ImageRgba datum)"""
        return _yarp.BufferedPortImageRgba_onRead(self, *args)

    def useCallback(self, *args):
        """
        useCallback(BufferedPortImageRgba self, TypedReaderCallbackImageRgba callback)
        useCallback(BufferedPortImageRgba self)
        """
        return _yarp.BufferedPortImageRgba_useCallback(self, *args)

    def disableCallback(self):
        """disableCallback(BufferedPortImageRgba self)"""
        return _yarp.BufferedPortImageRgba_disableCallback(self)

    def setEnvelope(self, *args):
        """setEnvelope(BufferedPortImageRgba self, PortWriter envelope) -> bool"""
        return _yarp.BufferedPortImageRgba_setEnvelope(self, *args)

    def getEnvelope(self, *args):
        """getEnvelope(BufferedPortImageRgba self, PortReader envelope) -> bool"""
        return _yarp.BufferedPortImageRgba_getEnvelope(self, *args)

    def getInputCount(self):
        """getInputCount(BufferedPortImageRgba self) -> int"""
        return _yarp.BufferedPortImageRgba_getInputCount(self)

    def getOutputCount(self):
        """getOutputCount(BufferedPortImageRgba self) -> int"""
        return _yarp.BufferedPortImageRgba_getOutputCount(self)

    def isWriting(self):
        """isWriting(BufferedPortImageRgba self) -> bool"""
        return _yarp.BufferedPortImageRgba_isWriting(self)

    def getReport(self, *args):
        """getReport(BufferedPortImageRgba self, PortReport reporter)"""
        return _yarp.BufferedPortImageRgba_getReport(self, *args)

    def setReporter(self, *args):
        """setReporter(BufferedPortImageRgba self, PortReport reporter)"""
        return _yarp.BufferedPortImageRgba_setReporter(self, *args)

    def acquire(self):
        """acquire(BufferedPortImageRgba self) -> void *"""
        return _yarp.BufferedPortImageRgba_acquire(self)

    def release(self, *args):
        """release(BufferedPortImageRgba self, void * handle)"""
        return _yarp.BufferedPortImageRgba_release(self, *args)

    def setTargetPeriod(self, *args):
        """setTargetPeriod(BufferedPortImageRgba self, double period)"""
        return _yarp.BufferedPortImageRgba_setTargetPeriod(self, *args)

BufferedPortImageRgba_swigregister = _yarp.BufferedPortImageRgba_swigregister
BufferedPortImageRgba_swigregister(BufferedPortImageRgba)

class ImageMono(Image):
    """Proxy of C++ yarp::sig::ImageOf<(yarp::sig::PixelMono)> class"""
    __swig_setmethods__ = {}
    for _s in [Image]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, ImageMono, name, value)
    __swig_getmethods__ = {}
    for _s in [Image]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, ImageMono, name)
    __repr__ = _swig_repr
    def getPixelSize(self):
        """getPixelSize(ImageMono self) -> int"""
        return _yarp.ImageMono_getPixelSize(self)

    def getPixelCode(self):
        """getPixelCode(ImageMono self) -> int"""
        return _yarp.ImageMono_getPixelCode(self)

    def pixel(self, *args):
        """pixel(ImageMono self, int x, int y) -> yarp::sig::PixelMono &"""
        return _yarp.ImageMono_pixel(self, *args)

    def access(self, *args):
        """access(ImageMono self, int x, int y) -> yarp::sig::PixelMono &"""
        return _yarp.ImageMono_access(self, *args)

    def safePixel(self, *args):
        """
        safePixel(ImageMono self, int x, int y) -> yarp::sig::PixelMono
        safePixel(ImageMono self, int x, int y) -> yarp::sig::PixelMono const &
        """
        return _yarp.ImageMono_safePixel(self, *args)

    def __init__(self): 
        """__init__(yarp::sig::ImageOf<(yarp::sig::PixelMono)> self) -> ImageMono"""
        this = _yarp.new_ImageMono()
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _yarp.delete_ImageMono
    __del__ = lambda self : None;
ImageMono_swigregister = _yarp.ImageMono_swigregister
ImageMono_swigregister(ImageMono)

class TypedReaderImageMono(_object):
    """Proxy of C++ yarp::os::TypedReader<(yarp::sig::ImageOf<(yarp::sig::PixelMono)>)> class"""
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, TypedReaderImageMono, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, TypedReaderImageMono, name)
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    def setStrict(self, strict=True):
        """
        setStrict(TypedReaderImageMono self, bool strict=True)
        setStrict(TypedReaderImageMono self)
        """
        return _yarp.TypedReaderImageMono_setStrict(self, strict)

    def read(self, shouldWait=True):
        """
        read(TypedReaderImageMono self, bool shouldWait=True) -> ImageMono
        read(TypedReaderImageMono self) -> ImageMono
        """
        return _yarp.TypedReaderImageMono_read(self, shouldWait)

    def interrupt(self):
        """interrupt(TypedReaderImageMono self)"""
        return _yarp.TypedReaderImageMono_interrupt(self)

    def lastRead(self):
        """lastRead(TypedReaderImageMono self) -> ImageMono"""
        return _yarp.TypedReaderImageMono_lastRead(self)

    def isClosed(self):
        """isClosed(TypedReaderImageMono self) -> bool"""
        return _yarp.TypedReaderImageMono_isClosed(self)

    def useCallback(self, *args):
        """useCallback(TypedReaderImageMono self, TypedReaderCallbackImageMono callback)"""
        return _yarp.TypedReaderImageMono_useCallback(self, *args)

    def disableCallback(self):
        """disableCallback(TypedReaderImageMono self)"""
        return _yarp.TypedReaderImageMono_disableCallback(self)

    def getPendingReads(self):
        """getPendingReads(TypedReaderImageMono self) -> int"""
        return _yarp.TypedReaderImageMono_getPendingReads(self)

    __swig_destroy__ = _yarp.delete_TypedReaderImageMono
    __del__ = lambda self : None;
    def getName(self):
        """getName(TypedReaderImageMono self) -> ConstString"""
        return _yarp.TypedReaderImageMono_getName(self)

    def setReplier(self, *args):
        """setReplier(TypedReaderImageMono self, PortReader reader)"""
        return _yarp.TypedReaderImageMono_setReplier(self, *args)

    def acquire(self):
        """acquire(TypedReaderImageMono self) -> void *"""
        return _yarp.TypedReaderImageMono_acquire(self)

    def release(self, *args):
        """release(TypedReaderImageMono self, void * handle)"""
        return _yarp.TypedReaderImageMono_release(self, *args)

    def setTargetPeriod(self, *args):
        """setTargetPeriod(TypedReaderImageMono self, double period)"""
        return _yarp.TypedReaderImageMono_setTargetPeriod(self, *args)

TypedReaderImageMono_swigregister = _yarp.TypedReaderImageMono_swigregister
TypedReaderImageMono_swigregister(TypedReaderImageMono)

class TypedReaderCallbackImageMono(_object):
    """Proxy of C++ yarp::os::TypedReaderCallback<(yarp::sig::ImageOf<(yarp::sig::PixelMono)>)> class"""
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, TypedReaderCallbackImageMono, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, TypedReaderCallbackImageMono, name)
    __repr__ = _swig_repr
    __swig_destroy__ = _yarp.delete_TypedReaderCallbackImageMono
    __del__ = lambda self : None;
    def onRead(self, *args):
        """
        onRead(TypedReaderCallbackImageMono self, ImageMono datum)
        onRead(TypedReaderCallbackImageMono self, ImageMono datum, TypedReaderImageMono reader)
        """
        return _yarp.TypedReaderCallbackImageMono_onRead(self, *args)

    def __init__(self): 
        """__init__(yarp::os::TypedReaderCallback<(yarp::sig::ImageOf<(yarp::sig::PixelMono)>)> self) -> TypedReaderCallbackImageMono"""
        this = _yarp.new_TypedReaderCallbackImageMono()
        try: self.this.append(this)
        except: self.this = this
TypedReaderCallbackImageMono_swigregister = _yarp.TypedReaderCallbackImageMono_swigregister
TypedReaderCallbackImageMono_swigregister(TypedReaderCallbackImageMono)

class BufferedPortImageMono(Contactable,TypedReaderImageMono,TypedReaderCallbackImageMono):
    """Proxy of C++ yarp::os::BufferedPort<(yarp::sig::ImageOf<(yarp::sig::PixelMono)>)> class"""
    __swig_setmethods__ = {}
    for _s in [Contactable,TypedReaderImageMono,TypedReaderCallbackImageMono]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, BufferedPortImageMono, name, value)
    __swig_getmethods__ = {}
    for _s in [Contactable,TypedReaderImageMono,TypedReaderCallbackImageMono]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, BufferedPortImageMono, name)
    __repr__ = _swig_repr
    def __init__(self): 
        """__init__(yarp::os::BufferedPort<(yarp::sig::ImageOf<(yarp::sig::PixelMono)>)> self) -> BufferedPortImageMono"""
        this = _yarp.new_BufferedPortImageMono()
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _yarp.delete_BufferedPortImageMono
    __del__ = lambda self : None;
    def addOutput(self, *args):
        """
        addOutput(BufferedPortImageMono self, char const * name) -> bool
        addOutput(BufferedPortImageMono self, char const * name, char const * carrier) -> bool
        addOutput(BufferedPortImageMono self, Contact contact) -> bool
        """
        return _yarp.BufferedPortImageMono_addOutput(self, *args)

    def close(self):
        """close(BufferedPortImageMono self)"""
        return _yarp.BufferedPortImageMono_close(self)

    def interrupt(self):
        """interrupt(BufferedPortImageMono self)"""
        return _yarp.BufferedPortImageMono_interrupt(self)

    def resume(self):
        """resume(BufferedPortImageMono self)"""
        return _yarp.BufferedPortImageMono_resume(self)

    def getPendingReads(self):
        """getPendingReads(BufferedPortImageMono self) -> int"""
        return _yarp.BufferedPortImageMono_getPendingReads(self)

    def where(self):
        """where(BufferedPortImageMono self) -> Contact"""
        return _yarp.BufferedPortImageMono_where(self)

    def getName(self):
        """getName(BufferedPortImageMono self) -> ConstString"""
        return _yarp.BufferedPortImageMono_getName(self)

    def prepare(self):
        """prepare(BufferedPortImageMono self) -> ImageMono"""
        return _yarp.BufferedPortImageMono_prepare(self)

    def unprepare(self):
        """unprepare(BufferedPortImageMono self) -> bool"""
        return _yarp.BufferedPortImageMono_unprepare(self)

    def write(self, forceStrict=False):
        """
        write(BufferedPortImageMono self, bool forceStrict=False)
        write(BufferedPortImageMono self)
        """
        return _yarp.BufferedPortImageMono_write(self, forceStrict)

    def writeStrict(self):
        """writeStrict(BufferedPortImageMono self)"""
        return _yarp.BufferedPortImageMono_writeStrict(self)

    def setStrict(self, strict=True):
        """
        setStrict(BufferedPortImageMono self, bool strict=True)
        setStrict(BufferedPortImageMono self)
        """
        return _yarp.BufferedPortImageMono_setStrict(self, strict)

    def read(self, shouldWait=True):
        """
        read(BufferedPortImageMono self, bool shouldWait=True) -> ImageMono
        read(BufferedPortImageMono self) -> ImageMono
        """
        return _yarp.BufferedPortImageMono_read(self, shouldWait)

    def lastRead(self):
        """lastRead(BufferedPortImageMono self) -> ImageMono"""
        return _yarp.BufferedPortImageMono_lastRead(self)

    def isClosed(self):
        """isClosed(BufferedPortImageMono self) -> bool"""
        return _yarp.BufferedPortImageMono_isClosed(self)

    def setReplier(self, *args):
        """setReplier(BufferedPortImageMono self, PortReader reader)"""
        return _yarp.BufferedPortImageMono_setReplier(self, *args)

    def setReader(self, *args):
        """setReader(BufferedPortImageMono self, PortReader reader)"""
        return _yarp.BufferedPortImageMono_setReader(self, *args)

    def onRead(self, *args):
        """onRead(BufferedPortImageMono self, ImageMono datum)"""
        return _yarp.BufferedPortImageMono_onRead(self, *args)

    def useCallback(self, *args):
        """
        useCallback(BufferedPortImageMono self, TypedReaderCallbackImageMono callback)
        useCallback(BufferedPortImageMono self)
        """
        return _yarp.BufferedPortImageMono_useCallback(self, *args)

    def disableCallback(self):
        """disableCallback(BufferedPortImageMono self)"""
        return _yarp.BufferedPortImageMono_disableCallback(self)

    def setEnvelope(self, *args):
        """setEnvelope(BufferedPortImageMono self, PortWriter envelope) -> bool"""
        return _yarp.BufferedPortImageMono_setEnvelope(self, *args)

    def getEnvelope(self, *args):
        """getEnvelope(BufferedPortImageMono self, PortReader envelope) -> bool"""
        return _yarp.BufferedPortImageMono_getEnvelope(self, *args)

    def getInputCount(self):
        """getInputCount(BufferedPortImageMono self) -> int"""
        return _yarp.BufferedPortImageMono_getInputCount(self)

    def getOutputCount(self):
        """getOutputCount(BufferedPortImageMono self) -> int"""
        return _yarp.BufferedPortImageMono_getOutputCount(self)

    def isWriting(self):
        """isWriting(BufferedPortImageMono self) -> bool"""
        return _yarp.BufferedPortImageMono_isWriting(self)

    def getReport(self, *args):
        """getReport(BufferedPortImageMono self, PortReport reporter)"""
        return _yarp.BufferedPortImageMono_getReport(self, *args)

    def setReporter(self, *args):
        """setReporter(BufferedPortImageMono self, PortReport reporter)"""
        return _yarp.BufferedPortImageMono_setReporter(self, *args)

    def acquire(self):
        """acquire(BufferedPortImageMono self) -> void *"""
        return _yarp.BufferedPortImageMono_acquire(self)

    def release(self, *args):
        """release(BufferedPortImageMono self, void * handle)"""
        return _yarp.BufferedPortImageMono_release(self, *args)

    def setTargetPeriod(self, *args):
        """setTargetPeriod(BufferedPortImageMono self, double period)"""
        return _yarp.BufferedPortImageMono_setTargetPeriod(self, *args)

BufferedPortImageMono_swigregister = _yarp.BufferedPortImageMono_swigregister
BufferedPortImageMono_swigregister(BufferedPortImageMono)

class TypedReaderSound(_object):
    """Proxy of C++ yarp::os::TypedReader<(yarp::sig::Sound)> class"""
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, TypedReaderSound, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, TypedReaderSound, name)
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    def setStrict(self, strict=True):
        """
        setStrict(TypedReaderSound self, bool strict=True)
        setStrict(TypedReaderSound self)
        """
        return _yarp.TypedReaderSound_setStrict(self, strict)

    def read(self, shouldWait=True):
        """
        read(TypedReaderSound self, bool shouldWait=True) -> Sound
        read(TypedReaderSound self) -> Sound
        """
        return _yarp.TypedReaderSound_read(self, shouldWait)

    def interrupt(self):
        """interrupt(TypedReaderSound self)"""
        return _yarp.TypedReaderSound_interrupt(self)

    def lastRead(self):
        """lastRead(TypedReaderSound self) -> Sound"""
        return _yarp.TypedReaderSound_lastRead(self)

    def isClosed(self):
        """isClosed(TypedReaderSound self) -> bool"""
        return _yarp.TypedReaderSound_isClosed(self)

    def useCallback(self, *args):
        """useCallback(TypedReaderSound self,  callback)"""
        return _yarp.TypedReaderSound_useCallback(self, *args)

    def disableCallback(self):
        """disableCallback(TypedReaderSound self)"""
        return _yarp.TypedReaderSound_disableCallback(self)

    def getPendingReads(self):
        """getPendingReads(TypedReaderSound self) -> int"""
        return _yarp.TypedReaderSound_getPendingReads(self)

    __swig_destroy__ = _yarp.delete_TypedReaderSound
    __del__ = lambda self : None;
    def getName(self):
        """getName(TypedReaderSound self) -> ConstString"""
        return _yarp.TypedReaderSound_getName(self)

    def setReplier(self, *args):
        """setReplier(TypedReaderSound self, PortReader reader)"""
        return _yarp.TypedReaderSound_setReplier(self, *args)

    def acquire(self):
        """acquire(TypedReaderSound self) -> void *"""
        return _yarp.TypedReaderSound_acquire(self)

    def release(self, *args):
        """release(TypedReaderSound self, void * handle)"""
        return _yarp.TypedReaderSound_release(self, *args)

    def setTargetPeriod(self, *args):
        """setTargetPeriod(TypedReaderSound self, double period)"""
        return _yarp.TypedReaderSound_setTargetPeriod(self, *args)

TypedReaderSound_swigregister = _yarp.TypedReaderSound_swigregister
TypedReaderSound_swigregister(TypedReaderSound)

class BufferedPortSound(Contactable,TypedReaderSound):
    """Proxy of C++ yarp::os::BufferedPort<(yarp::sig::Sound)> class"""
    __swig_setmethods__ = {}
    for _s in [Contactable,TypedReaderSound]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, BufferedPortSound, name, value)
    __swig_getmethods__ = {}
    for _s in [Contactable,TypedReaderSound]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, BufferedPortSound, name)
    __repr__ = _swig_repr
    def __init__(self): 
        """__init__(yarp::os::BufferedPort<(yarp::sig::Sound)> self) -> BufferedPortSound"""
        this = _yarp.new_BufferedPortSound()
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _yarp.delete_BufferedPortSound
    __del__ = lambda self : None;
    def addOutput(self, *args):
        """
        addOutput(BufferedPortSound self, char const * name) -> bool
        addOutput(BufferedPortSound self, char const * name, char const * carrier) -> bool
        addOutput(BufferedPortSound self, Contact contact) -> bool
        """
        return _yarp.BufferedPortSound_addOutput(self, *args)

    def close(self):
        """close(BufferedPortSound self)"""
        return _yarp.BufferedPortSound_close(self)

    def interrupt(self):
        """interrupt(BufferedPortSound self)"""
        return _yarp.BufferedPortSound_interrupt(self)

    def resume(self):
        """resume(BufferedPortSound self)"""
        return _yarp.BufferedPortSound_resume(self)

    def getPendingReads(self):
        """getPendingReads(BufferedPortSound self) -> int"""
        return _yarp.BufferedPortSound_getPendingReads(self)

    def where(self):
        """where(BufferedPortSound self) -> Contact"""
        return _yarp.BufferedPortSound_where(self)

    def getName(self):
        """getName(BufferedPortSound self) -> ConstString"""
        return _yarp.BufferedPortSound_getName(self)

    def prepare(self):
        """prepare(BufferedPortSound self) -> Sound"""
        return _yarp.BufferedPortSound_prepare(self)

    def unprepare(self):
        """unprepare(BufferedPortSound self) -> bool"""
        return _yarp.BufferedPortSound_unprepare(self)

    def write(self, forceStrict=False):
        """
        write(BufferedPortSound self, bool forceStrict=False)
        write(BufferedPortSound self)
        """
        return _yarp.BufferedPortSound_write(self, forceStrict)

    def writeStrict(self):
        """writeStrict(BufferedPortSound self)"""
        return _yarp.BufferedPortSound_writeStrict(self)

    def setStrict(self, strict=True):
        """
        setStrict(BufferedPortSound self, bool strict=True)
        setStrict(BufferedPortSound self)
        """
        return _yarp.BufferedPortSound_setStrict(self, strict)

    def read(self, shouldWait=True):
        """
        read(BufferedPortSound self, bool shouldWait=True) -> Sound
        read(BufferedPortSound self) -> Sound
        """
        return _yarp.BufferedPortSound_read(self, shouldWait)

    def lastRead(self):
        """lastRead(BufferedPortSound self) -> Sound"""
        return _yarp.BufferedPortSound_lastRead(self)

    def isClosed(self):
        """isClosed(BufferedPortSound self) -> bool"""
        return _yarp.BufferedPortSound_isClosed(self)

    def setReplier(self, *args):
        """setReplier(BufferedPortSound self, PortReader reader)"""
        return _yarp.BufferedPortSound_setReplier(self, *args)

    def setReader(self, *args):
        """setReader(BufferedPortSound self, PortReader reader)"""
        return _yarp.BufferedPortSound_setReader(self, *args)

    def onRead(self, *args):
        """onRead(BufferedPortSound self, Sound datum)"""
        return _yarp.BufferedPortSound_onRead(self, *args)

    def useCallback(self, *args):
        """
        useCallback(BufferedPortSound self,  callback)
        useCallback(BufferedPortSound self)
        """
        return _yarp.BufferedPortSound_useCallback(self, *args)

    def disableCallback(self):
        """disableCallback(BufferedPortSound self)"""
        return _yarp.BufferedPortSound_disableCallback(self)

    def setEnvelope(self, *args):
        """setEnvelope(BufferedPortSound self, PortWriter envelope) -> bool"""
        return _yarp.BufferedPortSound_setEnvelope(self, *args)

    def getEnvelope(self, *args):
        """getEnvelope(BufferedPortSound self, PortReader envelope) -> bool"""
        return _yarp.BufferedPortSound_getEnvelope(self, *args)

    def getInputCount(self):
        """getInputCount(BufferedPortSound self) -> int"""
        return _yarp.BufferedPortSound_getInputCount(self)

    def getOutputCount(self):
        """getOutputCount(BufferedPortSound self) -> int"""
        return _yarp.BufferedPortSound_getOutputCount(self)

    def isWriting(self):
        """isWriting(BufferedPortSound self) -> bool"""
        return _yarp.BufferedPortSound_isWriting(self)

    def getReport(self, *args):
        """getReport(BufferedPortSound self, PortReport reporter)"""
        return _yarp.BufferedPortSound_getReport(self, *args)

    def setReporter(self, *args):
        """setReporter(BufferedPortSound self, PortReport reporter)"""
        return _yarp.BufferedPortSound_setReporter(self, *args)

    def acquire(self):
        """acquire(BufferedPortSound self) -> void *"""
        return _yarp.BufferedPortSound_acquire(self)

    def release(self, *args):
        """release(BufferedPortSound self, void * handle)"""
        return _yarp.BufferedPortSound_release(self, *args)

    def setTargetPeriod(self, *args):
        """setTargetPeriod(BufferedPortSound self, double period)"""
        return _yarp.BufferedPortSound_setTargetPeriod(self, *args)

BufferedPortSound_swigregister = _yarp.BufferedPortSound_swigregister
BufferedPortSound_swigregister(BufferedPortSound)

class ImageFloat(Image):
    """Proxy of C++ yarp::sig::ImageOf<(yarp::sig::PixelFloat)> class"""
    __swig_setmethods__ = {}
    for _s in [Image]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, ImageFloat, name, value)
    __swig_getmethods__ = {}
    for _s in [Image]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, ImageFloat, name)
    __repr__ = _swig_repr
    def getPixelSize(self):
        """getPixelSize(ImageFloat self) -> int"""
        return _yarp.ImageFloat_getPixelSize(self)

    def getPixelCode(self):
        """getPixelCode(ImageFloat self) -> int"""
        return _yarp.ImageFloat_getPixelCode(self)

    def pixel(self, *args):
        """pixel(ImageFloat self, int x, int y) -> yarp::sig::PixelFloat &"""
        return _yarp.ImageFloat_pixel(self, *args)

    def access(self, *args):
        """access(ImageFloat self, int x, int y) -> yarp::sig::PixelFloat &"""
        return _yarp.ImageFloat_access(self, *args)

    def safePixel(self, *args):
        """
        safePixel(ImageFloat self, int x, int y) -> yarp::sig::PixelFloat
        safePixel(ImageFloat self, int x, int y) -> yarp::sig::PixelFloat const &
        """
        return _yarp.ImageFloat_safePixel(self, *args)

    def getPixel(self, *args):
        """getPixel(ImageFloat self, int x, int y) -> float"""
        return _yarp.ImageFloat_getPixel(self, *args)

    def setPixel(self, *args):
        """setPixel(ImageFloat self, int x, int y, float v)"""
        return _yarp.ImageFloat_setPixel(self, *args)

    def __init__(self): 
        """__init__(yarp::sig::ImageOf<(yarp::sig::PixelFloat)> self) -> ImageFloat"""
        this = _yarp.new_ImageFloat()
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _yarp.delete_ImageFloat
    __del__ = lambda self : None;
ImageFloat_swigregister = _yarp.ImageFloat_swigregister
ImageFloat_swigregister(ImageFloat)

class TypedReaderImageFloat(_object):
    """Proxy of C++ yarp::os::TypedReader<(yarp::sig::ImageOf<(yarp::sig::PixelFloat)>)> class"""
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, TypedReaderImageFloat, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, TypedReaderImageFloat, name)
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    def setStrict(self, strict=True):
        """
        setStrict(TypedReaderImageFloat self, bool strict=True)
        setStrict(TypedReaderImageFloat self)
        """
        return _yarp.TypedReaderImageFloat_setStrict(self, strict)

    def read(self, shouldWait=True):
        """
        read(TypedReaderImageFloat self, bool shouldWait=True) -> ImageFloat
        read(TypedReaderImageFloat self) -> ImageFloat
        """
        return _yarp.TypedReaderImageFloat_read(self, shouldWait)

    def interrupt(self):
        """interrupt(TypedReaderImageFloat self)"""
        return _yarp.TypedReaderImageFloat_interrupt(self)

    def lastRead(self):
        """lastRead(TypedReaderImageFloat self) -> ImageFloat"""
        return _yarp.TypedReaderImageFloat_lastRead(self)

    def isClosed(self):
        """isClosed(TypedReaderImageFloat self) -> bool"""
        return _yarp.TypedReaderImageFloat_isClosed(self)

    def useCallback(self, *args):
        """useCallback(TypedReaderImageFloat self, TypedReaderCallbackImageFloat callback)"""
        return _yarp.TypedReaderImageFloat_useCallback(self, *args)

    def disableCallback(self):
        """disableCallback(TypedReaderImageFloat self)"""
        return _yarp.TypedReaderImageFloat_disableCallback(self)

    def getPendingReads(self):
        """getPendingReads(TypedReaderImageFloat self) -> int"""
        return _yarp.TypedReaderImageFloat_getPendingReads(self)

    __swig_destroy__ = _yarp.delete_TypedReaderImageFloat
    __del__ = lambda self : None;
    def getName(self):
        """getName(TypedReaderImageFloat self) -> ConstString"""
        return _yarp.TypedReaderImageFloat_getName(self)

    def setReplier(self, *args):
        """setReplier(TypedReaderImageFloat self, PortReader reader)"""
        return _yarp.TypedReaderImageFloat_setReplier(self, *args)

    def acquire(self):
        """acquire(TypedReaderImageFloat self) -> void *"""
        return _yarp.TypedReaderImageFloat_acquire(self)

    def release(self, *args):
        """release(TypedReaderImageFloat self, void * handle)"""
        return _yarp.TypedReaderImageFloat_release(self, *args)

    def setTargetPeriod(self, *args):
        """setTargetPeriod(TypedReaderImageFloat self, double period)"""
        return _yarp.TypedReaderImageFloat_setTargetPeriod(self, *args)

TypedReaderImageFloat_swigregister = _yarp.TypedReaderImageFloat_swigregister
TypedReaderImageFloat_swigregister(TypedReaderImageFloat)

class TypedReaderCallbackImageFloat(_object):
    """Proxy of C++ yarp::os::TypedReaderCallback<(yarp::sig::ImageOf<(yarp::sig::PixelFloat)>)> class"""
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, TypedReaderCallbackImageFloat, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, TypedReaderCallbackImageFloat, name)
    __repr__ = _swig_repr
    __swig_destroy__ = _yarp.delete_TypedReaderCallbackImageFloat
    __del__ = lambda self : None;
    def onRead(self, *args):
        """
        onRead(TypedReaderCallbackImageFloat self, ImageFloat datum)
        onRead(TypedReaderCallbackImageFloat self, ImageFloat datum, TypedReaderImageFloat reader)
        """
        return _yarp.TypedReaderCallbackImageFloat_onRead(self, *args)

    def __init__(self): 
        """__init__(yarp::os::TypedReaderCallback<(yarp::sig::ImageOf<(yarp::sig::PixelFloat)>)> self) -> TypedReaderCallbackImageFloat"""
        this = _yarp.new_TypedReaderCallbackImageFloat()
        try: self.this.append(this)
        except: self.this = this
TypedReaderCallbackImageFloat_swigregister = _yarp.TypedReaderCallbackImageFloat_swigregister
TypedReaderCallbackImageFloat_swigregister(TypedReaderCallbackImageFloat)

class BufferedPortImageFloat(Contactable,TypedReaderImageFloat,TypedReaderCallbackImageFloat):
    """Proxy of C++ yarp::os::BufferedPort<(yarp::sig::ImageOf<(yarp::sig::PixelFloat)>)> class"""
    __swig_setmethods__ = {}
    for _s in [Contactable,TypedReaderImageFloat,TypedReaderCallbackImageFloat]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, BufferedPortImageFloat, name, value)
    __swig_getmethods__ = {}
    for _s in [Contactable,TypedReaderImageFloat,TypedReaderCallbackImageFloat]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, BufferedPortImageFloat, name)
    __repr__ = _swig_repr
    def __init__(self): 
        """__init__(yarp::os::BufferedPort<(yarp::sig::ImageOf<(yarp::sig::PixelFloat)>)> self) -> BufferedPortImageFloat"""
        this = _yarp.new_BufferedPortImageFloat()
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _yarp.delete_BufferedPortImageFloat
    __del__ = lambda self : None;
    def addOutput(self, *args):
        """
        addOutput(BufferedPortImageFloat self, char const * name) -> bool
        addOutput(BufferedPortImageFloat self, char const * name, char const * carrier) -> bool
        addOutput(BufferedPortImageFloat self, Contact contact) -> bool
        """
        return _yarp.BufferedPortImageFloat_addOutput(self, *args)

    def close(self):
        """close(BufferedPortImageFloat self)"""
        return _yarp.BufferedPortImageFloat_close(self)

    def interrupt(self):
        """interrupt(BufferedPortImageFloat self)"""
        return _yarp.BufferedPortImageFloat_interrupt(self)

    def resume(self):
        """resume(BufferedPortImageFloat self)"""
        return _yarp.BufferedPortImageFloat_resume(self)

    def getPendingReads(self):
        """getPendingReads(BufferedPortImageFloat self) -> int"""
        return _yarp.BufferedPortImageFloat_getPendingReads(self)

    def where(self):
        """where(BufferedPortImageFloat self) -> Contact"""
        return _yarp.BufferedPortImageFloat_where(self)

    def getName(self):
        """getName(BufferedPortImageFloat self) -> ConstString"""
        return _yarp.BufferedPortImageFloat_getName(self)

    def prepare(self):
        """prepare(BufferedPortImageFloat self) -> ImageFloat"""
        return _yarp.BufferedPortImageFloat_prepare(self)

    def unprepare(self):
        """unprepare(BufferedPortImageFloat self) -> bool"""
        return _yarp.BufferedPortImageFloat_unprepare(self)

    def write(self, forceStrict=False):
        """
        write(BufferedPortImageFloat self, bool forceStrict=False)
        write(BufferedPortImageFloat self)
        """
        return _yarp.BufferedPortImageFloat_write(self, forceStrict)

    def writeStrict(self):
        """writeStrict(BufferedPortImageFloat self)"""
        return _yarp.BufferedPortImageFloat_writeStrict(self)

    def setStrict(self, strict=True):
        """
        setStrict(BufferedPortImageFloat self, bool strict=True)
        setStrict(BufferedPortImageFloat self)
        """
        return _yarp.BufferedPortImageFloat_setStrict(self, strict)

    def read(self, shouldWait=True):
        """
        read(BufferedPortImageFloat self, bool shouldWait=True) -> ImageFloat
        read(BufferedPortImageFloat self) -> ImageFloat
        """
        return _yarp.BufferedPortImageFloat_read(self, shouldWait)

    def lastRead(self):
        """lastRead(BufferedPortImageFloat self) -> ImageFloat"""
        return _yarp.BufferedPortImageFloat_lastRead(self)

    def isClosed(self):
        """isClosed(BufferedPortImageFloat self) -> bool"""
        return _yarp.BufferedPortImageFloat_isClosed(self)

    def setReplier(self, *args):
        """setReplier(BufferedPortImageFloat self, PortReader reader)"""
        return _yarp.BufferedPortImageFloat_setReplier(self, *args)

    def setReader(self, *args):
        """setReader(BufferedPortImageFloat self, PortReader reader)"""
        return _yarp.BufferedPortImageFloat_setReader(self, *args)

    def onRead(self, *args):
        """onRead(BufferedPortImageFloat self, ImageFloat datum)"""
        return _yarp.BufferedPortImageFloat_onRead(self, *args)

    def useCallback(self, *args):
        """
        useCallback(BufferedPortImageFloat self, TypedReaderCallbackImageFloat callback)
        useCallback(BufferedPortImageFloat self)
        """
        return _yarp.BufferedPortImageFloat_useCallback(self, *args)

    def disableCallback(self):
        """disableCallback(BufferedPortImageFloat self)"""
        return _yarp.BufferedPortImageFloat_disableCallback(self)

    def setEnvelope(self, *args):
        """setEnvelope(BufferedPortImageFloat self, PortWriter envelope) -> bool"""
        return _yarp.BufferedPortImageFloat_setEnvelope(self, *args)

    def getEnvelope(self, *args):
        """getEnvelope(BufferedPortImageFloat self, PortReader envelope) -> bool"""
        return _yarp.BufferedPortImageFloat_getEnvelope(self, *args)

    def getInputCount(self):
        """getInputCount(BufferedPortImageFloat self) -> int"""
        return _yarp.BufferedPortImageFloat_getInputCount(self)

    def getOutputCount(self):
        """getOutputCount(BufferedPortImageFloat self) -> int"""
        return _yarp.BufferedPortImageFloat_getOutputCount(self)

    def isWriting(self):
        """isWriting(BufferedPortImageFloat self) -> bool"""
        return _yarp.BufferedPortImageFloat_isWriting(self)

    def getReport(self, *args):
        """getReport(BufferedPortImageFloat self, PortReport reporter)"""
        return _yarp.BufferedPortImageFloat_getReport(self, *args)

    def setReporter(self, *args):
        """setReporter(BufferedPortImageFloat self, PortReport reporter)"""
        return _yarp.BufferedPortImageFloat_setReporter(self, *args)

    def acquire(self):
        """acquire(BufferedPortImageFloat self) -> void *"""
        return _yarp.BufferedPortImageFloat_acquire(self)

    def release(self, *args):
        """release(BufferedPortImageFloat self, void * handle)"""
        return _yarp.BufferedPortImageFloat_release(self, *args)

    def setTargetPeriod(self, *args):
        """setTargetPeriod(BufferedPortImageFloat self, double period)"""
        return _yarp.BufferedPortImageFloat_setTargetPeriod(self, *args)

BufferedPortImageFloat_swigregister = _yarp.BufferedPortImageFloat_swigregister
BufferedPortImageFloat_swigregister(BufferedPortImageFloat)

class ImageRgbFloat(Image):
    """Proxy of C++ yarp::sig::ImageOf<(yarp::sig::PixelRgbFloat)> class"""
    __swig_setmethods__ = {}
    for _s in [Image]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, ImageRgbFloat, name, value)
    __swig_getmethods__ = {}
    for _s in [Image]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, ImageRgbFloat, name)
    __repr__ = _swig_repr
    def getPixelSize(self):
        """getPixelSize(ImageRgbFloat self) -> int"""
        return _yarp.ImageRgbFloat_getPixelSize(self)

    def getPixelCode(self):
        """getPixelCode(ImageRgbFloat self) -> int"""
        return _yarp.ImageRgbFloat_getPixelCode(self)

    def pixel(self, *args):
        """pixel(ImageRgbFloat self, int x, int y) -> PixelRgbFloat"""
        return _yarp.ImageRgbFloat_pixel(self, *args)

    def access(self, *args):
        """access(ImageRgbFloat self, int x, int y) -> PixelRgbFloat"""
        return _yarp.ImageRgbFloat_access(self, *args)

    def safePixel(self, *args):
        """
        safePixel(ImageRgbFloat self, int x, int y) -> PixelRgbFloat
        safePixel(ImageRgbFloat self, int x, int y) -> PixelRgbFloat
        """
        return _yarp.ImageRgbFloat_safePixel(self, *args)

    def __init__(self): 
        """__init__(yarp::sig::ImageOf<(yarp::sig::PixelRgbFloat)> self) -> ImageRgbFloat"""
        this = _yarp.new_ImageRgbFloat()
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _yarp.delete_ImageRgbFloat
    __del__ = lambda self : None;
ImageRgbFloat_swigregister = _yarp.ImageRgbFloat_swigregister
ImageRgbFloat_swigregister(ImageRgbFloat)

class TypedReaderImageRgbFloat(_object):
    """Proxy of C++ yarp::os::TypedReader<(yarp::sig::ImageOf<(yarp::sig::PixelRgbFloat)>)> class"""
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, TypedReaderImageRgbFloat, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, TypedReaderImageRgbFloat, name)
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    def setStrict(self, strict=True):
        """
        setStrict(TypedReaderImageRgbFloat self, bool strict=True)
        setStrict(TypedReaderImageRgbFloat self)
        """
        return _yarp.TypedReaderImageRgbFloat_setStrict(self, strict)

    def read(self, shouldWait=True):
        """
        read(TypedReaderImageRgbFloat self, bool shouldWait=True) -> ImageRgbFloat
        read(TypedReaderImageRgbFloat self) -> ImageRgbFloat
        """
        return _yarp.TypedReaderImageRgbFloat_read(self, shouldWait)

    def interrupt(self):
        """interrupt(TypedReaderImageRgbFloat self)"""
        return _yarp.TypedReaderImageRgbFloat_interrupt(self)

    def lastRead(self):
        """lastRead(TypedReaderImageRgbFloat self) -> ImageRgbFloat"""
        return _yarp.TypedReaderImageRgbFloat_lastRead(self)

    def isClosed(self):
        """isClosed(TypedReaderImageRgbFloat self) -> bool"""
        return _yarp.TypedReaderImageRgbFloat_isClosed(self)

    def useCallback(self, *args):
        """useCallback(TypedReaderImageRgbFloat self, TypedReaderCallbackImageRgbFloat callback)"""
        return _yarp.TypedReaderImageRgbFloat_useCallback(self, *args)

    def disableCallback(self):
        """disableCallback(TypedReaderImageRgbFloat self)"""
        return _yarp.TypedReaderImageRgbFloat_disableCallback(self)

    def getPendingReads(self):
        """getPendingReads(TypedReaderImageRgbFloat self) -> int"""
        return _yarp.TypedReaderImageRgbFloat_getPendingReads(self)

    __swig_destroy__ = _yarp.delete_TypedReaderImageRgbFloat
    __del__ = lambda self : None;
    def getName(self):
        """getName(TypedReaderImageRgbFloat self) -> ConstString"""
        return _yarp.TypedReaderImageRgbFloat_getName(self)

    def setReplier(self, *args):
        """setReplier(TypedReaderImageRgbFloat self, PortReader reader)"""
        return _yarp.TypedReaderImageRgbFloat_setReplier(self, *args)

    def acquire(self):
        """acquire(TypedReaderImageRgbFloat self) -> void *"""
        return _yarp.TypedReaderImageRgbFloat_acquire(self)

    def release(self, *args):
        """release(TypedReaderImageRgbFloat self, void * handle)"""
        return _yarp.TypedReaderImageRgbFloat_release(self, *args)

    def setTargetPeriod(self, *args):
        """setTargetPeriod(TypedReaderImageRgbFloat self, double period)"""
        return _yarp.TypedReaderImageRgbFloat_setTargetPeriod(self, *args)

TypedReaderImageRgbFloat_swigregister = _yarp.TypedReaderImageRgbFloat_swigregister
TypedReaderImageRgbFloat_swigregister(TypedReaderImageRgbFloat)

class TypedReaderCallbackImageRgbFloat(_object):
    """Proxy of C++ yarp::os::TypedReaderCallback<(yarp::sig::ImageOf<(yarp::sig::PixelRgbFloat)>)> class"""
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, TypedReaderCallbackImageRgbFloat, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, TypedReaderCallbackImageRgbFloat, name)
    __repr__ = _swig_repr
    __swig_destroy__ = _yarp.delete_TypedReaderCallbackImageRgbFloat
    __del__ = lambda self : None;
    def onRead(self, *args):
        """
        onRead(TypedReaderCallbackImageRgbFloat self, ImageRgbFloat datum)
        onRead(TypedReaderCallbackImageRgbFloat self, ImageRgbFloat datum, TypedReaderImageRgbFloat reader)
        """
        return _yarp.TypedReaderCallbackImageRgbFloat_onRead(self, *args)

    def __init__(self): 
        """__init__(yarp::os::TypedReaderCallback<(yarp::sig::ImageOf<(yarp::sig::PixelRgbFloat)>)> self) -> TypedReaderCallbackImageRgbFloat"""
        this = _yarp.new_TypedReaderCallbackImageRgbFloat()
        try: self.this.append(this)
        except: self.this = this
TypedReaderCallbackImageRgbFloat_swigregister = _yarp.TypedReaderCallbackImageRgbFloat_swigregister
TypedReaderCallbackImageRgbFloat_swigregister(TypedReaderCallbackImageRgbFloat)

class BufferedPortImageRgbFloat(Contactable,TypedReaderImageRgbFloat,TypedReaderCallbackImageRgbFloat):
    """Proxy of C++ yarp::os::BufferedPort<(yarp::sig::ImageOf<(yarp::sig::PixelRgbFloat)>)> class"""
    __swig_setmethods__ = {}
    for _s in [Contactable,TypedReaderImageRgbFloat,TypedReaderCallbackImageRgbFloat]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, BufferedPortImageRgbFloat, name, value)
    __swig_getmethods__ = {}
    for _s in [Contactable,TypedReaderImageRgbFloat,TypedReaderCallbackImageRgbFloat]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, BufferedPortImageRgbFloat, name)
    __repr__ = _swig_repr
    def __init__(self): 
        """__init__(yarp::os::BufferedPort<(yarp::sig::ImageOf<(yarp::sig::PixelRgbFloat)>)> self) -> BufferedPortImageRgbFloat"""
        this = _yarp.new_BufferedPortImageRgbFloat()
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _yarp.delete_BufferedPortImageRgbFloat
    __del__ = lambda self : None;
    def addOutput(self, *args):
        """
        addOutput(BufferedPortImageRgbFloat self, char const * name) -> bool
        addOutput(BufferedPortImageRgbFloat self, char const * name, char const * carrier) -> bool
        addOutput(BufferedPortImageRgbFloat self, Contact contact) -> bool
        """
        return _yarp.BufferedPortImageRgbFloat_addOutput(self, *args)

    def close(self):
        """close(BufferedPortImageRgbFloat self)"""
        return _yarp.BufferedPortImageRgbFloat_close(self)

    def interrupt(self):
        """interrupt(BufferedPortImageRgbFloat self)"""
        return _yarp.BufferedPortImageRgbFloat_interrupt(self)

    def resume(self):
        """resume(BufferedPortImageRgbFloat self)"""
        return _yarp.BufferedPortImageRgbFloat_resume(self)

    def getPendingReads(self):
        """getPendingReads(BufferedPortImageRgbFloat self) -> int"""
        return _yarp.BufferedPortImageRgbFloat_getPendingReads(self)

    def where(self):
        """where(BufferedPortImageRgbFloat self) -> Contact"""
        return _yarp.BufferedPortImageRgbFloat_where(self)

    def getName(self):
        """getName(BufferedPortImageRgbFloat self) -> ConstString"""
        return _yarp.BufferedPortImageRgbFloat_getName(self)

    def prepare(self):
        """prepare(BufferedPortImageRgbFloat self) -> ImageRgbFloat"""
        return _yarp.BufferedPortImageRgbFloat_prepare(self)

    def unprepare(self):
        """unprepare(BufferedPortImageRgbFloat self) -> bool"""
        return _yarp.BufferedPortImageRgbFloat_unprepare(self)

    def write(self, forceStrict=False):
        """
        write(BufferedPortImageRgbFloat self, bool forceStrict=False)
        write(BufferedPortImageRgbFloat self)
        """
        return _yarp.BufferedPortImageRgbFloat_write(self, forceStrict)

    def writeStrict(self):
        """writeStrict(BufferedPortImageRgbFloat self)"""
        return _yarp.BufferedPortImageRgbFloat_writeStrict(self)

    def setStrict(self, strict=True):
        """
        setStrict(BufferedPortImageRgbFloat self, bool strict=True)
        setStrict(BufferedPortImageRgbFloat self)
        """
        return _yarp.BufferedPortImageRgbFloat_setStrict(self, strict)

    def read(self, shouldWait=True):
        """
        read(BufferedPortImageRgbFloat self, bool shouldWait=True) -> ImageRgbFloat
        read(BufferedPortImageRgbFloat self) -> ImageRgbFloat
        """
        return _yarp.BufferedPortImageRgbFloat_read(self, shouldWait)

    def lastRead(self):
        """lastRead(BufferedPortImageRgbFloat self) -> ImageRgbFloat"""
        return _yarp.BufferedPortImageRgbFloat_lastRead(self)

    def isClosed(self):
        """isClosed(BufferedPortImageRgbFloat self) -> bool"""
        return _yarp.BufferedPortImageRgbFloat_isClosed(self)

    def setReplier(self, *args):
        """setReplier(BufferedPortImageRgbFloat self, PortReader reader)"""
        return _yarp.BufferedPortImageRgbFloat_setReplier(self, *args)

    def setReader(self, *args):
        """setReader(BufferedPortImageRgbFloat self, PortReader reader)"""
        return _yarp.BufferedPortImageRgbFloat_setReader(self, *args)

    def onRead(self, *args):
        """onRead(BufferedPortImageRgbFloat self, ImageRgbFloat datum)"""
        return _yarp.BufferedPortImageRgbFloat_onRead(self, *args)

    def useCallback(self, *args):
        """
        useCallback(BufferedPortImageRgbFloat self, TypedReaderCallbackImageRgbFloat callback)
        useCallback(BufferedPortImageRgbFloat self)
        """
        return _yarp.BufferedPortImageRgbFloat_useCallback(self, *args)

    def disableCallback(self):
        """disableCallback(BufferedPortImageRgbFloat self)"""
        return _yarp.BufferedPortImageRgbFloat_disableCallback(self)

    def setEnvelope(self, *args):
        """setEnvelope(BufferedPortImageRgbFloat self, PortWriter envelope) -> bool"""
        return _yarp.BufferedPortImageRgbFloat_setEnvelope(self, *args)

    def getEnvelope(self, *args):
        """getEnvelope(BufferedPortImageRgbFloat self, PortReader envelope) -> bool"""
        return _yarp.BufferedPortImageRgbFloat_getEnvelope(self, *args)

    def getInputCount(self):
        """getInputCount(BufferedPortImageRgbFloat self) -> int"""
        return _yarp.BufferedPortImageRgbFloat_getInputCount(self)

    def getOutputCount(self):
        """getOutputCount(BufferedPortImageRgbFloat self) -> int"""
        return _yarp.BufferedPortImageRgbFloat_getOutputCount(self)

    def isWriting(self):
        """isWriting(BufferedPortImageRgbFloat self) -> bool"""
        return _yarp.BufferedPortImageRgbFloat_isWriting(self)

    def getReport(self, *args):
        """getReport(BufferedPortImageRgbFloat self, PortReport reporter)"""
        return _yarp.BufferedPortImageRgbFloat_getReport(self, *args)

    def setReporter(self, *args):
        """setReporter(BufferedPortImageRgbFloat self, PortReport reporter)"""
        return _yarp.BufferedPortImageRgbFloat_setReporter(self, *args)

    def acquire(self):
        """acquire(BufferedPortImageRgbFloat self) -> void *"""
        return _yarp.BufferedPortImageRgbFloat_acquire(self)

    def release(self, *args):
        """release(BufferedPortImageRgbFloat self, void * handle)"""
        return _yarp.BufferedPortImageRgbFloat_release(self, *args)

    def setTargetPeriod(self, *args):
        """setTargetPeriod(BufferedPortImageRgbFloat self, double period)"""
        return _yarp.BufferedPortImageRgbFloat_setTargetPeriod(self, *args)

BufferedPortImageRgbFloat_swigregister = _yarp.BufferedPortImageRgbFloat_swigregister
BufferedPortImageRgbFloat_swigregister(BufferedPortImageRgbFloat)

# This file is compatible with both classic and new-style classes.


